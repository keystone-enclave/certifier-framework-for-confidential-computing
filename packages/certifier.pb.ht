// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: certifier.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_certifier_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_certifier_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3011000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3011004 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/inlined_string_field.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_certifier_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_certifier_2eproto {
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::AuxillaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTable schema[45]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::FieldMetadata field_metadata[];
  static const ::PROTOBUF_NAMESPACE_ID::internal::SerializationTable serialization_table[];
  static const ::PROTOBUF_NAMESPACE_ID::uint32 offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_certifier_2eproto;
class app_request;
class app_requestDefaultTypeInternal;
extern app_requestDefaultTypeInternal _app_request_default_instance_;
class app_response;
class app_responseDefaultTypeInternal;
extern app_responseDefaultTypeInternal _app_response_default_instance_;
class attestation_user_data;
class attestation_user_dataDefaultTypeInternal;
extern attestation_user_dataDefaultTypeInternal _attestation_user_data_default_instance_;
class buffer_sequence;
class buffer_sequenceDefaultTypeInternal;
extern buffer_sequenceDefaultTypeInternal _buffer_sequence_default_instance_;
class certifier_rules;
class certifier_rulesDefaultTypeInternal;
extern certifier_rulesDefaultTypeInternal _certifier_rules_default_instance_;
class channel_key_message;
class channel_key_messageDefaultTypeInternal;
extern channel_key_messageDefaultTypeInternal _channel_key_message_default_instance_;
class claim_message;
class claim_messageDefaultTypeInternal;
extern claim_messageDefaultTypeInternal _claim_message_default_instance_;
class claims_sequence;
class claims_sequenceDefaultTypeInternal;
extern claims_sequenceDefaultTypeInternal _claims_sequence_default_instance_;
class ecc_message;
class ecc_messageDefaultTypeInternal;
extern ecc_messageDefaultTypeInternal _ecc_message_default_instance_;
class entity_message;
class entity_messageDefaultTypeInternal;
extern entity_messageDefaultTypeInternal _entity_message_default_instance_;
class environment;
class environmentDefaultTypeInternal;
extern environmentDefaultTypeInternal _environment_default_instance_;
class evidence;
class evidenceDefaultTypeInternal;
extern evidenceDefaultTypeInternal _evidence_default_instance_;
class evidence_list;
class evidence_listDefaultTypeInternal;
extern evidence_listDefaultTypeInternal _evidence_list_default_instance_;
class evidence_package;
class evidence_packageDefaultTypeInternal;
extern evidence_packageDefaultTypeInternal _evidence_package_default_instance_;
class gramine_attestation_message;
class gramine_attestation_messageDefaultTypeInternal;
extern gramine_attestation_messageDefaultTypeInternal _gramine_attestation_message_default_instance_;
class key_message;
class key_messageDefaultTypeInternal;
extern key_messageDefaultTypeInternal _key_message_default_instance_;
class keystone_attestation_message;
class keystone_attestation_messageDefaultTypeInternal;
extern keystone_attestation_messageDefaultTypeInternal _keystone_attestation_message_default_instance_;
class platform;
class platformDefaultTypeInternal;
extern platformDefaultTypeInternal _platform_default_instance_;
class point_message;
class point_messageDefaultTypeInternal;
extern point_messageDefaultTypeInternal _point_message_default_instance_;
class policy_store_message;
class policy_store_messageDefaultTypeInternal;
extern policy_store_messageDefaultTypeInternal _policy_store_message_default_instance_;
class proof;
class proofDefaultTypeInternal;
extern proofDefaultTypeInternal _proof_default_instance_;
class proof_step;
class proof_stepDefaultTypeInternal;
extern proof_stepDefaultTypeInternal _proof_step_default_instance_;
class properties;
class propertiesDefaultTypeInternal;
extern propertiesDefaultTypeInternal _properties_default_instance_;
class property;
class propertyDefaultTypeInternal;
extern propertyDefaultTypeInternal _property_default_instance_;
class protected_blob_message;
class protected_blob_messageDefaultTypeInternal;
extern protected_blob_messageDefaultTypeInternal _protected_blob_message_default_instance_;
class proved_statements;
class proved_statementsDefaultTypeInternal;
extern proved_statementsDefaultTypeInternal _proved_statements_default_instance_;
class rsa_message;
class rsa_messageDefaultTypeInternal;
extern rsa_messageDefaultTypeInternal _rsa_message_default_instance_;
class run_request;
class run_requestDefaultTypeInternal;
extern run_requestDefaultTypeInternal _run_request_default_instance_;
class run_response;
class run_responseDefaultTypeInternal;
extern run_responseDefaultTypeInternal _run_response_default_instance_;
class sev_attestation_message;
class sev_attestation_messageDefaultTypeInternal;
extern sev_attestation_messageDefaultTypeInternal _sev_attestation_message_default_instance_;
class signed_claim_message;
class signed_claim_messageDefaultTypeInternal;
extern signed_claim_messageDefaultTypeInternal _signed_claim_message_default_instance_;
class signed_claim_sequence;
class signed_claim_sequenceDefaultTypeInternal;
extern signed_claim_sequenceDefaultTypeInternal _signed_claim_sequence_default_instance_;
class signed_report;
class signed_reportDefaultTypeInternal;
extern signed_reportDefaultTypeInternal _signed_report_default_instance_;
class storage_info_message;
class storage_info_messageDefaultTypeInternal;
extern storage_info_messageDefaultTypeInternal _storage_info_message_default_instance_;
class tagged_blob_message;
class tagged_blob_messageDefaultTypeInternal;
extern tagged_blob_messageDefaultTypeInternal _tagged_blob_message_default_instance_;
class tagged_claim;
class tagged_claimDefaultTypeInternal;
extern tagged_claimDefaultTypeInternal _tagged_claim_default_instance_;
class tagged_claims_sequence;
class tagged_claims_sequenceDefaultTypeInternal;
extern tagged_claims_sequenceDefaultTypeInternal _tagged_claims_sequence_default_instance_;
class tagged_signed_claim;
class tagged_signed_claimDefaultTypeInternal;
extern tagged_signed_claimDefaultTypeInternal _tagged_signed_claim_default_instance_;
class time_point;
class time_pointDefaultTypeInternal;
extern time_pointDefaultTypeInternal _time_point_default_instance_;
class trust_request_message;
class trust_request_messageDefaultTypeInternal;
extern trust_request_messageDefaultTypeInternal _trust_request_message_default_instance_;
class trust_response_message;
class trust_response_messageDefaultTypeInternal;
extern trust_response_messageDefaultTypeInternal _trust_response_message_default_instance_;
class trusted_service_message;
class trusted_service_messageDefaultTypeInternal;
extern trusted_service_messageDefaultTypeInternal _trusted_service_message_default_instance_;
class vse_attestation_report_info;
class vse_attestation_report_infoDefaultTypeInternal;
extern vse_attestation_report_infoDefaultTypeInternal _vse_attestation_report_info_default_instance_;
class vse_clause;
class vse_clauseDefaultTypeInternal;
extern vse_clauseDefaultTypeInternal _vse_clause_default_instance_;
class vse_clauses;
class vse_clausesDefaultTypeInternal;
extern vse_clausesDefaultTypeInternal _vse_clauses_default_instance_;
PROTOBUF_NAMESPACE_OPEN
template<> ::app_request* Arena::CreateMaybeMessage<::app_request>(Arena*);
template<> ::app_response* Arena::CreateMaybeMessage<::app_response>(Arena*);
template<> ::attestation_user_data* Arena::CreateMaybeMessage<::attestation_user_data>(Arena*);
template<> ::buffer_sequence* Arena::CreateMaybeMessage<::buffer_sequence>(Arena*);
template<> ::certifier_rules* Arena::CreateMaybeMessage<::certifier_rules>(Arena*);
template<> ::channel_key_message* Arena::CreateMaybeMessage<::channel_key_message>(Arena*);
template<> ::claim_message* Arena::CreateMaybeMessage<::claim_message>(Arena*);
template<> ::claims_sequence* Arena::CreateMaybeMessage<::claims_sequence>(Arena*);
template<> ::ecc_message* Arena::CreateMaybeMessage<::ecc_message>(Arena*);
template<> ::entity_message* Arena::CreateMaybeMessage<::entity_message>(Arena*);
template<> ::environment* Arena::CreateMaybeMessage<::environment>(Arena*);
template<> ::evidence* Arena::CreateMaybeMessage<::evidence>(Arena*);
template<> ::evidence_list* Arena::CreateMaybeMessage<::evidence_list>(Arena*);
template<> ::evidence_package* Arena::CreateMaybeMessage<::evidence_package>(Arena*);
template<> ::gramine_attestation_message* Arena::CreateMaybeMessage<::gramine_attestation_message>(Arena*);
template<> ::key_message* Arena::CreateMaybeMessage<::key_message>(Arena*);
template<> ::keystone_attestation_message* Arena::CreateMaybeMessage<::keystone_attestation_message>(Arena*);
template<> ::platform* Arena::CreateMaybeMessage<::platform>(Arena*);
template<> ::point_message* Arena::CreateMaybeMessage<::point_message>(Arena*);
template<> ::policy_store_message* Arena::CreateMaybeMessage<::policy_store_message>(Arena*);
template<> ::proof* Arena::CreateMaybeMessage<::proof>(Arena*);
template<> ::proof_step* Arena::CreateMaybeMessage<::proof_step>(Arena*);
template<> ::properties* Arena::CreateMaybeMessage<::properties>(Arena*);
template<> ::property* Arena::CreateMaybeMessage<::property>(Arena*);
template<> ::protected_blob_message* Arena::CreateMaybeMessage<::protected_blob_message>(Arena*);
template<> ::proved_statements* Arena::CreateMaybeMessage<::proved_statements>(Arena*);
template<> ::rsa_message* Arena::CreateMaybeMessage<::rsa_message>(Arena*);
template<> ::run_request* Arena::CreateMaybeMessage<::run_request>(Arena*);
template<> ::run_response* Arena::CreateMaybeMessage<::run_response>(Arena*);
template<> ::sev_attestation_message* Arena::CreateMaybeMessage<::sev_attestation_message>(Arena*);
template<> ::signed_claim_message* Arena::CreateMaybeMessage<::signed_claim_message>(Arena*);
template<> ::signed_claim_sequence* Arena::CreateMaybeMessage<::signed_claim_sequence>(Arena*);
template<> ::signed_report* Arena::CreateMaybeMessage<::signed_report>(Arena*);
template<> ::storage_info_message* Arena::CreateMaybeMessage<::storage_info_message>(Arena*);
template<> ::tagged_blob_message* Arena::CreateMaybeMessage<::tagged_blob_message>(Arena*);
template<> ::tagged_claim* Arena::CreateMaybeMessage<::tagged_claim>(Arena*);
template<> ::tagged_claims_sequence* Arena::CreateMaybeMessage<::tagged_claims_sequence>(Arena*);
template<> ::tagged_signed_claim* Arena::CreateMaybeMessage<::tagged_signed_claim>(Arena*);
template<> ::time_point* Arena::CreateMaybeMessage<::time_point>(Arena*);
template<> ::trust_request_message* Arena::CreateMaybeMessage<::trust_request_message>(Arena*);
template<> ::trust_response_message* Arena::CreateMaybeMessage<::trust_response_message>(Arena*);
template<> ::trusted_service_message* Arena::CreateMaybeMessage<::trusted_service_message>(Arena*);
template<> ::vse_attestation_report_info* Arena::CreateMaybeMessage<::vse_attestation_report_info>(Arena*);
template<> ::vse_clause* Arena::CreateMaybeMessage<::vse_clause>(Arena*);
template<> ::vse_clauses* Arena::CreateMaybeMessage<::vse_clauses>(Arena*);
PROTOBUF_NAMESPACE_CLOSE

// ===================================================================

class time_point :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:time_point) */ {
 public:
  time_point();
  virtual ~time_point();

  time_point(const time_point& from);
  time_point(time_point&& from) noexcept
    : time_point() {
    *this = ::std::move(from);
  }

  inline time_point& operator=(const time_point& from) {
    CopyFrom(from);
    return *this;
  }
  inline time_point& operator=(time_point&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const time_point& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const time_point* internal_default_instance() {
    return reinterpret_cast<const time_point*>(
               &_time_point_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(time_point& a, time_point& b) {
    a.Swap(&b);
  }
  inline void Swap(time_point* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline time_point* New() const final {
    return CreateMaybeMessage<time_point>(nullptr);
  }

  time_point* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<time_point>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const time_point& from);
  void MergeFrom(const time_point& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(time_point* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "time_point";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_certifier_2eproto);
    return ::descriptor_table_certifier_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kYearFieldNumber = 1,
    kMonthFieldNumber = 2,
    kDayFieldNumber = 3,
    kHourFieldNumber = 4,
    kSecondsFieldNumber = 6,
    kMinuteFieldNumber = 5,
  };
  // optional int32 year = 1;
  bool has_year() const;
  private:
  bool _internal_has_year() const;
  public:
  void clear_year();
  ::PROTOBUF_NAMESPACE_ID::int32 year() const;
  void set_year(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_year() const;
  void _internal_set_year(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // optional int32 month = 2;
  bool has_month() const;
  private:
  bool _internal_has_month() const;
  public:
  void clear_month();
  ::PROTOBUF_NAMESPACE_ID::int32 month() const;
  void set_month(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_month() const;
  void _internal_set_month(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // optional int32 day = 3;
  bool has_day() const;
  private:
  bool _internal_has_day() const;
  public:
  void clear_day();
  ::PROTOBUF_NAMESPACE_ID::int32 day() const;
  void set_day(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_day() const;
  void _internal_set_day(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // optional int32 hour = 4;
  bool has_hour() const;
  private:
  bool _internal_has_hour() const;
  public:
  void clear_hour();
  ::PROTOBUF_NAMESPACE_ID::int32 hour() const;
  void set_hour(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_hour() const;
  void _internal_set_hour(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // optional double seconds = 6;
  bool has_seconds() const;
  private:
  bool _internal_has_seconds() const;
  public:
  void clear_seconds();
  double seconds() const;
  void set_seconds(double value);
  private:
  double _internal_seconds() const;
  void _internal_set_seconds(double value);
  public:

  // optional int32 minute = 5;
  bool has_minute() const;
  private:
  bool _internal_has_minute() const;
  public:
  void clear_minute();
  ::PROTOBUF_NAMESPACE_ID::int32 minute() const;
  void set_minute(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_minute() const;
  void _internal_set_minute(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // @@protoc_insertion_point(class_scope:time_point)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::int32 year_;
  ::PROTOBUF_NAMESPACE_ID::int32 month_;
  ::PROTOBUF_NAMESPACE_ID::int32 day_;
  ::PROTOBUF_NAMESPACE_ID::int32 hour_;
  double seconds_;
  ::PROTOBUF_NAMESPACE_ID::int32 minute_;
  friend struct ::TableStruct_certifier_2eproto;
};
// -------------------------------------------------------------------

class rsa_message :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:rsa_message) */ {
 public:
  rsa_message();
  virtual ~rsa_message();

  rsa_message(const rsa_message& from);
  rsa_message(rsa_message&& from) noexcept
    : rsa_message() {
    *this = ::std::move(from);
  }

  inline rsa_message& operator=(const rsa_message& from) {
    CopyFrom(from);
    return *this;
  }
  inline rsa_message& operator=(rsa_message&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const rsa_message& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const rsa_message* internal_default_instance() {
    return reinterpret_cast<const rsa_message*>(
               &_rsa_message_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(rsa_message& a, rsa_message& b) {
    a.Swap(&b);
  }
  inline void Swap(rsa_message* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline rsa_message* New() const final {
    return CreateMaybeMessage<rsa_message>(nullptr);
  }

  rsa_message* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<rsa_message>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const rsa_message& from);
  void MergeFrom(const rsa_message& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(rsa_message* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "rsa_message";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_certifier_2eproto);
    return ::descriptor_table_certifier_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPublicModulusFieldNumber = 1,
    kPublicExponentFieldNumber = 2,
    kPrivateExponentFieldNumber = 3,
    kPrivatePFieldNumber = 4,
    kPrivateQFieldNumber = 5,
    kPrivateDpFieldNumber = 6,
    kPrivateDqFieldNumber = 7,
    kPrivateIqmpFieldNumber = 8,
  };
  // optional bytes public_modulus = 1;
  bool has_public_modulus() const;
  private:
  bool _internal_has_public_modulus() const;
  public:
  void clear_public_modulus();
  const std::string& public_modulus() const;
  void set_public_modulus(const std::string& value);
  void set_public_modulus(std::string&& value);
  void set_public_modulus(const char* value);
  void set_public_modulus(const void* value, size_t size);
  std::string* mutable_public_modulus();
  std::string* release_public_modulus();
  void set_allocated_public_modulus(std::string* public_modulus);
  private:
  const std::string& _internal_public_modulus() const;
  void _internal_set_public_modulus(const std::string& value);
  std::string* _internal_mutable_public_modulus();
  public:

  // optional bytes public_exponent = 2;
  bool has_public_exponent() const;
  private:
  bool _internal_has_public_exponent() const;
  public:
  void clear_public_exponent();
  const std::string& public_exponent() const;
  void set_public_exponent(const std::string& value);
  void set_public_exponent(std::string&& value);
  void set_public_exponent(const char* value);
  void set_public_exponent(const void* value, size_t size);
  std::string* mutable_public_exponent();
  std::string* release_public_exponent();
  void set_allocated_public_exponent(std::string* public_exponent);
  private:
  const std::string& _internal_public_exponent() const;
  void _internal_set_public_exponent(const std::string& value);
  std::string* _internal_mutable_public_exponent();
  public:

  // optional bytes private_exponent = 3;
  bool has_private_exponent() const;
  private:
  bool _internal_has_private_exponent() const;
  public:
  void clear_private_exponent();
  const std::string& private_exponent() const;
  void set_private_exponent(const std::string& value);
  void set_private_exponent(std::string&& value);
  void set_private_exponent(const char* value);
  void set_private_exponent(const void* value, size_t size);
  std::string* mutable_private_exponent();
  std::string* release_private_exponent();
  void set_allocated_private_exponent(std::string* private_exponent);
  private:
  const std::string& _internal_private_exponent() const;
  void _internal_set_private_exponent(const std::string& value);
  std::string* _internal_mutable_private_exponent();
  public:

  // optional bytes private_p = 4;
  bool has_private_p() const;
  private:
  bool _internal_has_private_p() const;
  public:
  void clear_private_p();
  const std::string& private_p() const;
  void set_private_p(const std::string& value);
  void set_private_p(std::string&& value);
  void set_private_p(const char* value);
  void set_private_p(const void* value, size_t size);
  std::string* mutable_private_p();
  std::string* release_private_p();
  void set_allocated_private_p(std::string* private_p);
  private:
  const std::string& _internal_private_p() const;
  void _internal_set_private_p(const std::string& value);
  std::string* _internal_mutable_private_p();
  public:

  // optional bytes private_q = 5;
  bool has_private_q() const;
  private:
  bool _internal_has_private_q() const;
  public:
  void clear_private_q();
  const std::string& private_q() const;
  void set_private_q(const std::string& value);
  void set_private_q(std::string&& value);
  void set_private_q(const char* value);
  void set_private_q(const void* value, size_t size);
  std::string* mutable_private_q();
  std::string* release_private_q();
  void set_allocated_private_q(std::string* private_q);
  private:
  const std::string& _internal_private_q() const;
  void _internal_set_private_q(const std::string& value);
  std::string* _internal_mutable_private_q();
  public:

  // optional bytes private_dp = 6;
  bool has_private_dp() const;
  private:
  bool _internal_has_private_dp() const;
  public:
  void clear_private_dp();
  const std::string& private_dp() const;
  void set_private_dp(const std::string& value);
  void set_private_dp(std::string&& value);
  void set_private_dp(const char* value);
  void set_private_dp(const void* value, size_t size);
  std::string* mutable_private_dp();
  std::string* release_private_dp();
  void set_allocated_private_dp(std::string* private_dp);
  private:
  const std::string& _internal_private_dp() const;
  void _internal_set_private_dp(const std::string& value);
  std::string* _internal_mutable_private_dp();
  public:

  // optional bytes private_dq = 7;
  bool has_private_dq() const;
  private:
  bool _internal_has_private_dq() const;
  public:
  void clear_private_dq();
  const std::string& private_dq() const;
  void set_private_dq(const std::string& value);
  void set_private_dq(std::string&& value);
  void set_private_dq(const char* value);
  void set_private_dq(const void* value, size_t size);
  std::string* mutable_private_dq();
  std::string* release_private_dq();
  void set_allocated_private_dq(std::string* private_dq);
  private:
  const std::string& _internal_private_dq() const;
  void _internal_set_private_dq(const std::string& value);
  std::string* _internal_mutable_private_dq();
  public:

  // optional bytes private_iqmp = 8;
  bool has_private_iqmp() const;
  private:
  bool _internal_has_private_iqmp() const;
  public:
  void clear_private_iqmp();
  const std::string& private_iqmp() const;
  void set_private_iqmp(const std::string& value);
  void set_private_iqmp(std::string&& value);
  void set_private_iqmp(const char* value);
  void set_private_iqmp(const void* value, size_t size);
  std::string* mutable_private_iqmp();
  std::string* release_private_iqmp();
  void set_allocated_private_iqmp(std::string* private_iqmp);
  private:
  const std::string& _internal_private_iqmp() const;
  void _internal_set_private_iqmp(const std::string& value);
  std::string* _internal_mutable_private_iqmp();
  public:

  // @@protoc_insertion_point(class_scope:rsa_message)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr public_modulus_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr public_exponent_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr private_exponent_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr private_p_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr private_q_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr private_dp_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr private_dq_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr private_iqmp_;
  friend struct ::TableStruct_certifier_2eproto;
};
// -------------------------------------------------------------------

class point_message :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:point_message) */ {
 public:
  point_message();
  virtual ~point_message();

  point_message(const point_message& from);
  point_message(point_message&& from) noexcept
    : point_message() {
    *this = ::std::move(from);
  }

  inline point_message& operator=(const point_message& from) {
    CopyFrom(from);
    return *this;
  }
  inline point_message& operator=(point_message&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const point_message& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const point_message* internal_default_instance() {
    return reinterpret_cast<const point_message*>(
               &_point_message_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(point_message& a, point_message& b) {
    a.Swap(&b);
  }
  inline void Swap(point_message* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline point_message* New() const final {
    return CreateMaybeMessage<point_message>(nullptr);
  }

  point_message* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<point_message>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const point_message& from);
  void MergeFrom(const point_message& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(point_message* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "point_message";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_certifier_2eproto);
    return ::descriptor_table_certifier_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kXFieldNumber = 1,
    kYFieldNumber = 2,
  };
  // optional bytes x = 1;
  bool has_x() const;
  private:
  bool _internal_has_x() const;
  public:
  void clear_x();
  const std::string& x() const;
  void set_x(const std::string& value);
  void set_x(std::string&& value);
  void set_x(const char* value);
  void set_x(const void* value, size_t size);
  std::string* mutable_x();
  std::string* release_x();
  void set_allocated_x(std::string* x);
  private:
  const std::string& _internal_x() const;
  void _internal_set_x(const std::string& value);
  std::string* _internal_mutable_x();
  public:

  // optional bytes y = 2;
  bool has_y() const;
  private:
  bool _internal_has_y() const;
  public:
  void clear_y();
  const std::string& y() const;
  void set_y(const std::string& value);
  void set_y(std::string&& value);
  void set_y(const char* value);
  void set_y(const void* value, size_t size);
  std::string* mutable_y();
  std::string* release_y();
  void set_allocated_y(std::string* y);
  private:
  const std::string& _internal_y() const;
  void _internal_set_y(const std::string& value);
  std::string* _internal_mutable_y();
  public:

  // @@protoc_insertion_point(class_scope:point_message)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr x_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr y_;
  friend struct ::TableStruct_certifier_2eproto;
};
// -------------------------------------------------------------------

class ecc_message :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ecc_message) */ {
 public:
  ecc_message();
  virtual ~ecc_message();

  ecc_message(const ecc_message& from);
  ecc_message(ecc_message&& from) noexcept
    : ecc_message() {
    *this = ::std::move(from);
  }

  inline ecc_message& operator=(const ecc_message& from) {
    CopyFrom(from);
    return *this;
  }
  inline ecc_message& operator=(ecc_message&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const ecc_message& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ecc_message* internal_default_instance() {
    return reinterpret_cast<const ecc_message*>(
               &_ecc_message_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(ecc_message& a, ecc_message& b) {
    a.Swap(&b);
  }
  inline void Swap(ecc_message* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ecc_message* New() const final {
    return CreateMaybeMessage<ecc_message>(nullptr);
  }

  ecc_message* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ecc_message>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const ecc_message& from);
  void MergeFrom(const ecc_message& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ecc_message* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ecc_message";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_certifier_2eproto);
    return ::descriptor_table_certifier_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCurveNameFieldNumber = 1,
    kCurvePFieldNumber = 2,
    kCurveAFieldNumber = 3,
    kCurveBFieldNumber = 4,
    kOrderOfBasePointFieldNumber = 7,
    kPrivateMultiplierFieldNumber = 8,
    kBasePointFieldNumber = 5,
    kPublicPointFieldNumber = 6,
  };
  // optional string curve_name = 1;
  bool has_curve_name() const;
  private:
  bool _internal_has_curve_name() const;
  public:
  void clear_curve_name();
  const std::string& curve_name() const;
  void set_curve_name(const std::string& value);
  void set_curve_name(std::string&& value);
  void set_curve_name(const char* value);
  void set_curve_name(const char* value, size_t size);
  std::string* mutable_curve_name();
  std::string* release_curve_name();
  void set_allocated_curve_name(std::string* curve_name);
  private:
  const std::string& _internal_curve_name() const;
  void _internal_set_curve_name(const std::string& value);
  std::string* _internal_mutable_curve_name();
  public:

  // optional bytes curve_p = 2;
  bool has_curve_p() const;
  private:
  bool _internal_has_curve_p() const;
  public:
  void clear_curve_p();
  const std::string& curve_p() const;
  void set_curve_p(const std::string& value);
  void set_curve_p(std::string&& value);
  void set_curve_p(const char* value);
  void set_curve_p(const void* value, size_t size);
  std::string* mutable_curve_p();
  std::string* release_curve_p();
  void set_allocated_curve_p(std::string* curve_p);
  private:
  const std::string& _internal_curve_p() const;
  void _internal_set_curve_p(const std::string& value);
  std::string* _internal_mutable_curve_p();
  public:

  // optional bytes curve_a = 3;
  bool has_curve_a() const;
  private:
  bool _internal_has_curve_a() const;
  public:
  void clear_curve_a();
  const std::string& curve_a() const;
  void set_curve_a(const std::string& value);
  void set_curve_a(std::string&& value);
  void set_curve_a(const char* value);
  void set_curve_a(const void* value, size_t size);
  std::string* mutable_curve_a();
  std::string* release_curve_a();
  void set_allocated_curve_a(std::string* curve_a);
  private:
  const std::string& _internal_curve_a() const;
  void _internal_set_curve_a(const std::string& value);
  std::string* _internal_mutable_curve_a();
  public:

  // optional bytes curve_b = 4;
  bool has_curve_b() const;
  private:
  bool _internal_has_curve_b() const;
  public:
  void clear_curve_b();
  const std::string& curve_b() const;
  void set_curve_b(const std::string& value);
  void set_curve_b(std::string&& value);
  void set_curve_b(const char* value);
  void set_curve_b(const void* value, size_t size);
  std::string* mutable_curve_b();
  std::string* release_curve_b();
  void set_allocated_curve_b(std::string* curve_b);
  private:
  const std::string& _internal_curve_b() const;
  void _internal_set_curve_b(const std::string& value);
  std::string* _internal_mutable_curve_b();
  public:

  // optional bytes order_of_base_point = 7;
  bool has_order_of_base_point() const;
  private:
  bool _internal_has_order_of_base_point() const;
  public:
  void clear_order_of_base_point();
  const std::string& order_of_base_point() const;
  void set_order_of_base_point(const std::string& value);
  void set_order_of_base_point(std::string&& value);
  void set_order_of_base_point(const char* value);
  void set_order_of_base_point(const void* value, size_t size);
  std::string* mutable_order_of_base_point();
  std::string* release_order_of_base_point();
  void set_allocated_order_of_base_point(std::string* order_of_base_point);
  private:
  const std::string& _internal_order_of_base_point() const;
  void _internal_set_order_of_base_point(const std::string& value);
  std::string* _internal_mutable_order_of_base_point();
  public:

  // optional bytes private_multiplier = 8;
  bool has_private_multiplier() const;
  private:
  bool _internal_has_private_multiplier() const;
  public:
  void clear_private_multiplier();
  const std::string& private_multiplier() const;
  void set_private_multiplier(const std::string& value);
  void set_private_multiplier(std::string&& value);
  void set_private_multiplier(const char* value);
  void set_private_multiplier(const void* value, size_t size);
  std::string* mutable_private_multiplier();
  std::string* release_private_multiplier();
  void set_allocated_private_multiplier(std::string* private_multiplier);
  private:
  const std::string& _internal_private_multiplier() const;
  void _internal_set_private_multiplier(const std::string& value);
  std::string* _internal_mutable_private_multiplier();
  public:

  // optional .point_message base_point = 5;
  bool has_base_point() const;
  private:
  bool _internal_has_base_point() const;
  public:
  void clear_base_point();
  const ::point_message& base_point() const;
  ::point_message* release_base_point();
  ::point_message* mutable_base_point();
  void set_allocated_base_point(::point_message* base_point);
  private:
  const ::point_message& _internal_base_point() const;
  ::point_message* _internal_mutable_base_point();
  public:

  // optional .point_message public_point = 6;
  bool has_public_point() const;
  private:
  bool _internal_has_public_point() const;
  public:
  void clear_public_point();
  const ::point_message& public_point() const;
  ::point_message* release_public_point();
  ::point_message* mutable_public_point();
  void set_allocated_public_point(::point_message* public_point);
  private:
  const ::point_message& _internal_public_point() const;
  ::point_message* _internal_mutable_public_point();
  public:

  // @@protoc_insertion_point(class_scope:ecc_message)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr curve_name_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr curve_p_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr curve_a_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr curve_b_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr order_of_base_point_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr private_multiplier_;
  ::point_message* base_point_;
  ::point_message* public_point_;
  friend struct ::TableStruct_certifier_2eproto;
};
// -------------------------------------------------------------------

class key_message :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:key_message) */ {
 public:
  key_message();
  virtual ~key_message();

  key_message(const key_message& from);
  key_message(key_message&& from) noexcept
    : key_message() {
    *this = ::std::move(from);
  }

  inline key_message& operator=(const key_message& from) {
    CopyFrom(from);
    return *this;
  }
  inline key_message& operator=(key_message&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const key_message& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const key_message* internal_default_instance() {
    return reinterpret_cast<const key_message*>(
               &_key_message_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(key_message& a, key_message& b) {
    a.Swap(&b);
  }
  inline void Swap(key_message* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline key_message* New() const final {
    return CreateMaybeMessage<key_message>(nullptr);
  }

  key_message* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<key_message>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const key_message& from);
  void MergeFrom(const key_message& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(key_message* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "key_message";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_certifier_2eproto);
    return ::descriptor_table_certifier_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kKeyNameFieldNumber = 1,
    kKeyTypeFieldNumber = 2,
    kKeyFormatFieldNumber = 3,
    kSecretKeyBitsFieldNumber = 6,
    kCertificateFieldNumber = 7,
    kOtherKeyFormatsFieldNumber = 8,
    kNotBeforeFieldNumber = 9,
    kNotAfterFieldNumber = 10,
    kRsaKeyFieldNumber = 4,
    kEccKeyFieldNumber = 5,
  };
  // optional string key_name = 1;
  bool has_key_name() const;
  private:
  bool _internal_has_key_name() const;
  public:
  void clear_key_name();
  const std::string& key_name() const;
  void set_key_name(const std::string& value);
  void set_key_name(std::string&& value);
  void set_key_name(const char* value);
  void set_key_name(const char* value, size_t size);
  std::string* mutable_key_name();
  std::string* release_key_name();
  void set_allocated_key_name(std::string* key_name);
  private:
  const std::string& _internal_key_name() const;
  void _internal_set_key_name(const std::string& value);
  std::string* _internal_mutable_key_name();
  public:

  // optional string key_type = 2;
  bool has_key_type() const;
  private:
  bool _internal_has_key_type() const;
  public:
  void clear_key_type();
  const std::string& key_type() const;
  void set_key_type(const std::string& value);
  void set_key_type(std::string&& value);
  void set_key_type(const char* value);
  void set_key_type(const char* value, size_t size);
  std::string* mutable_key_type();
  std::string* release_key_type();
  void set_allocated_key_type(std::string* key_type);
  private:
  const std::string& _internal_key_type() const;
  void _internal_set_key_type(const std::string& value);
  std::string* _internal_mutable_key_type();
  public:

  // optional string key_format = 3;
  bool has_key_format() const;
  private:
  bool _internal_has_key_format() const;
  public:
  void clear_key_format();
  const std::string& key_format() const;
  void set_key_format(const std::string& value);
  void set_key_format(std::string&& value);
  void set_key_format(const char* value);
  void set_key_format(const char* value, size_t size);
  std::string* mutable_key_format();
  std::string* release_key_format();
  void set_allocated_key_format(std::string* key_format);
  private:
  const std::string& _internal_key_format() const;
  void _internal_set_key_format(const std::string& value);
  std::string* _internal_mutable_key_format();
  public:

  // optional bytes secret_key_bits = 6;
  bool has_secret_key_bits() const;
  private:
  bool _internal_has_secret_key_bits() const;
  public:
  void clear_secret_key_bits();
  const std::string& secret_key_bits() const;
  void set_secret_key_bits(const std::string& value);
  void set_secret_key_bits(std::string&& value);
  void set_secret_key_bits(const char* value);
  void set_secret_key_bits(const void* value, size_t size);
  std::string* mutable_secret_key_bits();
  std::string* release_secret_key_bits();
  void set_allocated_secret_key_bits(std::string* secret_key_bits);
  private:
  const std::string& _internal_secret_key_bits() const;
  void _internal_set_secret_key_bits(const std::string& value);
  std::string* _internal_mutable_secret_key_bits();
  public:

  // optional bytes certificate = 7;
  bool has_certificate() const;
  private:
  bool _internal_has_certificate() const;
  public:
  void clear_certificate();
  const std::string& certificate() const;
  void set_certificate(const std::string& value);
  void set_certificate(std::string&& value);
  void set_certificate(const char* value);
  void set_certificate(const void* value, size_t size);
  std::string* mutable_certificate();
  std::string* release_certificate();
  void set_allocated_certificate(std::string* certificate);
  private:
  const std::string& _internal_certificate() const;
  void _internal_set_certificate(const std::string& value);
  std::string* _internal_mutable_certificate();
  public:

  // optional bytes other_key_formats = 8;
  bool has_other_key_formats() const;
  private:
  bool _internal_has_other_key_formats() const;
  public:
  void clear_other_key_formats();
  const std::string& other_key_formats() const;
  void set_other_key_formats(const std::string& value);
  void set_other_key_formats(std::string&& value);
  void set_other_key_formats(const char* value);
  void set_other_key_formats(const void* value, size_t size);
  std::string* mutable_other_key_formats();
  std::string* release_other_key_formats();
  void set_allocated_other_key_formats(std::string* other_key_formats);
  private:
  const std::string& _internal_other_key_formats() const;
  void _internal_set_other_key_formats(const std::string& value);
  std::string* _internal_mutable_other_key_formats();
  public:

  // optional string not_before = 9;
  bool has_not_before() const;
  private:
  bool _internal_has_not_before() const;
  public:
  void clear_not_before();
  const std::string& not_before() const;
  void set_not_before(const std::string& value);
  void set_not_before(std::string&& value);
  void set_not_before(const char* value);
  void set_not_before(const char* value, size_t size);
  std::string* mutable_not_before();
  std::string* release_not_before();
  void set_allocated_not_before(std::string* not_before);
  private:
  const std::string& _internal_not_before() const;
  void _internal_set_not_before(const std::string& value);
  std::string* _internal_mutable_not_before();
  public:

  // optional string not_after = 10;
  bool has_not_after() const;
  private:
  bool _internal_has_not_after() const;
  public:
  void clear_not_after();
  const std::string& not_after() const;
  void set_not_after(const std::string& value);
  void set_not_after(std::string&& value);
  void set_not_after(const char* value);
  void set_not_after(const char* value, size_t size);
  std::string* mutable_not_after();
  std::string* release_not_after();
  void set_allocated_not_after(std::string* not_after);
  private:
  const std::string& _internal_not_after() const;
  void _internal_set_not_after(const std::string& value);
  std::string* _internal_mutable_not_after();
  public:

  // optional .rsa_message rsa_key = 4;
  bool has_rsa_key() const;
  private:
  bool _internal_has_rsa_key() const;
  public:
  void clear_rsa_key();
  const ::rsa_message& rsa_key() const;
  ::rsa_message* release_rsa_key();
  ::rsa_message* mutable_rsa_key();
  void set_allocated_rsa_key(::rsa_message* rsa_key);
  private:
  const ::rsa_message& _internal_rsa_key() const;
  ::rsa_message* _internal_mutable_rsa_key();
  public:

  // optional .ecc_message ecc_key = 5;
  bool has_ecc_key() const;
  private:
  bool _internal_has_ecc_key() const;
  public:
  void clear_ecc_key();
  const ::ecc_message& ecc_key() const;
  ::ecc_message* release_ecc_key();
  ::ecc_message* mutable_ecc_key();
  void set_allocated_ecc_key(::ecc_message* ecc_key);
  private:
  const ::ecc_message& _internal_ecc_key() const;
  ::ecc_message* _internal_mutable_ecc_key();
  public:

  // @@protoc_insertion_point(class_scope:key_message)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr key_name_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr key_type_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr key_format_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr secret_key_bits_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr certificate_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr other_key_formats_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr not_before_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr not_after_;
  ::rsa_message* rsa_key_;
  ::ecc_message* ecc_key_;
  friend struct ::TableStruct_certifier_2eproto;
};
// -------------------------------------------------------------------

class protected_blob_message :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:protected_blob_message) */ {
 public:
  protected_blob_message();
  virtual ~protected_blob_message();

  protected_blob_message(const protected_blob_message& from);
  protected_blob_message(protected_blob_message&& from) noexcept
    : protected_blob_message() {
    *this = ::std::move(from);
  }

  inline protected_blob_message& operator=(const protected_blob_message& from) {
    CopyFrom(from);
    return *this;
  }
  inline protected_blob_message& operator=(protected_blob_message&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const protected_blob_message& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const protected_blob_message* internal_default_instance() {
    return reinterpret_cast<const protected_blob_message*>(
               &_protected_blob_message_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(protected_blob_message& a, protected_blob_message& b) {
    a.Swap(&b);
  }
  inline void Swap(protected_blob_message* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline protected_blob_message* New() const final {
    return CreateMaybeMessage<protected_blob_message>(nullptr);
  }

  protected_blob_message* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<protected_blob_message>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const protected_blob_message& from);
  void MergeFrom(const protected_blob_message& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(protected_blob_message* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "protected_blob_message";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_certifier_2eproto);
    return ::descriptor_table_certifier_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kEncryptedKeyFieldNumber = 1,
    kEncryptedDataFieldNumber = 2,
  };
  // optional bytes encrypted_key = 1;
  bool has_encrypted_key() const;
  private:
  bool _internal_has_encrypted_key() const;
  public:
  void clear_encrypted_key();
  const std::string& encrypted_key() const;
  void set_encrypted_key(const std::string& value);
  void set_encrypted_key(std::string&& value);
  void set_encrypted_key(const char* value);
  void set_encrypted_key(const void* value, size_t size);
  std::string* mutable_encrypted_key();
  std::string* release_encrypted_key();
  void set_allocated_encrypted_key(std::string* encrypted_key);
  private:
  const std::string& _internal_encrypted_key() const;
  void _internal_set_encrypted_key(const std::string& value);
  std::string* _internal_mutable_encrypted_key();
  public:

  // optional bytes encrypted_data = 2;
  bool has_encrypted_data() const;
  private:
  bool _internal_has_encrypted_data() const;
  public:
  void clear_encrypted_data();
  const std::string& encrypted_data() const;
  void set_encrypted_data(const std::string& value);
  void set_encrypted_data(std::string&& value);
  void set_encrypted_data(const char* value);
  void set_encrypted_data(const void* value, size_t size);
  std::string* mutable_encrypted_data();
  std::string* release_encrypted_data();
  void set_allocated_encrypted_data(std::string* encrypted_data);
  private:
  const std::string& _internal_encrypted_data() const;
  void _internal_set_encrypted_data(const std::string& value);
  std::string* _internal_mutable_encrypted_data();
  public:

  // @@protoc_insertion_point(class_scope:protected_blob_message)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr encrypted_key_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr encrypted_data_;
  friend struct ::TableStruct_certifier_2eproto;
};
// -------------------------------------------------------------------

class property :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:property) */ {
 public:
  property();
  virtual ~property();

  property(const property& from);
  property(property&& from) noexcept
    : property() {
    *this = ::std::move(from);
  }

  inline property& operator=(const property& from) {
    CopyFrom(from);
    return *this;
  }
  inline property& operator=(property&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const property& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const property* internal_default_instance() {
    return reinterpret_cast<const property*>(
               &_property_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(property& a, property& b) {
    a.Swap(&b);
  }
  inline void Swap(property* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline property* New() const final {
    return CreateMaybeMessage<property>(nullptr);
  }

  property* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<property>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const property& from);
  void MergeFrom(const property& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(property* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "property";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_certifier_2eproto);
    return ::descriptor_table_certifier_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPropertyNameFieldNumber = 1,
    kValueTypeFieldNumber = 2,
    kComparatorFieldNumber = 3,
    kStringValueFieldNumber = 4,
    kIntValueFieldNumber = 5,
  };
  // optional string property_name = 1;
  bool has_property_name() const;
  private:
  bool _internal_has_property_name() const;
  public:
  void clear_property_name();
  const std::string& property_name() const;
  void set_property_name(const std::string& value);
  void set_property_name(std::string&& value);
  void set_property_name(const char* value);
  void set_property_name(const char* value, size_t size);
  std::string* mutable_property_name();
  std::string* release_property_name();
  void set_allocated_property_name(std::string* property_name);
  private:
  const std::string& _internal_property_name() const;
  void _internal_set_property_name(const std::string& value);
  std::string* _internal_mutable_property_name();
  public:

  // optional string value_type = 2;
  bool has_value_type() const;
  private:
  bool _internal_has_value_type() const;
  public:
  void clear_value_type();
  const std::string& value_type() const;
  void set_value_type(const std::string& value);
  void set_value_type(std::string&& value);
  void set_value_type(const char* value);
  void set_value_type(const char* value, size_t size);
  std::string* mutable_value_type();
  std::string* release_value_type();
  void set_allocated_value_type(std::string* value_type);
  private:
  const std::string& _internal_value_type() const;
  void _internal_set_value_type(const std::string& value);
  std::string* _internal_mutable_value_type();
  public:

  // optional string comparator = 3;
  bool has_comparator() const;
  private:
  bool _internal_has_comparator() const;
  public:
  void clear_comparator();
  const std::string& comparator() const;
  void set_comparator(const std::string& value);
  void set_comparator(std::string&& value);
  void set_comparator(const char* value);
  void set_comparator(const char* value, size_t size);
  std::string* mutable_comparator();
  std::string* release_comparator();
  void set_allocated_comparator(std::string* comparator);
  private:
  const std::string& _internal_comparator() const;
  void _internal_set_comparator(const std::string& value);
  std::string* _internal_mutable_comparator();
  public:

  // optional string string_value = 4;
  bool has_string_value() const;
  private:
  bool _internal_has_string_value() const;
  public:
  void clear_string_value();
  const std::string& string_value() const;
  void set_string_value(const std::string& value);
  void set_string_value(std::string&& value);
  void set_string_value(const char* value);
  void set_string_value(const char* value, size_t size);
  std::string* mutable_string_value();
  std::string* release_string_value();
  void set_allocated_string_value(std::string* string_value);
  private:
  const std::string& _internal_string_value() const;
  void _internal_set_string_value(const std::string& value);
  std::string* _internal_mutable_string_value();
  public:

  // optional uint64 int_value = 5;
  bool has_int_value() const;
  private:
  bool _internal_has_int_value() const;
  public:
  void clear_int_value();
  ::PROTOBUF_NAMESPACE_ID::uint64 int_value() const;
  void set_int_value(::PROTOBUF_NAMESPACE_ID::uint64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint64 _internal_int_value() const;
  void _internal_set_int_value(::PROTOBUF_NAMESPACE_ID::uint64 value);
  public:

  // @@protoc_insertion_point(class_scope:property)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr property_name_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr value_type_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr comparator_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr string_value_;
  ::PROTOBUF_NAMESPACE_ID::uint64 int_value_;
  friend struct ::TableStruct_certifier_2eproto;
};
// -------------------------------------------------------------------

class properties :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:properties) */ {
 public:
  properties();
  virtual ~properties();

  properties(const properties& from);
  properties(properties&& from) noexcept
    : properties() {
    *this = ::std::move(from);
  }

  inline properties& operator=(const properties& from) {
    CopyFrom(from);
    return *this;
  }
  inline properties& operator=(properties&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const properties& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const properties* internal_default_instance() {
    return reinterpret_cast<const properties*>(
               &_properties_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(properties& a, properties& b) {
    a.Swap(&b);
  }
  inline void Swap(properties* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline properties* New() const final {
    return CreateMaybeMessage<properties>(nullptr);
  }

  properties* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<properties>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const properties& from);
  void MergeFrom(const properties& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(properties* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "properties";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_certifier_2eproto);
    return ::descriptor_table_certifier_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPropsFieldNumber = 1,
  };
  // repeated .property props = 1;
  int props_size() const;
  private:
  int _internal_props_size() const;
  public:
  void clear_props();
  ::property* mutable_props(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::property >*
      mutable_props();
  private:
  const ::property& _internal_props(int index) const;
  ::property* _internal_add_props();
  public:
  const ::property& props(int index) const;
  ::property* add_props();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::property >&
      props() const;

  // @@protoc_insertion_point(class_scope:properties)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::property > props_;
  friend struct ::TableStruct_certifier_2eproto;
};
// -------------------------------------------------------------------

class platform :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:platform) */ {
 public:
  platform();
  virtual ~platform();

  platform(const platform& from);
  platform(platform&& from) noexcept
    : platform() {
    *this = ::std::move(from);
  }

  inline platform& operator=(const platform& from) {
    CopyFrom(from);
    return *this;
  }
  inline platform& operator=(platform&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const platform& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const platform* internal_default_instance() {
    return reinterpret_cast<const platform*>(
               &_platform_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(platform& a, platform& b) {
    a.Swap(&b);
  }
  inline void Swap(platform* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline platform* New() const final {
    return CreateMaybeMessage<platform>(nullptr);
  }

  platform* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<platform>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const platform& from);
  void MergeFrom(const platform& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(platform* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "platform";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_certifier_2eproto);
    return ::descriptor_table_certifier_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPlatformTypeFieldNumber = 1,
    kAttestKeyFieldNumber = 2,
    kPropsFieldNumber = 3,
    kHasKeyFieldNumber = 4,
  };
  // optional string platform_type = 1;
  bool has_platform_type() const;
  private:
  bool _internal_has_platform_type() const;
  public:
  void clear_platform_type();
  const std::string& platform_type() const;
  void set_platform_type(const std::string& value);
  void set_platform_type(std::string&& value);
  void set_platform_type(const char* value);
  void set_platform_type(const char* value, size_t size);
  std::string* mutable_platform_type();
  std::string* release_platform_type();
  void set_allocated_platform_type(std::string* platform_type);
  private:
  const std::string& _internal_platform_type() const;
  void _internal_set_platform_type(const std::string& value);
  std::string* _internal_mutable_platform_type();
  public:

  // optional .key_message attest_key = 2;
  bool has_attest_key() const;
  private:
  bool _internal_has_attest_key() const;
  public:
  void clear_attest_key();
  const ::key_message& attest_key() const;
  ::key_message* release_attest_key();
  ::key_message* mutable_attest_key();
  void set_allocated_attest_key(::key_message* attest_key);
  private:
  const ::key_message& _internal_attest_key() const;
  ::key_message* _internal_mutable_attest_key();
  public:

  // optional .properties props = 3;
  bool has_props() const;
  private:
  bool _internal_has_props() const;
  public:
  void clear_props();
  const ::properties& props() const;
  ::properties* release_props();
  ::properties* mutable_props();
  void set_allocated_props(::properties* props);
  private:
  const ::properties& _internal_props() const;
  ::properties* _internal_mutable_props();
  public:

  // optional bool has_key = 4;
  bool has_has_key() const;
  private:
  bool _internal_has_has_key() const;
  public:
  void clear_has_key();
  bool has_key() const;
  void set_has_key(bool value);
  private:
  bool _internal_has_key() const;
  void _internal_set_has_key(bool value);
  public:

  // @@protoc_insertion_point(class_scope:platform)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr platform_type_;
  ::key_message* attest_key_;
  ::properties* props_;
  bool has_key_;
  friend struct ::TableStruct_certifier_2eproto;
};
// -------------------------------------------------------------------

class environment :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:environment) */ {
 public:
  environment();
  virtual ~environment();

  environment(const environment& from);
  environment(environment&& from) noexcept
    : environment() {
    *this = ::std::move(from);
  }

  inline environment& operator=(const environment& from) {
    CopyFrom(from);
    return *this;
  }
  inline environment& operator=(environment&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const environment& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const environment* internal_default_instance() {
    return reinterpret_cast<const environment*>(
               &_environment_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(environment& a, environment& b) {
    a.Swap(&b);
  }
  inline void Swap(environment* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline environment* New() const final {
    return CreateMaybeMessage<environment>(nullptr);
  }

  environment* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<environment>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const environment& from);
  void MergeFrom(const environment& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(environment* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "environment";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_certifier_2eproto);
    return ::descriptor_table_certifier_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTheMeasurementFieldNumber = 2,
    kThePlatformFieldNumber = 1,
  };
  // optional bytes the_measurement = 2;
  bool has_the_measurement() const;
  private:
  bool _internal_has_the_measurement() const;
  public:
  void clear_the_measurement();
  const std::string& the_measurement() const;
  void set_the_measurement(const std::string& value);
  void set_the_measurement(std::string&& value);
  void set_the_measurement(const char* value);
  void set_the_measurement(const void* value, size_t size);
  std::string* mutable_the_measurement();
  std::string* release_the_measurement();
  void set_allocated_the_measurement(std::string* the_measurement);
  private:
  const std::string& _internal_the_measurement() const;
  void _internal_set_the_measurement(const std::string& value);
  std::string* _internal_mutable_the_measurement();
  public:

  // optional .platform the_platform = 1;
  bool has_the_platform() const;
  private:
  bool _internal_has_the_platform() const;
  public:
  void clear_the_platform();
  const ::platform& the_platform() const;
  ::platform* release_the_platform();
  ::platform* mutable_the_platform();
  void set_allocated_the_platform(::platform* the_platform);
  private:
  const ::platform& _internal_the_platform() const;
  ::platform* _internal_mutable_the_platform();
  public:

  // @@protoc_insertion_point(class_scope:environment)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr the_measurement_;
  ::platform* the_platform_;
  friend struct ::TableStruct_certifier_2eproto;
};
// -------------------------------------------------------------------

class entity_message :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:entity_message) */ {
 public:
  entity_message();
  virtual ~entity_message();

  entity_message(const entity_message& from);
  entity_message(entity_message&& from) noexcept
    : entity_message() {
    *this = ::std::move(from);
  }

  inline entity_message& operator=(const entity_message& from) {
    CopyFrom(from);
    return *this;
  }
  inline entity_message& operator=(entity_message&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const entity_message& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const entity_message* internal_default_instance() {
    return reinterpret_cast<const entity_message*>(
               &_entity_message_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(entity_message& a, entity_message& b) {
    a.Swap(&b);
  }
  inline void Swap(entity_message* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline entity_message* New() const final {
    return CreateMaybeMessage<entity_message>(nullptr);
  }

  entity_message* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<entity_message>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const entity_message& from);
  void MergeFrom(const entity_message& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(entity_message* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "entity_message";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_certifier_2eproto);
    return ::descriptor_table_certifier_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kEntityTypeFieldNumber = 1,
    kMeasurementFieldNumber = 3,
    kKeyFieldNumber = 2,
    kPlatformEntFieldNumber = 4,
    kEnvironmentEntFieldNumber = 5,
  };
  // optional string entity_type = 1;
  bool has_entity_type() const;
  private:
  bool _internal_has_entity_type() const;
  public:
  void clear_entity_type();
  const std::string& entity_type() const;
  void set_entity_type(const std::string& value);
  void set_entity_type(std::string&& value);
  void set_entity_type(const char* value);
  void set_entity_type(const char* value, size_t size);
  std::string* mutable_entity_type();
  std::string* release_entity_type();
  void set_allocated_entity_type(std::string* entity_type);
  private:
  const std::string& _internal_entity_type() const;
  void _internal_set_entity_type(const std::string& value);
  std::string* _internal_mutable_entity_type();
  public:

  // optional bytes measurement = 3;
  bool has_measurement() const;
  private:
  bool _internal_has_measurement() const;
  public:
  void clear_measurement();
  const std::string& measurement() const;
  void set_measurement(const std::string& value);
  void set_measurement(std::string&& value);
  void set_measurement(const char* value);
  void set_measurement(const void* value, size_t size);
  std::string* mutable_measurement();
  std::string* release_measurement();
  void set_allocated_measurement(std::string* measurement);
  private:
  const std::string& _internal_measurement() const;
  void _internal_set_measurement(const std::string& value);
  std::string* _internal_mutable_measurement();
  public:

  // optional .key_message key = 2;
  bool has_key() const;
  private:
  bool _internal_has_key() const;
  public:
  void clear_key();
  const ::key_message& key() const;
  ::key_message* release_key();
  ::key_message* mutable_key();
  void set_allocated_key(::key_message* key);
  private:
  const ::key_message& _internal_key() const;
  ::key_message* _internal_mutable_key();
  public:

  // optional .platform platform_ent = 4;
  bool has_platform_ent() const;
  private:
  bool _internal_has_platform_ent() const;
  public:
  void clear_platform_ent();
  const ::platform& platform_ent() const;
  ::platform* release_platform_ent();
  ::platform* mutable_platform_ent();
  void set_allocated_platform_ent(::platform* platform_ent);
  private:
  const ::platform& _internal_platform_ent() const;
  ::platform* _internal_mutable_platform_ent();
  public:

  // optional .environment environment_ent = 5;
  bool has_environment_ent() const;
  private:
  bool _internal_has_environment_ent() const;
  public:
  void clear_environment_ent();
  const ::environment& environment_ent() const;
  ::environment* release_environment_ent();
  ::environment* mutable_environment_ent();
  void set_allocated_environment_ent(::environment* environment_ent);
  private:
  const ::environment& _internal_environment_ent() const;
  ::environment* _internal_mutable_environment_ent();
  public:

  // @@protoc_insertion_point(class_scope:entity_message)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr entity_type_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr measurement_;
  ::key_message* key_;
  ::platform* platform_ent_;
  ::environment* environment_ent_;
  friend struct ::TableStruct_certifier_2eproto;
};
// -------------------------------------------------------------------

class vse_clause :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:vse_clause) */ {
 public:
  vse_clause();
  virtual ~vse_clause();

  vse_clause(const vse_clause& from);
  vse_clause(vse_clause&& from) noexcept
    : vse_clause() {
    *this = ::std::move(from);
  }

  inline vse_clause& operator=(const vse_clause& from) {
    CopyFrom(from);
    return *this;
  }
  inline vse_clause& operator=(vse_clause&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const vse_clause& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const vse_clause* internal_default_instance() {
    return reinterpret_cast<const vse_clause*>(
               &_vse_clause_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(vse_clause& a, vse_clause& b) {
    a.Swap(&b);
  }
  inline void Swap(vse_clause* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline vse_clause* New() const final {
    return CreateMaybeMessage<vse_clause>(nullptr);
  }

  vse_clause* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<vse_clause>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const vse_clause& from);
  void MergeFrom(const vse_clause& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(vse_clause* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "vse_clause";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_certifier_2eproto);
    return ::descriptor_table_certifier_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kVerbFieldNumber = 2,
    kSubjectFieldNumber = 1,
    kObjectFieldNumber = 3,
    kClauseFieldNumber = 4,
  };
  // optional string verb = 2;
  bool has_verb() const;
  private:
  bool _internal_has_verb() const;
  public:
  void clear_verb();
  const std::string& verb() const;
  void set_verb(const std::string& value);
  void set_verb(std::string&& value);
  void set_verb(const char* value);
  void set_verb(const char* value, size_t size);
  std::string* mutable_verb();
  std::string* release_verb();
  void set_allocated_verb(std::string* verb);
  private:
  const std::string& _internal_verb() const;
  void _internal_set_verb(const std::string& value);
  std::string* _internal_mutable_verb();
  public:

  // optional .entity_message subject = 1;
  bool has_subject() const;
  private:
  bool _internal_has_subject() const;
  public:
  void clear_subject();
  const ::entity_message& subject() const;
  ::entity_message* release_subject();
  ::entity_message* mutable_subject();
  void set_allocated_subject(::entity_message* subject);
  private:
  const ::entity_message& _internal_subject() const;
  ::entity_message* _internal_mutable_subject();
  public:

  // optional .entity_message object = 3;
  bool has_object() const;
  private:
  bool _internal_has_object() const;
  public:
  void clear_object();
  const ::entity_message& object() const;
  ::entity_message* release_object();
  ::entity_message* mutable_object();
  void set_allocated_object(::entity_message* object);
  private:
  const ::entity_message& _internal_object() const;
  ::entity_message* _internal_mutable_object();
  public:

  // optional .vse_clause clause = 4;
  bool has_clause() const;
  private:
  bool _internal_has_clause() const;
  public:
  void clear_clause();
  const ::vse_clause& clause() const;
  ::vse_clause* release_clause();
  ::vse_clause* mutable_clause();
  void set_allocated_clause(::vse_clause* clause);
  private:
  const ::vse_clause& _internal_clause() const;
  ::vse_clause* _internal_mutable_clause();
  public:

  // @@protoc_insertion_point(class_scope:vse_clause)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr verb_;
  ::entity_message* subject_;
  ::entity_message* object_;
  ::vse_clause* clause_;
  friend struct ::TableStruct_certifier_2eproto;
};
// -------------------------------------------------------------------

class vse_clauses :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:vse_clauses) */ {
 public:
  vse_clauses();
  virtual ~vse_clauses();

  vse_clauses(const vse_clauses& from);
  vse_clauses(vse_clauses&& from) noexcept
    : vse_clauses() {
    *this = ::std::move(from);
  }

  inline vse_clauses& operator=(const vse_clauses& from) {
    CopyFrom(from);
    return *this;
  }
  inline vse_clauses& operator=(vse_clauses&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const vse_clauses& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const vse_clauses* internal_default_instance() {
    return reinterpret_cast<const vse_clauses*>(
               &_vse_clauses_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  friend void swap(vse_clauses& a, vse_clauses& b) {
    a.Swap(&b);
  }
  inline void Swap(vse_clauses* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline vse_clauses* New() const final {
    return CreateMaybeMessage<vse_clauses>(nullptr);
  }

  vse_clauses* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<vse_clauses>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const vse_clauses& from);
  void MergeFrom(const vse_clauses& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(vse_clauses* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "vse_clauses";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_certifier_2eproto);
    return ::descriptor_table_certifier_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kClausesFieldNumber = 1,
  };
  // repeated .vse_clause clauses = 1;
  int clauses_size() const;
  private:
  int _internal_clauses_size() const;
  public:
  void clear_clauses();
  ::vse_clause* mutable_clauses(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vse_clause >*
      mutable_clauses();
  private:
  const ::vse_clause& _internal_clauses(int index) const;
  ::vse_clause* _internal_add_clauses();
  public:
  const ::vse_clause& clauses(int index) const;
  ::vse_clause* add_clauses();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vse_clause >&
      clauses() const;

  // @@protoc_insertion_point(class_scope:vse_clauses)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vse_clause > clauses_;
  friend struct ::TableStruct_certifier_2eproto;
};
// -------------------------------------------------------------------

class claim_message :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:claim_message) */ {
 public:
  claim_message();
  virtual ~claim_message();

  claim_message(const claim_message& from);
  claim_message(claim_message&& from) noexcept
    : claim_message() {
    *this = ::std::move(from);
  }

  inline claim_message& operator=(const claim_message& from) {
    CopyFrom(from);
    return *this;
  }
  inline claim_message& operator=(claim_message&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const claim_message& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const claim_message* internal_default_instance() {
    return reinterpret_cast<const claim_message*>(
               &_claim_message_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  friend void swap(claim_message& a, claim_message& b) {
    a.Swap(&b);
  }
  inline void Swap(claim_message* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline claim_message* New() const final {
    return CreateMaybeMessage<claim_message>(nullptr);
  }

  claim_message* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<claim_message>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const claim_message& from);
  void MergeFrom(const claim_message& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(claim_message* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "claim_message";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_certifier_2eproto);
    return ::descriptor_table_certifier_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kClaimFormatFieldNumber = 1,
    kClaimDescriptorFieldNumber = 2,
    kNotBeforeFieldNumber = 3,
    kNotAfterFieldNumber = 4,
    kSerializedClaimFieldNumber = 5,
  };
  // optional string claim_format = 1;
  bool has_claim_format() const;
  private:
  bool _internal_has_claim_format() const;
  public:
  void clear_claim_format();
  const std::string& claim_format() const;
  void set_claim_format(const std::string& value);
  void set_claim_format(std::string&& value);
  void set_claim_format(const char* value);
  void set_claim_format(const char* value, size_t size);
  std::string* mutable_claim_format();
  std::string* release_claim_format();
  void set_allocated_claim_format(std::string* claim_format);
  private:
  const std::string& _internal_claim_format() const;
  void _internal_set_claim_format(const std::string& value);
  std::string* _internal_mutable_claim_format();
  public:

  // optional string claim_descriptor = 2;
  bool has_claim_descriptor() const;
  private:
  bool _internal_has_claim_descriptor() const;
  public:
  void clear_claim_descriptor();
  const std::string& claim_descriptor() const;
  void set_claim_descriptor(const std::string& value);
  void set_claim_descriptor(std::string&& value);
  void set_claim_descriptor(const char* value);
  void set_claim_descriptor(const char* value, size_t size);
  std::string* mutable_claim_descriptor();
  std::string* release_claim_descriptor();
  void set_allocated_claim_descriptor(std::string* claim_descriptor);
  private:
  const std::string& _internal_claim_descriptor() const;
  void _internal_set_claim_descriptor(const std::string& value);
  std::string* _internal_mutable_claim_descriptor();
  public:

  // optional string not_before = 3;
  bool has_not_before() const;
  private:
  bool _internal_has_not_before() const;
  public:
  void clear_not_before();
  const std::string& not_before() const;
  void set_not_before(const std::string& value);
  void set_not_before(std::string&& value);
  void set_not_before(const char* value);
  void set_not_before(const char* value, size_t size);
  std::string* mutable_not_before();
  std::string* release_not_before();
  void set_allocated_not_before(std::string* not_before);
  private:
  const std::string& _internal_not_before() const;
  void _internal_set_not_before(const std::string& value);
  std::string* _internal_mutable_not_before();
  public:

  // optional string not_after = 4;
  bool has_not_after() const;
  private:
  bool _internal_has_not_after() const;
  public:
  void clear_not_after();
  const std::string& not_after() const;
  void set_not_after(const std::string& value);
  void set_not_after(std::string&& value);
  void set_not_after(const char* value);
  void set_not_after(const char* value, size_t size);
  std::string* mutable_not_after();
  std::string* release_not_after();
  void set_allocated_not_after(std::string* not_after);
  private:
  const std::string& _internal_not_after() const;
  void _internal_set_not_after(const std::string& value);
  std::string* _internal_mutable_not_after();
  public:

  // optional bytes serialized_claim = 5;
  bool has_serialized_claim() const;
  private:
  bool _internal_has_serialized_claim() const;
  public:
  void clear_serialized_claim();
  const std::string& serialized_claim() const;
  void set_serialized_claim(const std::string& value);
  void set_serialized_claim(std::string&& value);
  void set_serialized_claim(const char* value);
  void set_serialized_claim(const void* value, size_t size);
  std::string* mutable_serialized_claim();
  std::string* release_serialized_claim();
  void set_allocated_serialized_claim(std::string* serialized_claim);
  private:
  const std::string& _internal_serialized_claim() const;
  void _internal_set_serialized_claim(const std::string& value);
  std::string* _internal_mutable_serialized_claim();
  public:

  // @@protoc_insertion_point(class_scope:claim_message)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr claim_format_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr claim_descriptor_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr not_before_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr not_after_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr serialized_claim_;
  friend struct ::TableStruct_certifier_2eproto;
};
// -------------------------------------------------------------------

class attestation_user_data :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:attestation_user_data) */ {
 public:
  attestation_user_data();
  virtual ~attestation_user_data();

  attestation_user_data(const attestation_user_data& from);
  attestation_user_data(attestation_user_data&& from) noexcept
    : attestation_user_data() {
    *this = ::std::move(from);
  }

  inline attestation_user_data& operator=(const attestation_user_data& from) {
    CopyFrom(from);
    return *this;
  }
  inline attestation_user_data& operator=(attestation_user_data&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const attestation_user_data& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const attestation_user_data* internal_default_instance() {
    return reinterpret_cast<const attestation_user_data*>(
               &_attestation_user_data_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  friend void swap(attestation_user_data& a, attestation_user_data& b) {
    a.Swap(&b);
  }
  inline void Swap(attestation_user_data* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline attestation_user_data* New() const final {
    return CreateMaybeMessage<attestation_user_data>(nullptr);
  }

  attestation_user_data* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<attestation_user_data>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const attestation_user_data& from);
  void MergeFrom(const attestation_user_data& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(attestation_user_data* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "attestation_user_data";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_certifier_2eproto);
    return ::descriptor_table_certifier_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kEnclaveTypeFieldNumber = 1,
    kTimeFieldNumber = 2,
    kEnclaveKeyFieldNumber = 3,
    kPolicyKeyFieldNumber = 4,
  };
  // optional string enclave_type = 1;
  bool has_enclave_type() const;
  private:
  bool _internal_has_enclave_type() const;
  public:
  void clear_enclave_type();
  const std::string& enclave_type() const;
  void set_enclave_type(const std::string& value);
  void set_enclave_type(std::string&& value);
  void set_enclave_type(const char* value);
  void set_enclave_type(const char* value, size_t size);
  std::string* mutable_enclave_type();
  std::string* release_enclave_type();
  void set_allocated_enclave_type(std::string* enclave_type);
  private:
  const std::string& _internal_enclave_type() const;
  void _internal_set_enclave_type(const std::string& value);
  std::string* _internal_mutable_enclave_type();
  public:

  // optional string time = 2;
  bool has_time() const;
  private:
  bool _internal_has_time() const;
  public:
  void clear_time();
  const std::string& time() const;
  void set_time(const std::string& value);
  void set_time(std::string&& value);
  void set_time(const char* value);
  void set_time(const char* value, size_t size);
  std::string* mutable_time();
  std::string* release_time();
  void set_allocated_time(std::string* time);
  private:
  const std::string& _internal_time() const;
  void _internal_set_time(const std::string& value);
  std::string* _internal_mutable_time();
  public:

  // optional .key_message enclave_key = 3;
  bool has_enclave_key() const;
  private:
  bool _internal_has_enclave_key() const;
  public:
  void clear_enclave_key();
  const ::key_message& enclave_key() const;
  ::key_message* release_enclave_key();
  ::key_message* mutable_enclave_key();
  void set_allocated_enclave_key(::key_message* enclave_key);
  private:
  const ::key_message& _internal_enclave_key() const;
  ::key_message* _internal_mutable_enclave_key();
  public:

  // optional .key_message policy_key = 4;
  bool has_policy_key() const;
  private:
  bool _internal_has_policy_key() const;
  public:
  void clear_policy_key();
  const ::key_message& policy_key() const;
  ::key_message* release_policy_key();
  ::key_message* mutable_policy_key();
  void set_allocated_policy_key(::key_message* policy_key);
  private:
  const ::key_message& _internal_policy_key() const;
  ::key_message* _internal_mutable_policy_key();
  public:

  // @@protoc_insertion_point(class_scope:attestation_user_data)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr enclave_type_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr time_;
  ::key_message* enclave_key_;
  ::key_message* policy_key_;
  friend struct ::TableStruct_certifier_2eproto;
};
// -------------------------------------------------------------------

class vse_attestation_report_info :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:vse_attestation_report_info) */ {
 public:
  vse_attestation_report_info();
  virtual ~vse_attestation_report_info();

  vse_attestation_report_info(const vse_attestation_report_info& from);
  vse_attestation_report_info(vse_attestation_report_info&& from) noexcept
    : vse_attestation_report_info() {
    *this = ::std::move(from);
  }

  inline vse_attestation_report_info& operator=(const vse_attestation_report_info& from) {
    CopyFrom(from);
    return *this;
  }
  inline vse_attestation_report_info& operator=(vse_attestation_report_info&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const vse_attestation_report_info& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const vse_attestation_report_info* internal_default_instance() {
    return reinterpret_cast<const vse_attestation_report_info*>(
               &_vse_attestation_report_info_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    15;

  friend void swap(vse_attestation_report_info& a, vse_attestation_report_info& b) {
    a.Swap(&b);
  }
  inline void Swap(vse_attestation_report_info* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline vse_attestation_report_info* New() const final {
    return CreateMaybeMessage<vse_attestation_report_info>(nullptr);
  }

  vse_attestation_report_info* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<vse_attestation_report_info>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const vse_attestation_report_info& from);
  void MergeFrom(const vse_attestation_report_info& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(vse_attestation_report_info* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "vse_attestation_report_info";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_certifier_2eproto);
    return ::descriptor_table_certifier_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kEnclaveTypeFieldNumber = 1,
    kVerifiedMeasurementFieldNumber = 2,
    kNotBeforeFieldNumber = 3,
    kNotAfterFieldNumber = 4,
    kUserDataFieldNumber = 5,
  };
  // optional string enclave_type = 1;
  bool has_enclave_type() const;
  private:
  bool _internal_has_enclave_type() const;
  public:
  void clear_enclave_type();
  const std::string& enclave_type() const;
  void set_enclave_type(const std::string& value);
  void set_enclave_type(std::string&& value);
  void set_enclave_type(const char* value);
  void set_enclave_type(const char* value, size_t size);
  std::string* mutable_enclave_type();
  std::string* release_enclave_type();
  void set_allocated_enclave_type(std::string* enclave_type);
  private:
  const std::string& _internal_enclave_type() const;
  void _internal_set_enclave_type(const std::string& value);
  std::string* _internal_mutable_enclave_type();
  public:

  // optional bytes verified_measurement = 2;
  bool has_verified_measurement() const;
  private:
  bool _internal_has_verified_measurement() const;
  public:
  void clear_verified_measurement();
  const std::string& verified_measurement() const;
  void set_verified_measurement(const std::string& value);
  void set_verified_measurement(std::string&& value);
  void set_verified_measurement(const char* value);
  void set_verified_measurement(const void* value, size_t size);
  std::string* mutable_verified_measurement();
  std::string* release_verified_measurement();
  void set_allocated_verified_measurement(std::string* verified_measurement);
  private:
  const std::string& _internal_verified_measurement() const;
  void _internal_set_verified_measurement(const std::string& value);
  std::string* _internal_mutable_verified_measurement();
  public:

  // optional string not_before = 3;
  bool has_not_before() const;
  private:
  bool _internal_has_not_before() const;
  public:
  void clear_not_before();
  const std::string& not_before() const;
  void set_not_before(const std::string& value);
  void set_not_before(std::string&& value);
  void set_not_before(const char* value);
  void set_not_before(const char* value, size_t size);
  std::string* mutable_not_before();
  std::string* release_not_before();
  void set_allocated_not_before(std::string* not_before);
  private:
  const std::string& _internal_not_before() const;
  void _internal_set_not_before(const std::string& value);
  std::string* _internal_mutable_not_before();
  public:

  // optional string not_after = 4;
  bool has_not_after() const;
  private:
  bool _internal_has_not_after() const;
  public:
  void clear_not_after();
  const std::string& not_after() const;
  void set_not_after(const std::string& value);
  void set_not_after(std::string&& value);
  void set_not_after(const char* value);
  void set_not_after(const char* value, size_t size);
  std::string* mutable_not_after();
  std::string* release_not_after();
  void set_allocated_not_after(std::string* not_after);
  private:
  const std::string& _internal_not_after() const;
  void _internal_set_not_after(const std::string& value);
  std::string* _internal_mutable_not_after();
  public:

  // optional bytes user_data = 5;
  bool has_user_data() const;
  private:
  bool _internal_has_user_data() const;
  public:
  void clear_user_data();
  const std::string& user_data() const;
  void set_user_data(const std::string& value);
  void set_user_data(std::string&& value);
  void set_user_data(const char* value);
  void set_user_data(const void* value, size_t size);
  std::string* mutable_user_data();
  std::string* release_user_data();
  void set_allocated_user_data(std::string* user_data);
  private:
  const std::string& _internal_user_data() const;
  void _internal_set_user_data(const std::string& value);
  std::string* _internal_mutable_user_data();
  public:

  // @@protoc_insertion_point(class_scope:vse_attestation_report_info)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr enclave_type_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr verified_measurement_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr not_before_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr not_after_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr user_data_;
  friend struct ::TableStruct_certifier_2eproto;
};
// -------------------------------------------------------------------

class signed_report :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:signed_report) */ {
 public:
  signed_report();
  virtual ~signed_report();

  signed_report(const signed_report& from);
  signed_report(signed_report&& from) noexcept
    : signed_report() {
    *this = ::std::move(from);
  }

  inline signed_report& operator=(const signed_report& from) {
    CopyFrom(from);
    return *this;
  }
  inline signed_report& operator=(signed_report&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const signed_report& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const signed_report* internal_default_instance() {
    return reinterpret_cast<const signed_report*>(
               &_signed_report_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    16;

  friend void swap(signed_report& a, signed_report& b) {
    a.Swap(&b);
  }
  inline void Swap(signed_report* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline signed_report* New() const final {
    return CreateMaybeMessage<signed_report>(nullptr);
  }

  signed_report* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<signed_report>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const signed_report& from);
  void MergeFrom(const signed_report& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(signed_report* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "signed_report";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_certifier_2eproto);
    return ::descriptor_table_certifier_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kReportFormatFieldNumber = 1,
    kReportFieldNumber = 2,
    kSigningAlgorithmFieldNumber = 4,
    kSignatureFieldNumber = 5,
    kSigningKeyFieldNumber = 3,
  };
  // optional string report_format = 1;
  bool has_report_format() const;
  private:
  bool _internal_has_report_format() const;
  public:
  void clear_report_format();
  const std::string& report_format() const;
  void set_report_format(const std::string& value);
  void set_report_format(std::string&& value);
  void set_report_format(const char* value);
  void set_report_format(const char* value, size_t size);
  std::string* mutable_report_format();
  std::string* release_report_format();
  void set_allocated_report_format(std::string* report_format);
  private:
  const std::string& _internal_report_format() const;
  void _internal_set_report_format(const std::string& value);
  std::string* _internal_mutable_report_format();
  public:

  // optional bytes report = 2;
  bool has_report() const;
  private:
  bool _internal_has_report() const;
  public:
  void clear_report();
  const std::string& report() const;
  void set_report(const std::string& value);
  void set_report(std::string&& value);
  void set_report(const char* value);
  void set_report(const void* value, size_t size);
  std::string* mutable_report();
  std::string* release_report();
  void set_allocated_report(std::string* report);
  private:
  const std::string& _internal_report() const;
  void _internal_set_report(const std::string& value);
  std::string* _internal_mutable_report();
  public:

  // optional string signing_algorithm = 4;
  bool has_signing_algorithm() const;
  private:
  bool _internal_has_signing_algorithm() const;
  public:
  void clear_signing_algorithm();
  const std::string& signing_algorithm() const;
  void set_signing_algorithm(const std::string& value);
  void set_signing_algorithm(std::string&& value);
  void set_signing_algorithm(const char* value);
  void set_signing_algorithm(const char* value, size_t size);
  std::string* mutable_signing_algorithm();
  std::string* release_signing_algorithm();
  void set_allocated_signing_algorithm(std::string* signing_algorithm);
  private:
  const std::string& _internal_signing_algorithm() const;
  void _internal_set_signing_algorithm(const std::string& value);
  std::string* _internal_mutable_signing_algorithm();
  public:

  // optional bytes signature = 5;
  bool has_signature() const;
  private:
  bool _internal_has_signature() const;
  public:
  void clear_signature();
  const std::string& signature() const;
  void set_signature(const std::string& value);
  void set_signature(std::string&& value);
  void set_signature(const char* value);
  void set_signature(const void* value, size_t size);
  std::string* mutable_signature();
  std::string* release_signature();
  void set_allocated_signature(std::string* signature);
  private:
  const std::string& _internal_signature() const;
  void _internal_set_signature(const std::string& value);
  std::string* _internal_mutable_signature();
  public:

  // optional .key_message signing_key = 3;
  bool has_signing_key() const;
  private:
  bool _internal_has_signing_key() const;
  public:
  void clear_signing_key();
  const ::key_message& signing_key() const;
  ::key_message* release_signing_key();
  ::key_message* mutable_signing_key();
  void set_allocated_signing_key(::key_message* signing_key);
  private:
  const ::key_message& _internal_signing_key() const;
  ::key_message* _internal_mutable_signing_key();
  public:

  // @@protoc_insertion_point(class_scope:signed_report)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr report_format_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr report_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr signing_algorithm_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr signature_;
  ::key_message* signing_key_;
  friend struct ::TableStruct_certifier_2eproto;
};
// -------------------------------------------------------------------

class signed_claim_message :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:signed_claim_message) */ {
 public:
  signed_claim_message();
  virtual ~signed_claim_message();

  signed_claim_message(const signed_claim_message& from);
  signed_claim_message(signed_claim_message&& from) noexcept
    : signed_claim_message() {
    *this = ::std::move(from);
  }

  inline signed_claim_message& operator=(const signed_claim_message& from) {
    CopyFrom(from);
    return *this;
  }
  inline signed_claim_message& operator=(signed_claim_message&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const signed_claim_message& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const signed_claim_message* internal_default_instance() {
    return reinterpret_cast<const signed_claim_message*>(
               &_signed_claim_message_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    17;

  friend void swap(signed_claim_message& a, signed_claim_message& b) {
    a.Swap(&b);
  }
  inline void Swap(signed_claim_message* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline signed_claim_message* New() const final {
    return CreateMaybeMessage<signed_claim_message>(nullptr);
  }

  signed_claim_message* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<signed_claim_message>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const signed_claim_message& from);
  void MergeFrom(const signed_claim_message& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(signed_claim_message* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "signed_claim_message";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_certifier_2eproto);
    return ::descriptor_table_certifier_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSerializedClaimMessageFieldNumber = 1,
    kSigningAlgorithmFieldNumber = 3,
    kSignatureFieldNumber = 4,
    kSigningKeyFieldNumber = 2,
  };
  // optional bytes serialized_claim_message = 1;
  bool has_serialized_claim_message() const;
  private:
  bool _internal_has_serialized_claim_message() const;
  public:
  void clear_serialized_claim_message();
  const std::string& serialized_claim_message() const;
  void set_serialized_claim_message(const std::string& value);
  void set_serialized_claim_message(std::string&& value);
  void set_serialized_claim_message(const char* value);
  void set_serialized_claim_message(const void* value, size_t size);
  std::string* mutable_serialized_claim_message();
  std::string* release_serialized_claim_message();
  void set_allocated_serialized_claim_message(std::string* serialized_claim_message);
  private:
  const std::string& _internal_serialized_claim_message() const;
  void _internal_set_serialized_claim_message(const std::string& value);
  std::string* _internal_mutable_serialized_claim_message();
  public:

  // optional string signing_algorithm = 3;
  bool has_signing_algorithm() const;
  private:
  bool _internal_has_signing_algorithm() const;
  public:
  void clear_signing_algorithm();
  const std::string& signing_algorithm() const;
  void set_signing_algorithm(const std::string& value);
  void set_signing_algorithm(std::string&& value);
  void set_signing_algorithm(const char* value);
  void set_signing_algorithm(const char* value, size_t size);
  std::string* mutable_signing_algorithm();
  std::string* release_signing_algorithm();
  void set_allocated_signing_algorithm(std::string* signing_algorithm);
  private:
  const std::string& _internal_signing_algorithm() const;
  void _internal_set_signing_algorithm(const std::string& value);
  std::string* _internal_mutable_signing_algorithm();
  public:

  // optional bytes signature = 4;
  bool has_signature() const;
  private:
  bool _internal_has_signature() const;
  public:
  void clear_signature();
  const std::string& signature() const;
  void set_signature(const std::string& value);
  void set_signature(std::string&& value);
  void set_signature(const char* value);
  void set_signature(const void* value, size_t size);
  std::string* mutable_signature();
  std::string* release_signature();
  void set_allocated_signature(std::string* signature);
  private:
  const std::string& _internal_signature() const;
  void _internal_set_signature(const std::string& value);
  std::string* _internal_mutable_signature();
  public:

  // optional .key_message signing_key = 2;
  bool has_signing_key() const;
  private:
  bool _internal_has_signing_key() const;
  public:
  void clear_signing_key();
  const ::key_message& signing_key() const;
  ::key_message* release_signing_key();
  ::key_message* mutable_signing_key();
  void set_allocated_signing_key(::key_message* signing_key);
  private:
  const ::key_message& _internal_signing_key() const;
  ::key_message* _internal_mutable_signing_key();
  public:

  // @@protoc_insertion_point(class_scope:signed_claim_message)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr serialized_claim_message_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr signing_algorithm_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr signature_;
  ::key_message* signing_key_;
  friend struct ::TableStruct_certifier_2eproto;
};
// -------------------------------------------------------------------

class evidence :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:evidence) */ {
 public:
  evidence();
  virtual ~evidence();

  evidence(const evidence& from);
  evidence(evidence&& from) noexcept
    : evidence() {
    *this = ::std::move(from);
  }

  inline evidence& operator=(const evidence& from) {
    CopyFrom(from);
    return *this;
  }
  inline evidence& operator=(evidence&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const evidence& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const evidence* internal_default_instance() {
    return reinterpret_cast<const evidence*>(
               &_evidence_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    18;

  friend void swap(evidence& a, evidence& b) {
    a.Swap(&b);
  }
  inline void Swap(evidence* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline evidence* New() const final {
    return CreateMaybeMessage<evidence>(nullptr);
  }

  evidence* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<evidence>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const evidence& from);
  void MergeFrom(const evidence& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(evidence* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "evidence";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_certifier_2eproto);
    return ::descriptor_table_certifier_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kEvidenceTypeFieldNumber = 1,
    kSerializedEvidenceFieldNumber = 2,
  };
  // optional string evidence_type = 1;
  bool has_evidence_type() const;
  private:
  bool _internal_has_evidence_type() const;
  public:
  void clear_evidence_type();
  const std::string& evidence_type() const;
  void set_evidence_type(const std::string& value);
  void set_evidence_type(std::string&& value);
  void set_evidence_type(const char* value);
  void set_evidence_type(const char* value, size_t size);
  std::string* mutable_evidence_type();
  std::string* release_evidence_type();
  void set_allocated_evidence_type(std::string* evidence_type);
  private:
  const std::string& _internal_evidence_type() const;
  void _internal_set_evidence_type(const std::string& value);
  std::string* _internal_mutable_evidence_type();
  public:

  // optional bytes serialized_evidence = 2;
  bool has_serialized_evidence() const;
  private:
  bool _internal_has_serialized_evidence() const;
  public:
  void clear_serialized_evidence();
  const std::string& serialized_evidence() const;
  void set_serialized_evidence(const std::string& value);
  void set_serialized_evidence(std::string&& value);
  void set_serialized_evidence(const char* value);
  void set_serialized_evidence(const void* value, size_t size);
  std::string* mutable_serialized_evidence();
  std::string* release_serialized_evidence();
  void set_allocated_serialized_evidence(std::string* serialized_evidence);
  private:
  const std::string& _internal_serialized_evidence() const;
  void _internal_set_serialized_evidence(const std::string& value);
  std::string* _internal_mutable_serialized_evidence();
  public:

  // @@protoc_insertion_point(class_scope:evidence)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr evidence_type_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr serialized_evidence_;
  friend struct ::TableStruct_certifier_2eproto;
};
// -------------------------------------------------------------------

class evidence_list :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:evidence_list) */ {
 public:
  evidence_list();
  virtual ~evidence_list();

  evidence_list(const evidence_list& from);
  evidence_list(evidence_list&& from) noexcept
    : evidence_list() {
    *this = ::std::move(from);
  }

  inline evidence_list& operator=(const evidence_list& from) {
    CopyFrom(from);
    return *this;
  }
  inline evidence_list& operator=(evidence_list&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const evidence_list& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const evidence_list* internal_default_instance() {
    return reinterpret_cast<const evidence_list*>(
               &_evidence_list_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    19;

  friend void swap(evidence_list& a, evidence_list& b) {
    a.Swap(&b);
  }
  inline void Swap(evidence_list* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline evidence_list* New() const final {
    return CreateMaybeMessage<evidence_list>(nullptr);
  }

  evidence_list* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<evidence_list>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const evidence_list& from);
  void MergeFrom(const evidence_list& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(evidence_list* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "evidence_list";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_certifier_2eproto);
    return ::descriptor_table_certifier_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAssertionFieldNumber = 1,
  };
  // repeated .evidence assertion = 1;
  int assertion_size() const;
  private:
  int _internal_assertion_size() const;
  public:
  void clear_assertion();
  ::evidence* mutable_assertion(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::evidence >*
      mutable_assertion();
  private:
  const ::evidence& _internal_assertion(int index) const;
  ::evidence* _internal_add_assertion();
  public:
  const ::evidence& assertion(int index) const;
  ::evidence* add_assertion();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::evidence >&
      assertion() const;

  // @@protoc_insertion_point(class_scope:evidence_list)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::evidence > assertion_;
  friend struct ::TableStruct_certifier_2eproto;
};
// -------------------------------------------------------------------

class keystone_attestation_message :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:keystone_attestation_message) */ {
 public:
  keystone_attestation_message();
  virtual ~keystone_attestation_message();

  keystone_attestation_message(const keystone_attestation_message& from);
  keystone_attestation_message(keystone_attestation_message&& from) noexcept
    : keystone_attestation_message() {
    *this = ::std::move(from);
  }

  inline keystone_attestation_message& operator=(const keystone_attestation_message& from) {
    CopyFrom(from);
    return *this;
  }
  inline keystone_attestation_message& operator=(keystone_attestation_message&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const keystone_attestation_message& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const keystone_attestation_message* internal_default_instance() {
    return reinterpret_cast<const keystone_attestation_message*>(
               &_keystone_attestation_message_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    20;

  friend void swap(keystone_attestation_message& a, keystone_attestation_message& b) {
    a.Swap(&b);
  }
  inline void Swap(keystone_attestation_message* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline keystone_attestation_message* New() const final {
    return CreateMaybeMessage<keystone_attestation_message>(nullptr);
  }

  keystone_attestation_message* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<keystone_attestation_message>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const keystone_attestation_message& from);
  void MergeFrom(const keystone_attestation_message& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(keystone_attestation_message* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "keystone_attestation_message";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_certifier_2eproto);
    return ::descriptor_table_certifier_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kWhatWasSaidFieldNumber = 1,
    kReportedAttestationFieldNumber = 2,
  };
  // optional bytes what_was_said = 1;
  bool has_what_was_said() const;
  private:
  bool _internal_has_what_was_said() const;
  public:
  void clear_what_was_said();
  const std::string& what_was_said() const;
  void set_what_was_said(const std::string& value);
  void set_what_was_said(std::string&& value);
  void set_what_was_said(const char* value);
  void set_what_was_said(const void* value, size_t size);
  std::string* mutable_what_was_said();
  std::string* release_what_was_said();
  void set_allocated_what_was_said(std::string* what_was_said);
  private:
  const std::string& _internal_what_was_said() const;
  void _internal_set_what_was_said(const std::string& value);
  std::string* _internal_mutable_what_was_said();
  public:

  // optional bytes reported_attestation = 2;
  bool has_reported_attestation() const;
  private:
  bool _internal_has_reported_attestation() const;
  public:
  void clear_reported_attestation();
  const std::string& reported_attestation() const;
  void set_reported_attestation(const std::string& value);
  void set_reported_attestation(std::string&& value);
  void set_reported_attestation(const char* value);
  void set_reported_attestation(const void* value, size_t size);
  std::string* mutable_reported_attestation();
  std::string* release_reported_attestation();
  void set_allocated_reported_attestation(std::string* reported_attestation);
  private:
  const std::string& _internal_reported_attestation() const;
  void _internal_set_reported_attestation(const std::string& value);
  std::string* _internal_mutable_reported_attestation();
  public:

  // @@protoc_insertion_point(class_scope:keystone_attestation_message)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr what_was_said_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr reported_attestation_;
  friend struct ::TableStruct_certifier_2eproto;
};
// -------------------------------------------------------------------

class sev_attestation_message :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:sev_attestation_message) */ {
 public:
  sev_attestation_message();
  virtual ~sev_attestation_message();

  sev_attestation_message(const sev_attestation_message& from);
  sev_attestation_message(sev_attestation_message&& from) noexcept
    : sev_attestation_message() {
    *this = ::std::move(from);
  }

  inline sev_attestation_message& operator=(const sev_attestation_message& from) {
    CopyFrom(from);
    return *this;
  }
  inline sev_attestation_message& operator=(sev_attestation_message&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const sev_attestation_message& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const sev_attestation_message* internal_default_instance() {
    return reinterpret_cast<const sev_attestation_message*>(
               &_sev_attestation_message_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    21;

  friend void swap(sev_attestation_message& a, sev_attestation_message& b) {
    a.Swap(&b);
  }
  inline void Swap(sev_attestation_message* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline sev_attestation_message* New() const final {
    return CreateMaybeMessage<sev_attestation_message>(nullptr);
  }

  sev_attestation_message* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<sev_attestation_message>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const sev_attestation_message& from);
  void MergeFrom(const sev_attestation_message& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(sev_attestation_message* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "sev_attestation_message";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_certifier_2eproto);
    return ::descriptor_table_certifier_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kWhatWasSaidFieldNumber = 1,
    kReportedAttestationFieldNumber = 2,
  };
  // optional bytes what_was_said = 1;
  bool has_what_was_said() const;
  private:
  bool _internal_has_what_was_said() const;
  public:
  void clear_what_was_said();
  const std::string& what_was_said() const;
  void set_what_was_said(const std::string& value);
  void set_what_was_said(std::string&& value);
  void set_what_was_said(const char* value);
  void set_what_was_said(const void* value, size_t size);
  std::string* mutable_what_was_said();
  std::string* release_what_was_said();
  void set_allocated_what_was_said(std::string* what_was_said);
  private:
  const std::string& _internal_what_was_said() const;
  void _internal_set_what_was_said(const std::string& value);
  std::string* _internal_mutable_what_was_said();
  public:

  // optional bytes reported_attestation = 2;
  bool has_reported_attestation() const;
  private:
  bool _internal_has_reported_attestation() const;
  public:
  void clear_reported_attestation();
  const std::string& reported_attestation() const;
  void set_reported_attestation(const std::string& value);
  void set_reported_attestation(std::string&& value);
  void set_reported_attestation(const char* value);
  void set_reported_attestation(const void* value, size_t size);
  std::string* mutable_reported_attestation();
  std::string* release_reported_attestation();
  void set_allocated_reported_attestation(std::string* reported_attestation);
  private:
  const std::string& _internal_reported_attestation() const;
  void _internal_set_reported_attestation(const std::string& value);
  std::string* _internal_mutable_reported_attestation();
  public:

  // @@protoc_insertion_point(class_scope:sev_attestation_message)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr what_was_said_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr reported_attestation_;
  friend struct ::TableStruct_certifier_2eproto;
};
// -------------------------------------------------------------------

class gramine_attestation_message :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:gramine_attestation_message) */ {
 public:
  gramine_attestation_message();
  virtual ~gramine_attestation_message();

  gramine_attestation_message(const gramine_attestation_message& from);
  gramine_attestation_message(gramine_attestation_message&& from) noexcept
    : gramine_attestation_message() {
    *this = ::std::move(from);
  }

  inline gramine_attestation_message& operator=(const gramine_attestation_message& from) {
    CopyFrom(from);
    return *this;
  }
  inline gramine_attestation_message& operator=(gramine_attestation_message&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const gramine_attestation_message& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const gramine_attestation_message* internal_default_instance() {
    return reinterpret_cast<const gramine_attestation_message*>(
               &_gramine_attestation_message_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    22;

  friend void swap(gramine_attestation_message& a, gramine_attestation_message& b) {
    a.Swap(&b);
  }
  inline void Swap(gramine_attestation_message* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline gramine_attestation_message* New() const final {
    return CreateMaybeMessage<gramine_attestation_message>(nullptr);
  }

  gramine_attestation_message* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<gramine_attestation_message>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const gramine_attestation_message& from);
  void MergeFrom(const gramine_attestation_message& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(gramine_attestation_message* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "gramine_attestation_message";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_certifier_2eproto);
    return ::descriptor_table_certifier_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kWhatWasSaidFieldNumber = 1,
    kReportedAttestationFieldNumber = 2,
  };
  // optional bytes what_was_said = 1;
  bool has_what_was_said() const;
  private:
  bool _internal_has_what_was_said() const;
  public:
  void clear_what_was_said();
  const std::string& what_was_said() const;
  void set_what_was_said(const std::string& value);
  void set_what_was_said(std::string&& value);
  void set_what_was_said(const char* value);
  void set_what_was_said(const void* value, size_t size);
  std::string* mutable_what_was_said();
  std::string* release_what_was_said();
  void set_allocated_what_was_said(std::string* what_was_said);
  private:
  const std::string& _internal_what_was_said() const;
  void _internal_set_what_was_said(const std::string& value);
  std::string* _internal_mutable_what_was_said();
  public:

  // optional bytes reported_attestation = 2;
  bool has_reported_attestation() const;
  private:
  bool _internal_has_reported_attestation() const;
  public:
  void clear_reported_attestation();
  const std::string& reported_attestation() const;
  void set_reported_attestation(const std::string& value);
  void set_reported_attestation(std::string&& value);
  void set_reported_attestation(const char* value);
  void set_reported_attestation(const void* value, size_t size);
  std::string* mutable_reported_attestation();
  std::string* release_reported_attestation();
  void set_allocated_reported_attestation(std::string* reported_attestation);
  private:
  const std::string& _internal_reported_attestation() const;
  void _internal_set_reported_attestation(const std::string& value);
  std::string* _internal_mutable_reported_attestation();
  public:

  // @@protoc_insertion_point(class_scope:gramine_attestation_message)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr what_was_said_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr reported_attestation_;
  friend struct ::TableStruct_certifier_2eproto;
};
// -------------------------------------------------------------------

class evidence_package :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:evidence_package) */ {
 public:
  evidence_package();
  virtual ~evidence_package();

  evidence_package(const evidence_package& from);
  evidence_package(evidence_package&& from) noexcept
    : evidence_package() {
    *this = ::std::move(from);
  }

  inline evidence_package& operator=(const evidence_package& from) {
    CopyFrom(from);
    return *this;
  }
  inline evidence_package& operator=(evidence_package&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const evidence_package& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const evidence_package* internal_default_instance() {
    return reinterpret_cast<const evidence_package*>(
               &_evidence_package_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    23;

  friend void swap(evidence_package& a, evidence_package& b) {
    a.Swap(&b);
  }
  inline void Swap(evidence_package* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline evidence_package* New() const final {
    return CreateMaybeMessage<evidence_package>(nullptr);
  }

  evidence_package* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<evidence_package>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const evidence_package& from);
  void MergeFrom(const evidence_package& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(evidence_package* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "evidence_package";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_certifier_2eproto);
    return ::descriptor_table_certifier_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kFactAssertionFieldNumber = 2,
    kProverTypeFieldNumber = 1,
  };
  // repeated .evidence fact_assertion = 2;
  int fact_assertion_size() const;
  private:
  int _internal_fact_assertion_size() const;
  public:
  void clear_fact_assertion();
  ::evidence* mutable_fact_assertion(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::evidence >*
      mutable_fact_assertion();
  private:
  const ::evidence& _internal_fact_assertion(int index) const;
  ::evidence* _internal_add_fact_assertion();
  public:
  const ::evidence& fact_assertion(int index) const;
  ::evidence* add_fact_assertion();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::evidence >&
      fact_assertion() const;

  // optional string prover_type = 1;
  bool has_prover_type() const;
  private:
  bool _internal_has_prover_type() const;
  public:
  void clear_prover_type();
  const std::string& prover_type() const;
  void set_prover_type(const std::string& value);
  void set_prover_type(std::string&& value);
  void set_prover_type(const char* value);
  void set_prover_type(const char* value, size_t size);
  std::string* mutable_prover_type();
  std::string* release_prover_type();
  void set_allocated_prover_type(std::string* prover_type);
  private:
  const std::string& _internal_prover_type() const;
  void _internal_set_prover_type(const std::string& value);
  std::string* _internal_mutable_prover_type();
  public:

  // @@protoc_insertion_point(class_scope:evidence_package)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::evidence > fact_assertion_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr prover_type_;
  friend struct ::TableStruct_certifier_2eproto;
};
// -------------------------------------------------------------------

class certifier_rules :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:certifier_rules) */ {
 public:
  certifier_rules();
  virtual ~certifier_rules();

  certifier_rules(const certifier_rules& from);
  certifier_rules(certifier_rules&& from) noexcept
    : certifier_rules() {
    *this = ::std::move(from);
  }

  inline certifier_rules& operator=(const certifier_rules& from) {
    CopyFrom(from);
    return *this;
  }
  inline certifier_rules& operator=(certifier_rules&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const certifier_rules& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const certifier_rules* internal_default_instance() {
    return reinterpret_cast<const certifier_rules*>(
               &_certifier_rules_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    24;

  friend void swap(certifier_rules& a, certifier_rules& b) {
    a.Swap(&b);
  }
  inline void Swap(certifier_rules* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline certifier_rules* New() const final {
    return CreateMaybeMessage<certifier_rules>(nullptr);
  }

  certifier_rules* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<certifier_rules>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const certifier_rules& from);
  void MergeFrom(const certifier_rules& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(certifier_rules* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "certifier_rules";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_certifier_2eproto);
    return ::descriptor_table_certifier_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRuleFieldNumber = 1,
  };
  // repeated string rule = 1;
  int rule_size() const;
  private:
  int _internal_rule_size() const;
  public:
  void clear_rule();
  const std::string& rule(int index) const;
  std::string* mutable_rule(int index);
  void set_rule(int index, const std::string& value);
  void set_rule(int index, std::string&& value);
  void set_rule(int index, const char* value);
  void set_rule(int index, const char* value, size_t size);
  std::string* add_rule();
  void add_rule(const std::string& value);
  void add_rule(std::string&& value);
  void add_rule(const char* value);
  void add_rule(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& rule() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_rule();
  private:
  const std::string& _internal_rule(int index) const;
  std::string* _internal_add_rule();
  public:

  // @@protoc_insertion_point(class_scope:certifier_rules)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> rule_;
  friend struct ::TableStruct_certifier_2eproto;
};
// -------------------------------------------------------------------

class proved_statements :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:proved_statements) */ {
 public:
  proved_statements();
  virtual ~proved_statements();

  proved_statements(const proved_statements& from);
  proved_statements(proved_statements&& from) noexcept
    : proved_statements() {
    *this = ::std::move(from);
  }

  inline proved_statements& operator=(const proved_statements& from) {
    CopyFrom(from);
    return *this;
  }
  inline proved_statements& operator=(proved_statements&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const proved_statements& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const proved_statements* internal_default_instance() {
    return reinterpret_cast<const proved_statements*>(
               &_proved_statements_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    25;

  friend void swap(proved_statements& a, proved_statements& b) {
    a.Swap(&b);
  }
  inline void Swap(proved_statements* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline proved_statements* New() const final {
    return CreateMaybeMessage<proved_statements>(nullptr);
  }

  proved_statements* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<proved_statements>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const proved_statements& from);
  void MergeFrom(const proved_statements& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(proved_statements* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "proved_statements";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_certifier_2eproto);
    return ::descriptor_table_certifier_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kProvedFieldNumber = 1,
  };
  // repeated .vse_clause proved = 1;
  int proved_size() const;
  private:
  int _internal_proved_size() const;
  public:
  void clear_proved();
  ::vse_clause* mutable_proved(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vse_clause >*
      mutable_proved();
  private:
  const ::vse_clause& _internal_proved(int index) const;
  ::vse_clause* _internal_add_proved();
  public:
  const ::vse_clause& proved(int index) const;
  ::vse_clause* add_proved();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vse_clause >&
      proved() const;

  // @@protoc_insertion_point(class_scope:proved_statements)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vse_clause > proved_;
  friend struct ::TableStruct_certifier_2eproto;
};
// -------------------------------------------------------------------

class proof_step :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:proof_step) */ {
 public:
  proof_step();
  virtual ~proof_step();

  proof_step(const proof_step& from);
  proof_step(proof_step&& from) noexcept
    : proof_step() {
    *this = ::std::move(from);
  }

  inline proof_step& operator=(const proof_step& from) {
    CopyFrom(from);
    return *this;
  }
  inline proof_step& operator=(proof_step&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const proof_step& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const proof_step* internal_default_instance() {
    return reinterpret_cast<const proof_step*>(
               &_proof_step_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    26;

  friend void swap(proof_step& a, proof_step& b) {
    a.Swap(&b);
  }
  inline void Swap(proof_step* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline proof_step* New() const final {
    return CreateMaybeMessage<proof_step>(nullptr);
  }

  proof_step* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<proof_step>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const proof_step& from);
  void MergeFrom(const proof_step& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(proof_step* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "proof_step";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_certifier_2eproto);
    return ::descriptor_table_certifier_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kS1FieldNumber = 1,
    kS2FieldNumber = 2,
    kConclusionFieldNumber = 3,
    kRuleAppliedFieldNumber = 4,
  };
  // optional .vse_clause s1 = 1;
  bool has_s1() const;
  private:
  bool _internal_has_s1() const;
  public:
  void clear_s1();
  const ::vse_clause& s1() const;
  ::vse_clause* release_s1();
  ::vse_clause* mutable_s1();
  void set_allocated_s1(::vse_clause* s1);
  private:
  const ::vse_clause& _internal_s1() const;
  ::vse_clause* _internal_mutable_s1();
  public:

  // optional .vse_clause s2 = 2;
  bool has_s2() const;
  private:
  bool _internal_has_s2() const;
  public:
  void clear_s2();
  const ::vse_clause& s2() const;
  ::vse_clause* release_s2();
  ::vse_clause* mutable_s2();
  void set_allocated_s2(::vse_clause* s2);
  private:
  const ::vse_clause& _internal_s2() const;
  ::vse_clause* _internal_mutable_s2();
  public:

  // optional .vse_clause conclusion = 3;
  bool has_conclusion() const;
  private:
  bool _internal_has_conclusion() const;
  public:
  void clear_conclusion();
  const ::vse_clause& conclusion() const;
  ::vse_clause* release_conclusion();
  ::vse_clause* mutable_conclusion();
  void set_allocated_conclusion(::vse_clause* conclusion);
  private:
  const ::vse_clause& _internal_conclusion() const;
  ::vse_clause* _internal_mutable_conclusion();
  public:

  // optional int32 rule_applied = 4;
  bool has_rule_applied() const;
  private:
  bool _internal_has_rule_applied() const;
  public:
  void clear_rule_applied();
  ::PROTOBUF_NAMESPACE_ID::int32 rule_applied() const;
  void set_rule_applied(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_rule_applied() const;
  void _internal_set_rule_applied(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // @@protoc_insertion_point(class_scope:proof_step)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::vse_clause* s1_;
  ::vse_clause* s2_;
  ::vse_clause* conclusion_;
  ::PROTOBUF_NAMESPACE_ID::int32 rule_applied_;
  friend struct ::TableStruct_certifier_2eproto;
};
// -------------------------------------------------------------------

class proof :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:proof) */ {
 public:
  proof();
  virtual ~proof();

  proof(const proof& from);
  proof(proof&& from) noexcept
    : proof() {
    *this = ::std::move(from);
  }

  inline proof& operator=(const proof& from) {
    CopyFrom(from);
    return *this;
  }
  inline proof& operator=(proof&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const proof& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const proof* internal_default_instance() {
    return reinterpret_cast<const proof*>(
               &_proof_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    27;

  friend void swap(proof& a, proof& b) {
    a.Swap(&b);
  }
  inline void Swap(proof* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline proof* New() const final {
    return CreateMaybeMessage<proof>(nullptr);
  }

  proof* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<proof>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const proof& from);
  void MergeFrom(const proof& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(proof* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "proof";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_certifier_2eproto);
    return ::descriptor_table_certifier_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAlreadyProvedFieldNumber = 2,
    kStepsFieldNumber = 3,
    kToProveFieldNumber = 1,
  };
  // repeated .vse_clause already_proved = 2;
  int already_proved_size() const;
  private:
  int _internal_already_proved_size() const;
  public:
  void clear_already_proved();
  ::vse_clause* mutable_already_proved(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vse_clause >*
      mutable_already_proved();
  private:
  const ::vse_clause& _internal_already_proved(int index) const;
  ::vse_clause* _internal_add_already_proved();
  public:
  const ::vse_clause& already_proved(int index) const;
  ::vse_clause* add_already_proved();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vse_clause >&
      already_proved() const;

  // repeated .proof_step steps = 3;
  int steps_size() const;
  private:
  int _internal_steps_size() const;
  public:
  void clear_steps();
  ::proof_step* mutable_steps(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::proof_step >*
      mutable_steps();
  private:
  const ::proof_step& _internal_steps(int index) const;
  ::proof_step* _internal_add_steps();
  public:
  const ::proof_step& steps(int index) const;
  ::proof_step* add_steps();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::proof_step >&
      steps() const;

  // optional .vse_clause to_prove = 1;
  bool has_to_prove() const;
  private:
  bool _internal_has_to_prove() const;
  public:
  void clear_to_prove();
  const ::vse_clause& to_prove() const;
  ::vse_clause* release_to_prove();
  ::vse_clause* mutable_to_prove();
  void set_allocated_to_prove(::vse_clause* to_prove);
  private:
  const ::vse_clause& _internal_to_prove() const;
  ::vse_clause* _internal_mutable_to_prove();
  public:

  // @@protoc_insertion_point(class_scope:proof)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vse_clause > already_proved_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::proof_step > steps_;
  ::vse_clause* to_prove_;
  friend struct ::TableStruct_certifier_2eproto;
};
// -------------------------------------------------------------------

class trust_request_message :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:trust_request_message) */ {
 public:
  trust_request_message();
  virtual ~trust_request_message();

  trust_request_message(const trust_request_message& from);
  trust_request_message(trust_request_message&& from) noexcept
    : trust_request_message() {
    *this = ::std::move(from);
  }

  inline trust_request_message& operator=(const trust_request_message& from) {
    CopyFrom(from);
    return *this;
  }
  inline trust_request_message& operator=(trust_request_message&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const trust_request_message& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const trust_request_message* internal_default_instance() {
    return reinterpret_cast<const trust_request_message*>(
               &_trust_request_message_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    28;

  friend void swap(trust_request_message& a, trust_request_message& b) {
    a.Swap(&b);
  }
  inline void Swap(trust_request_message* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline trust_request_message* New() const final {
    return CreateMaybeMessage<trust_request_message>(nullptr);
  }

  trust_request_message* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<trust_request_message>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const trust_request_message& from);
  void MergeFrom(const trust_request_message& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(trust_request_message* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "trust_request_message";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_certifier_2eproto);
    return ::descriptor_table_certifier_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRequestingEnclaveTagFieldNumber = 1,
    kProvidingEnclaveTagFieldNumber = 2,
    kSubmittedEvidenceTypeFieldNumber = 3,
    kPurposeFieldNumber = 4,
    kSupportFieldNumber = 5,
  };
  // optional string requesting_enclave_tag = 1;
  bool has_requesting_enclave_tag() const;
  private:
  bool _internal_has_requesting_enclave_tag() const;
  public:
  void clear_requesting_enclave_tag();
  const std::string& requesting_enclave_tag() const;
  void set_requesting_enclave_tag(const std::string& value);
  void set_requesting_enclave_tag(std::string&& value);
  void set_requesting_enclave_tag(const char* value);
  void set_requesting_enclave_tag(const char* value, size_t size);
  std::string* mutable_requesting_enclave_tag();
  std::string* release_requesting_enclave_tag();
  void set_allocated_requesting_enclave_tag(std::string* requesting_enclave_tag);
  private:
  const std::string& _internal_requesting_enclave_tag() const;
  void _internal_set_requesting_enclave_tag(const std::string& value);
  std::string* _internal_mutable_requesting_enclave_tag();
  public:

  // optional string providing_enclave_tag = 2;
  bool has_providing_enclave_tag() const;
  private:
  bool _internal_has_providing_enclave_tag() const;
  public:
  void clear_providing_enclave_tag();
  const std::string& providing_enclave_tag() const;
  void set_providing_enclave_tag(const std::string& value);
  void set_providing_enclave_tag(std::string&& value);
  void set_providing_enclave_tag(const char* value);
  void set_providing_enclave_tag(const char* value, size_t size);
  std::string* mutable_providing_enclave_tag();
  std::string* release_providing_enclave_tag();
  void set_allocated_providing_enclave_tag(std::string* providing_enclave_tag);
  private:
  const std::string& _internal_providing_enclave_tag() const;
  void _internal_set_providing_enclave_tag(const std::string& value);
  std::string* _internal_mutable_providing_enclave_tag();
  public:

  // optional string submitted_evidence_type = 3;
  bool has_submitted_evidence_type() const;
  private:
  bool _internal_has_submitted_evidence_type() const;
  public:
  void clear_submitted_evidence_type();
  const std::string& submitted_evidence_type() const;
  void set_submitted_evidence_type(const std::string& value);
  void set_submitted_evidence_type(std::string&& value);
  void set_submitted_evidence_type(const char* value);
  void set_submitted_evidence_type(const char* value, size_t size);
  std::string* mutable_submitted_evidence_type();
  std::string* release_submitted_evidence_type();
  void set_allocated_submitted_evidence_type(std::string* submitted_evidence_type);
  private:
  const std::string& _internal_submitted_evidence_type() const;
  void _internal_set_submitted_evidence_type(const std::string& value);
  std::string* _internal_mutable_submitted_evidence_type();
  public:

  // optional string purpose = 4;
  bool has_purpose() const;
  private:
  bool _internal_has_purpose() const;
  public:
  void clear_purpose();
  const std::string& purpose() const;
  void set_purpose(const std::string& value);
  void set_purpose(std::string&& value);
  void set_purpose(const char* value);
  void set_purpose(const char* value, size_t size);
  std::string* mutable_purpose();
  std::string* release_purpose();
  void set_allocated_purpose(std::string* purpose);
  private:
  const std::string& _internal_purpose() const;
  void _internal_set_purpose(const std::string& value);
  std::string* _internal_mutable_purpose();
  public:

  // optional .evidence_package support = 5;
  bool has_support() const;
  private:
  bool _internal_has_support() const;
  public:
  void clear_support();
  const ::evidence_package& support() const;
  ::evidence_package* release_support();
  ::evidence_package* mutable_support();
  void set_allocated_support(::evidence_package* support);
  private:
  const ::evidence_package& _internal_support() const;
  ::evidence_package* _internal_mutable_support();
  public:

  // @@protoc_insertion_point(class_scope:trust_request_message)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr requesting_enclave_tag_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr providing_enclave_tag_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr submitted_evidence_type_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr purpose_;
  ::evidence_package* support_;
  friend struct ::TableStruct_certifier_2eproto;
};
// -------------------------------------------------------------------

class trust_response_message :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:trust_response_message) */ {
 public:
  trust_response_message();
  virtual ~trust_response_message();

  trust_response_message(const trust_response_message& from);
  trust_response_message(trust_response_message&& from) noexcept
    : trust_response_message() {
    *this = ::std::move(from);
  }

  inline trust_response_message& operator=(const trust_response_message& from) {
    CopyFrom(from);
    return *this;
  }
  inline trust_response_message& operator=(trust_response_message&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const trust_response_message& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const trust_response_message* internal_default_instance() {
    return reinterpret_cast<const trust_response_message*>(
               &_trust_response_message_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    29;

  friend void swap(trust_response_message& a, trust_response_message& b) {
    a.Swap(&b);
  }
  inline void Swap(trust_response_message* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline trust_response_message* New() const final {
    return CreateMaybeMessage<trust_response_message>(nullptr);
  }

  trust_response_message* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<trust_response_message>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const trust_response_message& from);
  void MergeFrom(const trust_response_message& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(trust_response_message* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "trust_response_message";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_certifier_2eproto);
    return ::descriptor_table_certifier_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kStatusFieldNumber = 1,
    kRequestingEnclaveTagFieldNumber = 2,
    kProvidingEnclaveTagFieldNumber = 3,
    kArtifactFieldNumber = 4,
  };
  // optional string status = 1;
  bool has_status() const;
  private:
  bool _internal_has_status() const;
  public:
  void clear_status();
  const std::string& status() const;
  void set_status(const std::string& value);
  void set_status(std::string&& value);
  void set_status(const char* value);
  void set_status(const char* value, size_t size);
  std::string* mutable_status();
  std::string* release_status();
  void set_allocated_status(std::string* status);
  private:
  const std::string& _internal_status() const;
  void _internal_set_status(const std::string& value);
  std::string* _internal_mutable_status();
  public:

  // optional string requesting_enclave_tag = 2;
  bool has_requesting_enclave_tag() const;
  private:
  bool _internal_has_requesting_enclave_tag() const;
  public:
  void clear_requesting_enclave_tag();
  const std::string& requesting_enclave_tag() const;
  void set_requesting_enclave_tag(const std::string& value);
  void set_requesting_enclave_tag(std::string&& value);
  void set_requesting_enclave_tag(const char* value);
  void set_requesting_enclave_tag(const char* value, size_t size);
  std::string* mutable_requesting_enclave_tag();
  std::string* release_requesting_enclave_tag();
  void set_allocated_requesting_enclave_tag(std::string* requesting_enclave_tag);
  private:
  const std::string& _internal_requesting_enclave_tag() const;
  void _internal_set_requesting_enclave_tag(const std::string& value);
  std::string* _internal_mutable_requesting_enclave_tag();
  public:

  // optional string providing_enclave_tag = 3;
  bool has_providing_enclave_tag() const;
  private:
  bool _internal_has_providing_enclave_tag() const;
  public:
  void clear_providing_enclave_tag();
  const std::string& providing_enclave_tag() const;
  void set_providing_enclave_tag(const std::string& value);
  void set_providing_enclave_tag(std::string&& value);
  void set_providing_enclave_tag(const char* value);
  void set_providing_enclave_tag(const char* value, size_t size);
  std::string* mutable_providing_enclave_tag();
  std::string* release_providing_enclave_tag();
  void set_allocated_providing_enclave_tag(std::string* providing_enclave_tag);
  private:
  const std::string& _internal_providing_enclave_tag() const;
  void _internal_set_providing_enclave_tag(const std::string& value);
  std::string* _internal_mutable_providing_enclave_tag();
  public:

  // optional bytes artifact = 4;
  bool has_artifact() const;
  private:
  bool _internal_has_artifact() const;
  public:
  void clear_artifact();
  const std::string& artifact() const;
  void set_artifact(const std::string& value);
  void set_artifact(std::string&& value);
  void set_artifact(const char* value);
  void set_artifact(const void* value, size_t size);
  std::string* mutable_artifact();
  std::string* release_artifact();
  void set_allocated_artifact(std::string* artifact);
  private:
  const std::string& _internal_artifact() const;
  void _internal_set_artifact(const std::string& value);
  std::string* _internal_mutable_artifact();
  public:

  // @@protoc_insertion_point(class_scope:trust_response_message)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr status_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr requesting_enclave_tag_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr providing_enclave_tag_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr artifact_;
  friend struct ::TableStruct_certifier_2eproto;
};
// -------------------------------------------------------------------

class storage_info_message :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:storage_info_message) */ {
 public:
  storage_info_message();
  virtual ~storage_info_message();

  storage_info_message(const storage_info_message& from);
  storage_info_message(storage_info_message&& from) noexcept
    : storage_info_message() {
    *this = ::std::move(from);
  }

  inline storage_info_message& operator=(const storage_info_message& from) {
    CopyFrom(from);
    return *this;
  }
  inline storage_info_message& operator=(storage_info_message&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const storage_info_message& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const storage_info_message* internal_default_instance() {
    return reinterpret_cast<const storage_info_message*>(
               &_storage_info_message_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    30;

  friend void swap(storage_info_message& a, storage_info_message& b) {
    a.Swap(&b);
  }
  inline void Swap(storage_info_message* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline storage_info_message* New() const final {
    return CreateMaybeMessage<storage_info_message>(nullptr);
  }

  storage_info_message* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<storage_info_message>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const storage_info_message& from);
  void MergeFrom(const storage_info_message& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(storage_info_message* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "storage_info_message";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_certifier_2eproto);
    return ::descriptor_table_certifier_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kStorageTypeFieldNumber = 1,
    kStorageDescriptorFieldNumber = 2,
    kAddressFieldNumber = 3,
    kTagFieldNumber = 5,
    kStorageKeyFieldNumber = 4,
  };
  // optional string storage_type = 1;
  bool has_storage_type() const;
  private:
  bool _internal_has_storage_type() const;
  public:
  void clear_storage_type();
  const std::string& storage_type() const;
  void set_storage_type(const std::string& value);
  void set_storage_type(std::string&& value);
  void set_storage_type(const char* value);
  void set_storage_type(const char* value, size_t size);
  std::string* mutable_storage_type();
  std::string* release_storage_type();
  void set_allocated_storage_type(std::string* storage_type);
  private:
  const std::string& _internal_storage_type() const;
  void _internal_set_storage_type(const std::string& value);
  std::string* _internal_mutable_storage_type();
  public:

  // optional string storage_descriptor = 2;
  bool has_storage_descriptor() const;
  private:
  bool _internal_has_storage_descriptor() const;
  public:
  void clear_storage_descriptor();
  const std::string& storage_descriptor() const;
  void set_storage_descriptor(const std::string& value);
  void set_storage_descriptor(std::string&& value);
  void set_storage_descriptor(const char* value);
  void set_storage_descriptor(const char* value, size_t size);
  std::string* mutable_storage_descriptor();
  std::string* release_storage_descriptor();
  void set_allocated_storage_descriptor(std::string* storage_descriptor);
  private:
  const std::string& _internal_storage_descriptor() const;
  void _internal_set_storage_descriptor(const std::string& value);
  std::string* _internal_mutable_storage_descriptor();
  public:

  // optional string address = 3;
  bool has_address() const;
  private:
  bool _internal_has_address() const;
  public:
  void clear_address();
  const std::string& address() const;
  void set_address(const std::string& value);
  void set_address(std::string&& value);
  void set_address(const char* value);
  void set_address(const char* value, size_t size);
  std::string* mutable_address();
  std::string* release_address();
  void set_allocated_address(std::string* address);
  private:
  const std::string& _internal_address() const;
  void _internal_set_address(const std::string& value);
  std::string* _internal_mutable_address();
  public:

  // optional string tag = 5;
  bool has_tag() const;
  private:
  bool _internal_has_tag() const;
  public:
  void clear_tag();
  const std::string& tag() const;
  void set_tag(const std::string& value);
  void set_tag(std::string&& value);
  void set_tag(const char* value);
  void set_tag(const char* value, size_t size);
  std::string* mutable_tag();
  std::string* release_tag();
  void set_allocated_tag(std::string* tag);
  private:
  const std::string& _internal_tag() const;
  void _internal_set_tag(const std::string& value);
  std::string* _internal_mutable_tag();
  public:

  // optional .key_message storage_key = 4;
  bool has_storage_key() const;
  private:
  bool _internal_has_storage_key() const;
  public:
  void clear_storage_key();
  const ::key_message& storage_key() const;
  ::key_message* release_storage_key();
  ::key_message* mutable_storage_key();
  void set_allocated_storage_key(::key_message* storage_key);
  private:
  const ::key_message& _internal_storage_key() const;
  ::key_message* _internal_mutable_storage_key();
  public:

  // @@protoc_insertion_point(class_scope:storage_info_message)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr storage_type_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr storage_descriptor_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr address_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr tag_;
  ::key_message* storage_key_;
  friend struct ::TableStruct_certifier_2eproto;
};
// -------------------------------------------------------------------

class channel_key_message :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:channel_key_message) */ {
 public:
  channel_key_message();
  virtual ~channel_key_message();

  channel_key_message(const channel_key_message& from);
  channel_key_message(channel_key_message&& from) noexcept
    : channel_key_message() {
    *this = ::std::move(from);
  }

  inline channel_key_message& operator=(const channel_key_message& from) {
    CopyFrom(from);
    return *this;
  }
  inline channel_key_message& operator=(channel_key_message&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const channel_key_message& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const channel_key_message* internal_default_instance() {
    return reinterpret_cast<const channel_key_message*>(
               &_channel_key_message_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    31;

  friend void swap(channel_key_message& a, channel_key_message& b) {
    a.Swap(&b);
  }
  inline void Swap(channel_key_message* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline channel_key_message* New() const final {
    return CreateMaybeMessage<channel_key_message>(nullptr);
  }

  channel_key_message* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<channel_key_message>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const channel_key_message& from);
  void MergeFrom(const channel_key_message& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(channel_key_message* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "channel_key_message";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_certifier_2eproto);
    return ::descriptor_table_certifier_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTagFieldNumber = 1,
    kAuthKeyFieldNumber = 2,
  };
  // optional string tag = 1;
  bool has_tag() const;
  private:
  bool _internal_has_tag() const;
  public:
  void clear_tag();
  const std::string& tag() const;
  void set_tag(const std::string& value);
  void set_tag(std::string&& value);
  void set_tag(const char* value);
  void set_tag(const char* value, size_t size);
  std::string* mutable_tag();
  std::string* release_tag();
  void set_allocated_tag(std::string* tag);
  private:
  const std::string& _internal_tag() const;
  void _internal_set_tag(const std::string& value);
  std::string* _internal_mutable_tag();
  public:

  // optional .key_message auth_key = 2;
  bool has_auth_key() const;
  private:
  bool _internal_has_auth_key() const;
  public:
  void clear_auth_key();
  const ::key_message& auth_key() const;
  ::key_message* release_auth_key();
  ::key_message* mutable_auth_key();
  void set_allocated_auth_key(::key_message* auth_key);
  private:
  const ::key_message& _internal_auth_key() const;
  ::key_message* _internal_mutable_auth_key();
  public:

  // @@protoc_insertion_point(class_scope:channel_key_message)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr tag_;
  ::key_message* auth_key_;
  friend struct ::TableStruct_certifier_2eproto;
};
// -------------------------------------------------------------------

class trusted_service_message :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:trusted_service_message) */ {
 public:
  trusted_service_message();
  virtual ~trusted_service_message();

  trusted_service_message(const trusted_service_message& from);
  trusted_service_message(trusted_service_message&& from) noexcept
    : trusted_service_message() {
    *this = ::std::move(from);
  }

  inline trusted_service_message& operator=(const trusted_service_message& from) {
    CopyFrom(from);
    return *this;
  }
  inline trusted_service_message& operator=(trusted_service_message&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const trusted_service_message& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const trusted_service_message* internal_default_instance() {
    return reinterpret_cast<const trusted_service_message*>(
               &_trusted_service_message_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    32;

  friend void swap(trusted_service_message& a, trusted_service_message& b) {
    a.Swap(&b);
  }
  inline void Swap(trusted_service_message* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline trusted_service_message* New() const final {
    return CreateMaybeMessage<trusted_service_message>(nullptr);
  }

  trusted_service_message* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<trusted_service_message>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const trusted_service_message& from);
  void MergeFrom(const trusted_service_message& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(trusted_service_message* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "trusted_service_message";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_certifier_2eproto);
    return ::descriptor_table_certifier_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTrustedServiceAddressFieldNumber = 1,
    kTagFieldNumber = 3,
    kTrustedServiceKeyFieldNumber = 2,
  };
  // optional string trusted_service_address = 1;
  bool has_trusted_service_address() const;
  private:
  bool _internal_has_trusted_service_address() const;
  public:
  void clear_trusted_service_address();
  const std::string& trusted_service_address() const;
  void set_trusted_service_address(const std::string& value);
  void set_trusted_service_address(std::string&& value);
  void set_trusted_service_address(const char* value);
  void set_trusted_service_address(const char* value, size_t size);
  std::string* mutable_trusted_service_address();
  std::string* release_trusted_service_address();
  void set_allocated_trusted_service_address(std::string* trusted_service_address);
  private:
  const std::string& _internal_trusted_service_address() const;
  void _internal_set_trusted_service_address(const std::string& value);
  std::string* _internal_mutable_trusted_service_address();
  public:

  // optional string tag = 3;
  bool has_tag() const;
  private:
  bool _internal_has_tag() const;
  public:
  void clear_tag();
  const std::string& tag() const;
  void set_tag(const std::string& value);
  void set_tag(std::string&& value);
  void set_tag(const char* value);
  void set_tag(const char* value, size_t size);
  std::string* mutable_tag();
  std::string* release_tag();
  void set_allocated_tag(std::string* tag);
  private:
  const std::string& _internal_tag() const;
  void _internal_set_tag(const std::string& value);
  std::string* _internal_mutable_tag();
  public:

  // optional .key_message trusted_service_key = 2;
  bool has_trusted_service_key() const;
  private:
  bool _internal_has_trusted_service_key() const;
  public:
  void clear_trusted_service_key();
  const ::key_message& trusted_service_key() const;
  ::key_message* release_trusted_service_key();
  ::key_message* mutable_trusted_service_key();
  void set_allocated_trusted_service_key(::key_message* trusted_service_key);
  private:
  const ::key_message& _internal_trusted_service_key() const;
  ::key_message* _internal_mutable_trusted_service_key();
  public:

  // @@protoc_insertion_point(class_scope:trusted_service_message)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr trusted_service_address_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr tag_;
  ::key_message* trusted_service_key_;
  friend struct ::TableStruct_certifier_2eproto;
};
// -------------------------------------------------------------------

class tagged_claim :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:tagged_claim) */ {
 public:
  tagged_claim();
  virtual ~tagged_claim();

  tagged_claim(const tagged_claim& from);
  tagged_claim(tagged_claim&& from) noexcept
    : tagged_claim() {
    *this = ::std::move(from);
  }

  inline tagged_claim& operator=(const tagged_claim& from) {
    CopyFrom(from);
    return *this;
  }
  inline tagged_claim& operator=(tagged_claim&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const tagged_claim& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const tagged_claim* internal_default_instance() {
    return reinterpret_cast<const tagged_claim*>(
               &_tagged_claim_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    33;

  friend void swap(tagged_claim& a, tagged_claim& b) {
    a.Swap(&b);
  }
  inline void Swap(tagged_claim* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline tagged_claim* New() const final {
    return CreateMaybeMessage<tagged_claim>(nullptr);
  }

  tagged_claim* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<tagged_claim>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const tagged_claim& from);
  void MergeFrom(const tagged_claim& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(tagged_claim* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "tagged_claim";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_certifier_2eproto);
    return ::descriptor_table_certifier_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTagFieldNumber = 1,
    kClaimFieldNumber = 2,
  };
  // optional string tag = 1;
  bool has_tag() const;
  private:
  bool _internal_has_tag() const;
  public:
  void clear_tag();
  const std::string& tag() const;
  void set_tag(const std::string& value);
  void set_tag(std::string&& value);
  void set_tag(const char* value);
  void set_tag(const char* value, size_t size);
  std::string* mutable_tag();
  std::string* release_tag();
  void set_allocated_tag(std::string* tag);
  private:
  const std::string& _internal_tag() const;
  void _internal_set_tag(const std::string& value);
  std::string* _internal_mutable_tag();
  public:

  // optional .claim_message claim = 2;
  bool has_claim() const;
  private:
  bool _internal_has_claim() const;
  public:
  void clear_claim();
  const ::claim_message& claim() const;
  ::claim_message* release_claim();
  ::claim_message* mutable_claim();
  void set_allocated_claim(::claim_message* claim);
  private:
  const ::claim_message& _internal_claim() const;
  ::claim_message* _internal_mutable_claim();
  public:

  // @@protoc_insertion_point(class_scope:tagged_claim)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr tag_;
  ::claim_message* claim_;
  friend struct ::TableStruct_certifier_2eproto;
};
// -------------------------------------------------------------------

class tagged_claims_sequence :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:tagged_claims_sequence) */ {
 public:
  tagged_claims_sequence();
  virtual ~tagged_claims_sequence();

  tagged_claims_sequence(const tagged_claims_sequence& from);
  tagged_claims_sequence(tagged_claims_sequence&& from) noexcept
    : tagged_claims_sequence() {
    *this = ::std::move(from);
  }

  inline tagged_claims_sequence& operator=(const tagged_claims_sequence& from) {
    CopyFrom(from);
    return *this;
  }
  inline tagged_claims_sequence& operator=(tagged_claims_sequence&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const tagged_claims_sequence& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const tagged_claims_sequence* internal_default_instance() {
    return reinterpret_cast<const tagged_claims_sequence*>(
               &_tagged_claims_sequence_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    34;

  friend void swap(tagged_claims_sequence& a, tagged_claims_sequence& b) {
    a.Swap(&b);
  }
  inline void Swap(tagged_claims_sequence* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline tagged_claims_sequence* New() const final {
    return CreateMaybeMessage<tagged_claims_sequence>(nullptr);
  }

  tagged_claims_sequence* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<tagged_claims_sequence>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const tagged_claims_sequence& from);
  void MergeFrom(const tagged_claims_sequence& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(tagged_claims_sequence* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "tagged_claims_sequence";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_certifier_2eproto);
    return ::descriptor_table_certifier_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kClaimsFieldNumber = 1,
  };
  // repeated .tagged_claim claims = 1;
  int claims_size() const;
  private:
  int _internal_claims_size() const;
  public:
  void clear_claims();
  ::tagged_claim* mutable_claims(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::tagged_claim >*
      mutable_claims();
  private:
  const ::tagged_claim& _internal_claims(int index) const;
  ::tagged_claim* _internal_add_claims();
  public:
  const ::tagged_claim& claims(int index) const;
  ::tagged_claim* add_claims();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::tagged_claim >&
      claims() const;

  // @@protoc_insertion_point(class_scope:tagged_claims_sequence)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::tagged_claim > claims_;
  friend struct ::TableStruct_certifier_2eproto;
};
// -------------------------------------------------------------------

class policy_store_message :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:policy_store_message) */ {
 public:
  policy_store_message();
  virtual ~policy_store_message();

  policy_store_message(const policy_store_message& from);
  policy_store_message(policy_store_message&& from) noexcept
    : policy_store_message() {
    *this = ::std::move(from);
  }

  inline policy_store_message& operator=(const policy_store_message& from) {
    CopyFrom(from);
    return *this;
  }
  inline policy_store_message& operator=(policy_store_message&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const policy_store_message& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const policy_store_message* internal_default_instance() {
    return reinterpret_cast<const policy_store_message*>(
               &_policy_store_message_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    35;

  friend void swap(policy_store_message& a, policy_store_message& b) {
    a.Swap(&b);
  }
  inline void Swap(policy_store_message* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline policy_store_message* New() const final {
    return CreateMaybeMessage<policy_store_message>(nullptr);
  }

  policy_store_message* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<policy_store_message>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const policy_store_message& from);
  void MergeFrom(const policy_store_message& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(policy_store_message* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "policy_store_message";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_certifier_2eproto);
    return ::descriptor_table_certifier_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTrustedServicesFieldNumber = 2,
    kChannelAuthenticationKeysFieldNumber = 3,
    kClaimsFieldNumber = 4,
    kStorageInfoFieldNumber = 5,
    kSignedClaimsFieldNumber = 6,
    kBlobsFieldNumber = 7,
    kPolicyKeyFieldNumber = 1,
  };
  // repeated .trusted_service_message trusted_services = 2;
  int trusted_services_size() const;
  private:
  int _internal_trusted_services_size() const;
  public:
  void clear_trusted_services();
  ::trusted_service_message* mutable_trusted_services(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::trusted_service_message >*
      mutable_trusted_services();
  private:
  const ::trusted_service_message& _internal_trusted_services(int index) const;
  ::trusted_service_message* _internal_add_trusted_services();
  public:
  const ::trusted_service_message& trusted_services(int index) const;
  ::trusted_service_message* add_trusted_services();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::trusted_service_message >&
      trusted_services() const;

  // repeated .channel_key_message channel_authentication_keys = 3;
  int channel_authentication_keys_size() const;
  private:
  int _internal_channel_authentication_keys_size() const;
  public:
  void clear_channel_authentication_keys();
  ::channel_key_message* mutable_channel_authentication_keys(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::channel_key_message >*
      mutable_channel_authentication_keys();
  private:
  const ::channel_key_message& _internal_channel_authentication_keys(int index) const;
  ::channel_key_message* _internal_add_channel_authentication_keys();
  public:
  const ::channel_key_message& channel_authentication_keys(int index) const;
  ::channel_key_message* add_channel_authentication_keys();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::channel_key_message >&
      channel_authentication_keys() const;

  // repeated .tagged_claim claims = 4;
  int claims_size() const;
  private:
  int _internal_claims_size() const;
  public:
  void clear_claims();
  ::tagged_claim* mutable_claims(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::tagged_claim >*
      mutable_claims();
  private:
  const ::tagged_claim& _internal_claims(int index) const;
  ::tagged_claim* _internal_add_claims();
  public:
  const ::tagged_claim& claims(int index) const;
  ::tagged_claim* add_claims();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::tagged_claim >&
      claims() const;

  // repeated .storage_info_message storage_info = 5;
  int storage_info_size() const;
  private:
  int _internal_storage_info_size() const;
  public:
  void clear_storage_info();
  ::storage_info_message* mutable_storage_info(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::storage_info_message >*
      mutable_storage_info();
  private:
  const ::storage_info_message& _internal_storage_info(int index) const;
  ::storage_info_message* _internal_add_storage_info();
  public:
  const ::storage_info_message& storage_info(int index) const;
  ::storage_info_message* add_storage_info();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::storage_info_message >&
      storage_info() const;

  // repeated .tagged_signed_claim signed_claims = 6;
  int signed_claims_size() const;
  private:
  int _internal_signed_claims_size() const;
  public:
  void clear_signed_claims();
  ::tagged_signed_claim* mutable_signed_claims(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::tagged_signed_claim >*
      mutable_signed_claims();
  private:
  const ::tagged_signed_claim& _internal_signed_claims(int index) const;
  ::tagged_signed_claim* _internal_add_signed_claims();
  public:
  const ::tagged_signed_claim& signed_claims(int index) const;
  ::tagged_signed_claim* add_signed_claims();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::tagged_signed_claim >&
      signed_claims() const;

  // repeated .tagged_blob_message blobs = 7;
  int blobs_size() const;
  private:
  int _internal_blobs_size() const;
  public:
  void clear_blobs();
  ::tagged_blob_message* mutable_blobs(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::tagged_blob_message >*
      mutable_blobs();
  private:
  const ::tagged_blob_message& _internal_blobs(int index) const;
  ::tagged_blob_message* _internal_add_blobs();
  public:
  const ::tagged_blob_message& blobs(int index) const;
  ::tagged_blob_message* add_blobs();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::tagged_blob_message >&
      blobs() const;

  // optional .key_message policy_key = 1;
  bool has_policy_key() const;
  private:
  bool _internal_has_policy_key() const;
  public:
  void clear_policy_key();
  const ::key_message& policy_key() const;
  ::key_message* release_policy_key();
  ::key_message* mutable_policy_key();
  void set_allocated_policy_key(::key_message* policy_key);
  private:
  const ::key_message& _internal_policy_key() const;
  ::key_message* _internal_mutable_policy_key();
  public:

  // @@protoc_insertion_point(class_scope:policy_store_message)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::trusted_service_message > trusted_services_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::channel_key_message > channel_authentication_keys_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::tagged_claim > claims_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::storage_info_message > storage_info_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::tagged_signed_claim > signed_claims_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::tagged_blob_message > blobs_;
  ::key_message* policy_key_;
  friend struct ::TableStruct_certifier_2eproto;
};
// -------------------------------------------------------------------

class claims_sequence :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:claims_sequence) */ {
 public:
  claims_sequence();
  virtual ~claims_sequence();

  claims_sequence(const claims_sequence& from);
  claims_sequence(claims_sequence&& from) noexcept
    : claims_sequence() {
    *this = ::std::move(from);
  }

  inline claims_sequence& operator=(const claims_sequence& from) {
    CopyFrom(from);
    return *this;
  }
  inline claims_sequence& operator=(claims_sequence&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const claims_sequence& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const claims_sequence* internal_default_instance() {
    return reinterpret_cast<const claims_sequence*>(
               &_claims_sequence_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    36;

  friend void swap(claims_sequence& a, claims_sequence& b) {
    a.Swap(&b);
  }
  inline void Swap(claims_sequence* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline claims_sequence* New() const final {
    return CreateMaybeMessage<claims_sequence>(nullptr);
  }

  claims_sequence* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<claims_sequence>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const claims_sequence& from);
  void MergeFrom(const claims_sequence& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(claims_sequence* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "claims_sequence";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_certifier_2eproto);
    return ::descriptor_table_certifier_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kClaimsFieldNumber = 1,
  };
  // repeated .claim_message claims = 1;
  int claims_size() const;
  private:
  int _internal_claims_size() const;
  public:
  void clear_claims();
  ::claim_message* mutable_claims(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::claim_message >*
      mutable_claims();
  private:
  const ::claim_message& _internal_claims(int index) const;
  ::claim_message* _internal_add_claims();
  public:
  const ::claim_message& claims(int index) const;
  ::claim_message* add_claims();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::claim_message >&
      claims() const;

  // @@protoc_insertion_point(class_scope:claims_sequence)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::claim_message > claims_;
  friend struct ::TableStruct_certifier_2eproto;
};
// -------------------------------------------------------------------

class signed_claim_sequence :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:signed_claim_sequence) */ {
 public:
  signed_claim_sequence();
  virtual ~signed_claim_sequence();

  signed_claim_sequence(const signed_claim_sequence& from);
  signed_claim_sequence(signed_claim_sequence&& from) noexcept
    : signed_claim_sequence() {
    *this = ::std::move(from);
  }

  inline signed_claim_sequence& operator=(const signed_claim_sequence& from) {
    CopyFrom(from);
    return *this;
  }
  inline signed_claim_sequence& operator=(signed_claim_sequence&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const signed_claim_sequence& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const signed_claim_sequence* internal_default_instance() {
    return reinterpret_cast<const signed_claim_sequence*>(
               &_signed_claim_sequence_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    37;

  friend void swap(signed_claim_sequence& a, signed_claim_sequence& b) {
    a.Swap(&b);
  }
  inline void Swap(signed_claim_sequence* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline signed_claim_sequence* New() const final {
    return CreateMaybeMessage<signed_claim_sequence>(nullptr);
  }

  signed_claim_sequence* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<signed_claim_sequence>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const signed_claim_sequence& from);
  void MergeFrom(const signed_claim_sequence& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(signed_claim_sequence* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "signed_claim_sequence";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_certifier_2eproto);
    return ::descriptor_table_certifier_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kClaimsFieldNumber = 1,
  };
  // repeated .signed_claim_message claims = 1;
  int claims_size() const;
  private:
  int _internal_claims_size() const;
  public:
  void clear_claims();
  ::signed_claim_message* mutable_claims(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::signed_claim_message >*
      mutable_claims();
  private:
  const ::signed_claim_message& _internal_claims(int index) const;
  ::signed_claim_message* _internal_add_claims();
  public:
  const ::signed_claim_message& claims(int index) const;
  ::signed_claim_message* add_claims();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::signed_claim_message >&
      claims() const;

  // @@protoc_insertion_point(class_scope:signed_claim_sequence)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::signed_claim_message > claims_;
  friend struct ::TableStruct_certifier_2eproto;
};
// -------------------------------------------------------------------

class tagged_signed_claim :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:tagged_signed_claim) */ {
 public:
  tagged_signed_claim();
  virtual ~tagged_signed_claim();

  tagged_signed_claim(const tagged_signed_claim& from);
  tagged_signed_claim(tagged_signed_claim&& from) noexcept
    : tagged_signed_claim() {
    *this = ::std::move(from);
  }

  inline tagged_signed_claim& operator=(const tagged_signed_claim& from) {
    CopyFrom(from);
    return *this;
  }
  inline tagged_signed_claim& operator=(tagged_signed_claim&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const tagged_signed_claim& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const tagged_signed_claim* internal_default_instance() {
    return reinterpret_cast<const tagged_signed_claim*>(
               &_tagged_signed_claim_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    38;

  friend void swap(tagged_signed_claim& a, tagged_signed_claim& b) {
    a.Swap(&b);
  }
  inline void Swap(tagged_signed_claim* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline tagged_signed_claim* New() const final {
    return CreateMaybeMessage<tagged_signed_claim>(nullptr);
  }

  tagged_signed_claim* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<tagged_signed_claim>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const tagged_signed_claim& from);
  void MergeFrom(const tagged_signed_claim& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(tagged_signed_claim* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "tagged_signed_claim";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_certifier_2eproto);
    return ::descriptor_table_certifier_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTagFieldNumber = 1,
    kScFieldNumber = 2,
  };
  // optional string tag = 1;
  bool has_tag() const;
  private:
  bool _internal_has_tag() const;
  public:
  void clear_tag();
  const std::string& tag() const;
  void set_tag(const std::string& value);
  void set_tag(std::string&& value);
  void set_tag(const char* value);
  void set_tag(const char* value, size_t size);
  std::string* mutable_tag();
  std::string* release_tag();
  void set_allocated_tag(std::string* tag);
  private:
  const std::string& _internal_tag() const;
  void _internal_set_tag(const std::string& value);
  std::string* _internal_mutable_tag();
  public:

  // optional .signed_claim_message sc = 2;
  bool has_sc() const;
  private:
  bool _internal_has_sc() const;
  public:
  void clear_sc();
  const ::signed_claim_message& sc() const;
  ::signed_claim_message* release_sc();
  ::signed_claim_message* mutable_sc();
  void set_allocated_sc(::signed_claim_message* sc);
  private:
  const ::signed_claim_message& _internal_sc() const;
  ::signed_claim_message* _internal_mutable_sc();
  public:

  // @@protoc_insertion_point(class_scope:tagged_signed_claim)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr tag_;
  ::signed_claim_message* sc_;
  friend struct ::TableStruct_certifier_2eproto;
};
// -------------------------------------------------------------------

class buffer_sequence :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:buffer_sequence) */ {
 public:
  buffer_sequence();
  virtual ~buffer_sequence();

  buffer_sequence(const buffer_sequence& from);
  buffer_sequence(buffer_sequence&& from) noexcept
    : buffer_sequence() {
    *this = ::std::move(from);
  }

  inline buffer_sequence& operator=(const buffer_sequence& from) {
    CopyFrom(from);
    return *this;
  }
  inline buffer_sequence& operator=(buffer_sequence&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const buffer_sequence& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const buffer_sequence* internal_default_instance() {
    return reinterpret_cast<const buffer_sequence*>(
               &_buffer_sequence_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    39;

  friend void swap(buffer_sequence& a, buffer_sequence& b) {
    a.Swap(&b);
  }
  inline void Swap(buffer_sequence* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline buffer_sequence* New() const final {
    return CreateMaybeMessage<buffer_sequence>(nullptr);
  }

  buffer_sequence* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<buffer_sequence>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const buffer_sequence& from);
  void MergeFrom(const buffer_sequence& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(buffer_sequence* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "buffer_sequence";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_certifier_2eproto);
    return ::descriptor_table_certifier_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kBlockFieldNumber = 1,
  };
  // repeated bytes block = 1;
  int block_size() const;
  private:
  int _internal_block_size() const;
  public:
  void clear_block();
  const std::string& block(int index) const;
  std::string* mutable_block(int index);
  void set_block(int index, const std::string& value);
  void set_block(int index, std::string&& value);
  void set_block(int index, const char* value);
  void set_block(int index, const void* value, size_t size);
  std::string* add_block();
  void add_block(const std::string& value);
  void add_block(std::string&& value);
  void add_block(const char* value);
  void add_block(const void* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& block() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_block();
  private:
  const std::string& _internal_block(int index) const;
  std::string* _internal_add_block();
  public:

  // @@protoc_insertion_point(class_scope:buffer_sequence)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> block_;
  friend struct ::TableStruct_certifier_2eproto;
};
// -------------------------------------------------------------------

class run_request :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:run_request) */ {
 public:
  run_request();
  virtual ~run_request();

  run_request(const run_request& from);
  run_request(run_request&& from) noexcept
    : run_request() {
    *this = ::std::move(from);
  }

  inline run_request& operator=(const run_request& from) {
    CopyFrom(from);
    return *this;
  }
  inline run_request& operator=(run_request&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const run_request& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const run_request* internal_default_instance() {
    return reinterpret_cast<const run_request*>(
               &_run_request_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    40;

  friend void swap(run_request& a, run_request& b) {
    a.Swap(&b);
  }
  inline void Swap(run_request* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline run_request* New() const final {
    return CreateMaybeMessage<run_request>(nullptr);
  }

  run_request* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<run_request>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const run_request& from);
  void MergeFrom(const run_request& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(run_request* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "run_request";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_certifier_2eproto);
    return ::descriptor_table_certifier_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kArgsFieldNumber = 3,
    kLocationFieldNumber = 1,
    kCertFieldNumber = 2,
  };
  // repeated string args = 3;
  int args_size() const;
  private:
  int _internal_args_size() const;
  public:
  void clear_args();
  const std::string& args(int index) const;
  std::string* mutable_args(int index);
  void set_args(int index, const std::string& value);
  void set_args(int index, std::string&& value);
  void set_args(int index, const char* value);
  void set_args(int index, const char* value, size_t size);
  std::string* add_args();
  void add_args(const std::string& value);
  void add_args(std::string&& value);
  void add_args(const char* value);
  void add_args(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& args() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_args();
  private:
  const std::string& _internal_args(int index) const;
  std::string* _internal_add_args();
  public:

  // optional string location = 1;
  bool has_location() const;
  private:
  bool _internal_has_location() const;
  public:
  void clear_location();
  const std::string& location() const;
  void set_location(const std::string& value);
  void set_location(std::string&& value);
  void set_location(const char* value);
  void set_location(const char* value, size_t size);
  std::string* mutable_location();
  std::string* release_location();
  void set_allocated_location(std::string* location);
  private:
  const std::string& _internal_location() const;
  void _internal_set_location(const std::string& value);
  std::string* _internal_mutable_location();
  public:

  // optional bytes cert = 2;
  bool has_cert() const;
  private:
  bool _internal_has_cert() const;
  public:
  void clear_cert();
  const std::string& cert() const;
  void set_cert(const std::string& value);
  void set_cert(std::string&& value);
  void set_cert(const char* value);
  void set_cert(const void* value, size_t size);
  std::string* mutable_cert();
  std::string* release_cert();
  void set_allocated_cert(std::string* cert);
  private:
  const std::string& _internal_cert() const;
  void _internal_set_cert(const std::string& value);
  std::string* _internal_mutable_cert();
  public:

  // @@protoc_insertion_point(class_scope:run_request)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> args_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr location_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr cert_;
  friend struct ::TableStruct_certifier_2eproto;
};
// -------------------------------------------------------------------

class run_response :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:run_response) */ {
 public:
  run_response();
  virtual ~run_response();

  run_response(const run_response& from);
  run_response(run_response&& from) noexcept
    : run_response() {
    *this = ::std::move(from);
  }

  inline run_response& operator=(const run_response& from) {
    CopyFrom(from);
    return *this;
  }
  inline run_response& operator=(run_response&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const run_response& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const run_response* internal_default_instance() {
    return reinterpret_cast<const run_response*>(
               &_run_response_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    41;

  friend void swap(run_response& a, run_response& b) {
    a.Swap(&b);
  }
  inline void Swap(run_response* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline run_response* New() const final {
    return CreateMaybeMessage<run_response>(nullptr);
  }

  run_response* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<run_response>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const run_response& from);
  void MergeFrom(const run_response& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(run_response* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "run_response";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_certifier_2eproto);
    return ::descriptor_table_certifier_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kStatusFieldNumber = 1,
  };
  // optional string status = 1;
  bool has_status() const;
  private:
  bool _internal_has_status() const;
  public:
  void clear_status();
  const std::string& status() const;
  void set_status(const std::string& value);
  void set_status(std::string&& value);
  void set_status(const char* value);
  void set_status(const char* value, size_t size);
  std::string* mutable_status();
  std::string* release_status();
  void set_allocated_status(std::string* status);
  private:
  const std::string& _internal_status() const;
  void _internal_set_status(const std::string& value);
  std::string* _internal_mutable_status();
  public:

  // @@protoc_insertion_point(class_scope:run_response)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr status_;
  friend struct ::TableStruct_certifier_2eproto;
};
// -------------------------------------------------------------------

class app_request :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:app_request) */ {
 public:
  app_request();
  virtual ~app_request();

  app_request(const app_request& from);
  app_request(app_request&& from) noexcept
    : app_request() {
    *this = ::std::move(from);
  }

  inline app_request& operator=(const app_request& from) {
    CopyFrom(from);
    return *this;
  }
  inline app_request& operator=(app_request&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const app_request& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const app_request* internal_default_instance() {
    return reinterpret_cast<const app_request*>(
               &_app_request_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    42;

  friend void swap(app_request& a, app_request& b) {
    a.Swap(&b);
  }
  inline void Swap(app_request* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline app_request* New() const final {
    return CreateMaybeMessage<app_request>(nullptr);
  }

  app_request* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<app_request>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const app_request& from);
  void MergeFrom(const app_request& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(app_request* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "app_request";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_certifier_2eproto);
    return ::descriptor_table_certifier_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kArgsFieldNumber = 2,
    kFunctionFieldNumber = 1,
  };
  // repeated bytes args = 2;
  int args_size() const;
  private:
  int _internal_args_size() const;
  public:
  void clear_args();
  const std::string& args(int index) const;
  std::string* mutable_args(int index);
  void set_args(int index, const std::string& value);
  void set_args(int index, std::string&& value);
  void set_args(int index, const char* value);
  void set_args(int index, const void* value, size_t size);
  std::string* add_args();
  void add_args(const std::string& value);
  void add_args(std::string&& value);
  void add_args(const char* value);
  void add_args(const void* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& args() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_args();
  private:
  const std::string& _internal_args(int index) const;
  std::string* _internal_add_args();
  public:

  // optional string function = 1;
  bool has_function() const;
  private:
  bool _internal_has_function() const;
  public:
  void clear_function();
  const std::string& function() const;
  void set_function(const std::string& value);
  void set_function(std::string&& value);
  void set_function(const char* value);
  void set_function(const char* value, size_t size);
  std::string* mutable_function();
  std::string* release_function();
  void set_allocated_function(std::string* function);
  private:
  const std::string& _internal_function() const;
  void _internal_set_function(const std::string& value);
  std::string* _internal_mutable_function();
  public:

  // @@protoc_insertion_point(class_scope:app_request)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> args_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr function_;
  friend struct ::TableStruct_certifier_2eproto;
};
// -------------------------------------------------------------------

class app_response :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:app_response) */ {
 public:
  app_response();
  virtual ~app_response();

  app_response(const app_response& from);
  app_response(app_response&& from) noexcept
    : app_response() {
    *this = ::std::move(from);
  }

  inline app_response& operator=(const app_response& from) {
    CopyFrom(from);
    return *this;
  }
  inline app_response& operator=(app_response&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const app_response& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const app_response* internal_default_instance() {
    return reinterpret_cast<const app_response*>(
               &_app_response_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    43;

  friend void swap(app_response& a, app_response& b) {
    a.Swap(&b);
  }
  inline void Swap(app_response* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline app_response* New() const final {
    return CreateMaybeMessage<app_response>(nullptr);
  }

  app_response* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<app_response>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const app_response& from);
  void MergeFrom(const app_response& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(app_response* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "app_response";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_certifier_2eproto);
    return ::descriptor_table_certifier_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kArgsFieldNumber = 3,
    kFunctionFieldNumber = 1,
    kStatusFieldNumber = 2,
  };
  // repeated bytes args = 3;
  int args_size() const;
  private:
  int _internal_args_size() const;
  public:
  void clear_args();
  const std::string& args(int index) const;
  std::string* mutable_args(int index);
  void set_args(int index, const std::string& value);
  void set_args(int index, std::string&& value);
  void set_args(int index, const char* value);
  void set_args(int index, const void* value, size_t size);
  std::string* add_args();
  void add_args(const std::string& value);
  void add_args(std::string&& value);
  void add_args(const char* value);
  void add_args(const void* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& args() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_args();
  private:
  const std::string& _internal_args(int index) const;
  std::string* _internal_add_args();
  public:

  // optional string function = 1;
  bool has_function() const;
  private:
  bool _internal_has_function() const;
  public:
  void clear_function();
  const std::string& function() const;
  void set_function(const std::string& value);
  void set_function(std::string&& value);
  void set_function(const char* value);
  void set_function(const char* value, size_t size);
  std::string* mutable_function();
  std::string* release_function();
  void set_allocated_function(std::string* function);
  private:
  const std::string& _internal_function() const;
  void _internal_set_function(const std::string& value);
  std::string* _internal_mutable_function();
  public:

  // optional string status = 2;
  bool has_status() const;
  private:
  bool _internal_has_status() const;
  public:
  void clear_status();
  const std::string& status() const;
  void set_status(const std::string& value);
  void set_status(std::string&& value);
  void set_status(const char* value);
  void set_status(const char* value, size_t size);
  std::string* mutable_status();
  std::string* release_status();
  void set_allocated_status(std::string* status);
  private:
  const std::string& _internal_status() const;
  void _internal_set_status(const std::string& value);
  std::string* _internal_mutable_status();
  public:

  // @@protoc_insertion_point(class_scope:app_response)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> args_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr function_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr status_;
  friend struct ::TableStruct_certifier_2eproto;
};
// -------------------------------------------------------------------

class tagged_blob_message :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:tagged_blob_message) */ {
 public:
  tagged_blob_message();
  virtual ~tagged_blob_message();

  tagged_blob_message(const tagged_blob_message& from);
  tagged_blob_message(tagged_blob_message&& from) noexcept
    : tagged_blob_message() {
    *this = ::std::move(from);
  }

  inline tagged_blob_message& operator=(const tagged_blob_message& from) {
    CopyFrom(from);
    return *this;
  }
  inline tagged_blob_message& operator=(tagged_blob_message&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const tagged_blob_message& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const tagged_blob_message* internal_default_instance() {
    return reinterpret_cast<const tagged_blob_message*>(
               &_tagged_blob_message_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    44;

  friend void swap(tagged_blob_message& a, tagged_blob_message& b) {
    a.Swap(&b);
  }
  inline void Swap(tagged_blob_message* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline tagged_blob_message* New() const final {
    return CreateMaybeMessage<tagged_blob_message>(nullptr);
  }

  tagged_blob_message* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<tagged_blob_message>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const tagged_blob_message& from);
  void MergeFrom(const tagged_blob_message& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(tagged_blob_message* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "tagged_blob_message";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_certifier_2eproto);
    return ::descriptor_table_certifier_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTagFieldNumber = 1,
    kBFieldNumber = 2,
  };
  // optional string tag = 1;
  bool has_tag() const;
  private:
  bool _internal_has_tag() const;
  public:
  void clear_tag();
  const std::string& tag() const;
  void set_tag(const std::string& value);
  void set_tag(std::string&& value);
  void set_tag(const char* value);
  void set_tag(const char* value, size_t size);
  std::string* mutable_tag();
  std::string* release_tag();
  void set_allocated_tag(std::string* tag);
  private:
  const std::string& _internal_tag() const;
  void _internal_set_tag(const std::string& value);
  std::string* _internal_mutable_tag();
  public:

  // optional bytes b = 2;
  bool has_b() const;
  private:
  bool _internal_has_b() const;
  public:
  void clear_b();
  const std::string& b() const;
  void set_b(const std::string& value);
  void set_b(std::string&& value);
  void set_b(const char* value);
  void set_b(const void* value, size_t size);
  std::string* mutable_b();
  std::string* release_b();
  void set_allocated_b(std::string* b);
  private:
  const std::string& _internal_b() const;
  void _internal_set_b(const std::string& value);
  std::string* _internal_mutable_b();
  public:

  // @@protoc_insertion_point(class_scope:tagged_blob_message)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr tag_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr b_;
  friend struct ::TableStruct_certifier_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// time_point

// optional int32 year = 1;
inline bool time_point::_internal_has_year() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool time_point::has_year() const {
  return _internal_has_year();
}
inline void time_point::clear_year() {
  year_ = 0;
  _has_bits_[0] &= ~0x00000001u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 time_point::_internal_year() const {
  return year_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 time_point::year() const {
  // @@protoc_insertion_point(field_get:time_point.year)
  return _internal_year();
}
inline void time_point::_internal_set_year(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000001u;
  year_ = value;
}
inline void time_point::set_year(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_year(value);
  // @@protoc_insertion_point(field_set:time_point.year)
}

// optional int32 month = 2;
inline bool time_point::_internal_has_month() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool time_point::has_month() const {
  return _internal_has_month();
}
inline void time_point::clear_month() {
  month_ = 0;
  _has_bits_[0] &= ~0x00000002u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 time_point::_internal_month() const {
  return month_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 time_point::month() const {
  // @@protoc_insertion_point(field_get:time_point.month)
  return _internal_month();
}
inline void time_point::_internal_set_month(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000002u;
  month_ = value;
}
inline void time_point::set_month(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_month(value);
  // @@protoc_insertion_point(field_set:time_point.month)
}

// optional int32 day = 3;
inline bool time_point::_internal_has_day() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool time_point::has_day() const {
  return _internal_has_day();
}
inline void time_point::clear_day() {
  day_ = 0;
  _has_bits_[0] &= ~0x00000004u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 time_point::_internal_day() const {
  return day_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 time_point::day() const {
  // @@protoc_insertion_point(field_get:time_point.day)
  return _internal_day();
}
inline void time_point::_internal_set_day(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000004u;
  day_ = value;
}
inline void time_point::set_day(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_day(value);
  // @@protoc_insertion_point(field_set:time_point.day)
}

// optional int32 hour = 4;
inline bool time_point::_internal_has_hour() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool time_point::has_hour() const {
  return _internal_has_hour();
}
inline void time_point::clear_hour() {
  hour_ = 0;
  _has_bits_[0] &= ~0x00000008u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 time_point::_internal_hour() const {
  return hour_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 time_point::hour() const {
  // @@protoc_insertion_point(field_get:time_point.hour)
  return _internal_hour();
}
inline void time_point::_internal_set_hour(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000008u;
  hour_ = value;
}
inline void time_point::set_hour(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_hour(value);
  // @@protoc_insertion_point(field_set:time_point.hour)
}

// optional int32 minute = 5;
inline bool time_point::_internal_has_minute() const {
  bool value = (_has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool time_point::has_minute() const {
  return _internal_has_minute();
}
inline void time_point::clear_minute() {
  minute_ = 0;
  _has_bits_[0] &= ~0x00000020u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 time_point::_internal_minute() const {
  return minute_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 time_point::minute() const {
  // @@protoc_insertion_point(field_get:time_point.minute)
  return _internal_minute();
}
inline void time_point::_internal_set_minute(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000020u;
  minute_ = value;
}
inline void time_point::set_minute(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_minute(value);
  // @@protoc_insertion_point(field_set:time_point.minute)
}

// optional double seconds = 6;
inline bool time_point::_internal_has_seconds() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool time_point::has_seconds() const {
  return _internal_has_seconds();
}
inline void time_point::clear_seconds() {
  seconds_ = 0;
  _has_bits_[0] &= ~0x00000010u;
}
inline double time_point::_internal_seconds() const {
  return seconds_;
}
inline double time_point::seconds() const {
  // @@protoc_insertion_point(field_get:time_point.seconds)
  return _internal_seconds();
}
inline void time_point::_internal_set_seconds(double value) {
  _has_bits_[0] |= 0x00000010u;
  seconds_ = value;
}
inline void time_point::set_seconds(double value) {
  _internal_set_seconds(value);
  // @@protoc_insertion_point(field_set:time_point.seconds)
}

// -------------------------------------------------------------------

// rsa_message

// optional bytes public_modulus = 1;
inline bool rsa_message::_internal_has_public_modulus() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool rsa_message::has_public_modulus() const {
  return _internal_has_public_modulus();
}
inline void rsa_message::clear_public_modulus() {
  public_modulus_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& rsa_message::public_modulus() const {
  // @@protoc_insertion_point(field_get:rsa_message.public_modulus)
  return _internal_public_modulus();
}
inline void rsa_message::set_public_modulus(const std::string& value) {
  _internal_set_public_modulus(value);
  // @@protoc_insertion_point(field_set:rsa_message.public_modulus)
}
inline std::string* rsa_message::mutable_public_modulus() {
  // @@protoc_insertion_point(field_mutable:rsa_message.public_modulus)
  return _internal_mutable_public_modulus();
}
inline const std::string& rsa_message::_internal_public_modulus() const {
  return public_modulus_.GetNoArena();
}
inline void rsa_message::_internal_set_public_modulus(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  public_modulus_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
}
inline void rsa_message::set_public_modulus(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  public_modulus_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:rsa_message.public_modulus)
}
inline void rsa_message::set_public_modulus(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  public_modulus_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:rsa_message.public_modulus)
}
inline void rsa_message::set_public_modulus(const void* value, size_t size) {
  _has_bits_[0] |= 0x00000001u;
  public_modulus_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:rsa_message.public_modulus)
}
inline std::string* rsa_message::_internal_mutable_public_modulus() {
  _has_bits_[0] |= 0x00000001u;
  return public_modulus_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* rsa_message::release_public_modulus() {
  // @@protoc_insertion_point(field_release:rsa_message.public_modulus)
  if (!_internal_has_public_modulus()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return public_modulus_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void rsa_message::set_allocated_public_modulus(std::string* public_modulus) {
  if (public_modulus != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  public_modulus_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), public_modulus);
  // @@protoc_insertion_point(field_set_allocated:rsa_message.public_modulus)
}

// optional bytes public_exponent = 2;
inline bool rsa_message::_internal_has_public_exponent() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool rsa_message::has_public_exponent() const {
  return _internal_has_public_exponent();
}
inline void rsa_message::clear_public_exponent() {
  public_exponent_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& rsa_message::public_exponent() const {
  // @@protoc_insertion_point(field_get:rsa_message.public_exponent)
  return _internal_public_exponent();
}
inline void rsa_message::set_public_exponent(const std::string& value) {
  _internal_set_public_exponent(value);
  // @@protoc_insertion_point(field_set:rsa_message.public_exponent)
}
inline std::string* rsa_message::mutable_public_exponent() {
  // @@protoc_insertion_point(field_mutable:rsa_message.public_exponent)
  return _internal_mutable_public_exponent();
}
inline const std::string& rsa_message::_internal_public_exponent() const {
  return public_exponent_.GetNoArena();
}
inline void rsa_message::_internal_set_public_exponent(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  public_exponent_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
}
inline void rsa_message::set_public_exponent(std::string&& value) {
  _has_bits_[0] |= 0x00000002u;
  public_exponent_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:rsa_message.public_exponent)
}
inline void rsa_message::set_public_exponent(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000002u;
  public_exponent_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:rsa_message.public_exponent)
}
inline void rsa_message::set_public_exponent(const void* value, size_t size) {
  _has_bits_[0] |= 0x00000002u;
  public_exponent_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:rsa_message.public_exponent)
}
inline std::string* rsa_message::_internal_mutable_public_exponent() {
  _has_bits_[0] |= 0x00000002u;
  return public_exponent_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* rsa_message::release_public_exponent() {
  // @@protoc_insertion_point(field_release:rsa_message.public_exponent)
  if (!_internal_has_public_exponent()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  return public_exponent_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void rsa_message::set_allocated_public_exponent(std::string* public_exponent) {
  if (public_exponent != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  public_exponent_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), public_exponent);
  // @@protoc_insertion_point(field_set_allocated:rsa_message.public_exponent)
}

// optional bytes private_exponent = 3;
inline bool rsa_message::_internal_has_private_exponent() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool rsa_message::has_private_exponent() const {
  return _internal_has_private_exponent();
}
inline void rsa_message::clear_private_exponent() {
  private_exponent_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000004u;
}
inline const std::string& rsa_message::private_exponent() const {
  // @@protoc_insertion_point(field_get:rsa_message.private_exponent)
  return _internal_private_exponent();
}
inline void rsa_message::set_private_exponent(const std::string& value) {
  _internal_set_private_exponent(value);
  // @@protoc_insertion_point(field_set:rsa_message.private_exponent)
}
inline std::string* rsa_message::mutable_private_exponent() {
  // @@protoc_insertion_point(field_mutable:rsa_message.private_exponent)
  return _internal_mutable_private_exponent();
}
inline const std::string& rsa_message::_internal_private_exponent() const {
  return private_exponent_.GetNoArena();
}
inline void rsa_message::_internal_set_private_exponent(const std::string& value) {
  _has_bits_[0] |= 0x00000004u;
  private_exponent_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
}
inline void rsa_message::set_private_exponent(std::string&& value) {
  _has_bits_[0] |= 0x00000004u;
  private_exponent_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:rsa_message.private_exponent)
}
inline void rsa_message::set_private_exponent(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000004u;
  private_exponent_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:rsa_message.private_exponent)
}
inline void rsa_message::set_private_exponent(const void* value, size_t size) {
  _has_bits_[0] |= 0x00000004u;
  private_exponent_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:rsa_message.private_exponent)
}
inline std::string* rsa_message::_internal_mutable_private_exponent() {
  _has_bits_[0] |= 0x00000004u;
  return private_exponent_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* rsa_message::release_private_exponent() {
  // @@protoc_insertion_point(field_release:rsa_message.private_exponent)
  if (!_internal_has_private_exponent()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000004u;
  return private_exponent_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void rsa_message::set_allocated_private_exponent(std::string* private_exponent) {
  if (private_exponent != nullptr) {
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  private_exponent_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), private_exponent);
  // @@protoc_insertion_point(field_set_allocated:rsa_message.private_exponent)
}

// optional bytes private_p = 4;
inline bool rsa_message::_internal_has_private_p() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool rsa_message::has_private_p() const {
  return _internal_has_private_p();
}
inline void rsa_message::clear_private_p() {
  private_p_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000008u;
}
inline const std::string& rsa_message::private_p() const {
  // @@protoc_insertion_point(field_get:rsa_message.private_p)
  return _internal_private_p();
}
inline void rsa_message::set_private_p(const std::string& value) {
  _internal_set_private_p(value);
  // @@protoc_insertion_point(field_set:rsa_message.private_p)
}
inline std::string* rsa_message::mutable_private_p() {
  // @@protoc_insertion_point(field_mutable:rsa_message.private_p)
  return _internal_mutable_private_p();
}
inline const std::string& rsa_message::_internal_private_p() const {
  return private_p_.GetNoArena();
}
inline void rsa_message::_internal_set_private_p(const std::string& value) {
  _has_bits_[0] |= 0x00000008u;
  private_p_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
}
inline void rsa_message::set_private_p(std::string&& value) {
  _has_bits_[0] |= 0x00000008u;
  private_p_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:rsa_message.private_p)
}
inline void rsa_message::set_private_p(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000008u;
  private_p_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:rsa_message.private_p)
}
inline void rsa_message::set_private_p(const void* value, size_t size) {
  _has_bits_[0] |= 0x00000008u;
  private_p_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:rsa_message.private_p)
}
inline std::string* rsa_message::_internal_mutable_private_p() {
  _has_bits_[0] |= 0x00000008u;
  return private_p_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* rsa_message::release_private_p() {
  // @@protoc_insertion_point(field_release:rsa_message.private_p)
  if (!_internal_has_private_p()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000008u;
  return private_p_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void rsa_message::set_allocated_private_p(std::string* private_p) {
  if (private_p != nullptr) {
    _has_bits_[0] |= 0x00000008u;
  } else {
    _has_bits_[0] &= ~0x00000008u;
  }
  private_p_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), private_p);
  // @@protoc_insertion_point(field_set_allocated:rsa_message.private_p)
}

// optional bytes private_q = 5;
inline bool rsa_message::_internal_has_private_q() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool rsa_message::has_private_q() const {
  return _internal_has_private_q();
}
inline void rsa_message::clear_private_q() {
  private_q_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000010u;
}
inline const std::string& rsa_message::private_q() const {
  // @@protoc_insertion_point(field_get:rsa_message.private_q)
  return _internal_private_q();
}
inline void rsa_message::set_private_q(const std::string& value) {
  _internal_set_private_q(value);
  // @@protoc_insertion_point(field_set:rsa_message.private_q)
}
inline std::string* rsa_message::mutable_private_q() {
  // @@protoc_insertion_point(field_mutable:rsa_message.private_q)
  return _internal_mutable_private_q();
}
inline const std::string& rsa_message::_internal_private_q() const {
  return private_q_.GetNoArena();
}
inline void rsa_message::_internal_set_private_q(const std::string& value) {
  _has_bits_[0] |= 0x00000010u;
  private_q_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
}
inline void rsa_message::set_private_q(std::string&& value) {
  _has_bits_[0] |= 0x00000010u;
  private_q_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:rsa_message.private_q)
}
inline void rsa_message::set_private_q(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000010u;
  private_q_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:rsa_message.private_q)
}
inline void rsa_message::set_private_q(const void* value, size_t size) {
  _has_bits_[0] |= 0x00000010u;
  private_q_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:rsa_message.private_q)
}
inline std::string* rsa_message::_internal_mutable_private_q() {
  _has_bits_[0] |= 0x00000010u;
  return private_q_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* rsa_message::release_private_q() {
  // @@protoc_insertion_point(field_release:rsa_message.private_q)
  if (!_internal_has_private_q()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000010u;
  return private_q_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void rsa_message::set_allocated_private_q(std::string* private_q) {
  if (private_q != nullptr) {
    _has_bits_[0] |= 0x00000010u;
  } else {
    _has_bits_[0] &= ~0x00000010u;
  }
  private_q_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), private_q);
  // @@protoc_insertion_point(field_set_allocated:rsa_message.private_q)
}

// optional bytes private_dp = 6;
inline bool rsa_message::_internal_has_private_dp() const {
  bool value = (_has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool rsa_message::has_private_dp() const {
  return _internal_has_private_dp();
}
inline void rsa_message::clear_private_dp() {
  private_dp_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000020u;
}
inline const std::string& rsa_message::private_dp() const {
  // @@protoc_insertion_point(field_get:rsa_message.private_dp)
  return _internal_private_dp();
}
inline void rsa_message::set_private_dp(const std::string& value) {
  _internal_set_private_dp(value);
  // @@protoc_insertion_point(field_set:rsa_message.private_dp)
}
inline std::string* rsa_message::mutable_private_dp() {
  // @@protoc_insertion_point(field_mutable:rsa_message.private_dp)
  return _internal_mutable_private_dp();
}
inline const std::string& rsa_message::_internal_private_dp() const {
  return private_dp_.GetNoArena();
}
inline void rsa_message::_internal_set_private_dp(const std::string& value) {
  _has_bits_[0] |= 0x00000020u;
  private_dp_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
}
inline void rsa_message::set_private_dp(std::string&& value) {
  _has_bits_[0] |= 0x00000020u;
  private_dp_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:rsa_message.private_dp)
}
inline void rsa_message::set_private_dp(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000020u;
  private_dp_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:rsa_message.private_dp)
}
inline void rsa_message::set_private_dp(const void* value, size_t size) {
  _has_bits_[0] |= 0x00000020u;
  private_dp_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:rsa_message.private_dp)
}
inline std::string* rsa_message::_internal_mutable_private_dp() {
  _has_bits_[0] |= 0x00000020u;
  return private_dp_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* rsa_message::release_private_dp() {
  // @@protoc_insertion_point(field_release:rsa_message.private_dp)
  if (!_internal_has_private_dp()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000020u;
  return private_dp_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void rsa_message::set_allocated_private_dp(std::string* private_dp) {
  if (private_dp != nullptr) {
    _has_bits_[0] |= 0x00000020u;
  } else {
    _has_bits_[0] &= ~0x00000020u;
  }
  private_dp_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), private_dp);
  // @@protoc_insertion_point(field_set_allocated:rsa_message.private_dp)
}

// optional bytes private_dq = 7;
inline bool rsa_message::_internal_has_private_dq() const {
  bool value = (_has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline bool rsa_message::has_private_dq() const {
  return _internal_has_private_dq();
}
inline void rsa_message::clear_private_dq() {
  private_dq_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000040u;
}
inline const std::string& rsa_message::private_dq() const {
  // @@protoc_insertion_point(field_get:rsa_message.private_dq)
  return _internal_private_dq();
}
inline void rsa_message::set_private_dq(const std::string& value) {
  _internal_set_private_dq(value);
  // @@protoc_insertion_point(field_set:rsa_message.private_dq)
}
inline std::string* rsa_message::mutable_private_dq() {
  // @@protoc_insertion_point(field_mutable:rsa_message.private_dq)
  return _internal_mutable_private_dq();
}
inline const std::string& rsa_message::_internal_private_dq() const {
  return private_dq_.GetNoArena();
}
inline void rsa_message::_internal_set_private_dq(const std::string& value) {
  _has_bits_[0] |= 0x00000040u;
  private_dq_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
}
inline void rsa_message::set_private_dq(std::string&& value) {
  _has_bits_[0] |= 0x00000040u;
  private_dq_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:rsa_message.private_dq)
}
inline void rsa_message::set_private_dq(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000040u;
  private_dq_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:rsa_message.private_dq)
}
inline void rsa_message::set_private_dq(const void* value, size_t size) {
  _has_bits_[0] |= 0x00000040u;
  private_dq_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:rsa_message.private_dq)
}
inline std::string* rsa_message::_internal_mutable_private_dq() {
  _has_bits_[0] |= 0x00000040u;
  return private_dq_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* rsa_message::release_private_dq() {
  // @@protoc_insertion_point(field_release:rsa_message.private_dq)
  if (!_internal_has_private_dq()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000040u;
  return private_dq_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void rsa_message::set_allocated_private_dq(std::string* private_dq) {
  if (private_dq != nullptr) {
    _has_bits_[0] |= 0x00000040u;
  } else {
    _has_bits_[0] &= ~0x00000040u;
  }
  private_dq_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), private_dq);
  // @@protoc_insertion_point(field_set_allocated:rsa_message.private_dq)
}

// optional bytes private_iqmp = 8;
inline bool rsa_message::_internal_has_private_iqmp() const {
  bool value = (_has_bits_[0] & 0x00000080u) != 0;
  return value;
}
inline bool rsa_message::has_private_iqmp() const {
  return _internal_has_private_iqmp();
}
inline void rsa_message::clear_private_iqmp() {
  private_iqmp_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000080u;
}
inline const std::string& rsa_message::private_iqmp() const {
  // @@protoc_insertion_point(field_get:rsa_message.private_iqmp)
  return _internal_private_iqmp();
}
inline void rsa_message::set_private_iqmp(const std::string& value) {
  _internal_set_private_iqmp(value);
  // @@protoc_insertion_point(field_set:rsa_message.private_iqmp)
}
inline std::string* rsa_message::mutable_private_iqmp() {
  // @@protoc_insertion_point(field_mutable:rsa_message.private_iqmp)
  return _internal_mutable_private_iqmp();
}
inline const std::string& rsa_message::_internal_private_iqmp() const {
  return private_iqmp_.GetNoArena();
}
inline void rsa_message::_internal_set_private_iqmp(const std::string& value) {
  _has_bits_[0] |= 0x00000080u;
  private_iqmp_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
}
inline void rsa_message::set_private_iqmp(std::string&& value) {
  _has_bits_[0] |= 0x00000080u;
  private_iqmp_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:rsa_message.private_iqmp)
}
inline void rsa_message::set_private_iqmp(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000080u;
  private_iqmp_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:rsa_message.private_iqmp)
}
inline void rsa_message::set_private_iqmp(const void* value, size_t size) {
  _has_bits_[0] |= 0x00000080u;
  private_iqmp_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:rsa_message.private_iqmp)
}
inline std::string* rsa_message::_internal_mutable_private_iqmp() {
  _has_bits_[0] |= 0x00000080u;
  return private_iqmp_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* rsa_message::release_private_iqmp() {
  // @@protoc_insertion_point(field_release:rsa_message.private_iqmp)
  if (!_internal_has_private_iqmp()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000080u;
  return private_iqmp_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void rsa_message::set_allocated_private_iqmp(std::string* private_iqmp) {
  if (private_iqmp != nullptr) {
    _has_bits_[0] |= 0x00000080u;
  } else {
    _has_bits_[0] &= ~0x00000080u;
  }
  private_iqmp_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), private_iqmp);
  // @@protoc_insertion_point(field_set_allocated:rsa_message.private_iqmp)
}

// -------------------------------------------------------------------

// point_message

// optional bytes x = 1;
inline bool point_message::_internal_has_x() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool point_message::has_x() const {
  return _internal_has_x();
}
inline void point_message::clear_x() {
  x_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& point_message::x() const {
  // @@protoc_insertion_point(field_get:point_message.x)
  return _internal_x();
}
inline void point_message::set_x(const std::string& value) {
  _internal_set_x(value);
  // @@protoc_insertion_point(field_set:point_message.x)
}
inline std::string* point_message::mutable_x() {
  // @@protoc_insertion_point(field_mutable:point_message.x)
  return _internal_mutable_x();
}
inline const std::string& point_message::_internal_x() const {
  return x_.GetNoArena();
}
inline void point_message::_internal_set_x(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  x_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
}
inline void point_message::set_x(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  x_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:point_message.x)
}
inline void point_message::set_x(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  x_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:point_message.x)
}
inline void point_message::set_x(const void* value, size_t size) {
  _has_bits_[0] |= 0x00000001u;
  x_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:point_message.x)
}
inline std::string* point_message::_internal_mutable_x() {
  _has_bits_[0] |= 0x00000001u;
  return x_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* point_message::release_x() {
  // @@protoc_insertion_point(field_release:point_message.x)
  if (!_internal_has_x()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return x_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void point_message::set_allocated_x(std::string* x) {
  if (x != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  x_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), x);
  // @@protoc_insertion_point(field_set_allocated:point_message.x)
}

// optional bytes y = 2;
inline bool point_message::_internal_has_y() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool point_message::has_y() const {
  return _internal_has_y();
}
inline void point_message::clear_y() {
  y_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& point_message::y() const {
  // @@protoc_insertion_point(field_get:point_message.y)
  return _internal_y();
}
inline void point_message::set_y(const std::string& value) {
  _internal_set_y(value);
  // @@protoc_insertion_point(field_set:point_message.y)
}
inline std::string* point_message::mutable_y() {
  // @@protoc_insertion_point(field_mutable:point_message.y)
  return _internal_mutable_y();
}
inline const std::string& point_message::_internal_y() const {
  return y_.GetNoArena();
}
inline void point_message::_internal_set_y(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  y_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
}
inline void point_message::set_y(std::string&& value) {
  _has_bits_[0] |= 0x00000002u;
  y_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:point_message.y)
}
inline void point_message::set_y(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000002u;
  y_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:point_message.y)
}
inline void point_message::set_y(const void* value, size_t size) {
  _has_bits_[0] |= 0x00000002u;
  y_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:point_message.y)
}
inline std::string* point_message::_internal_mutable_y() {
  _has_bits_[0] |= 0x00000002u;
  return y_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* point_message::release_y() {
  // @@protoc_insertion_point(field_release:point_message.y)
  if (!_internal_has_y()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  return y_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void point_message::set_allocated_y(std::string* y) {
  if (y != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  y_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), y);
  // @@protoc_insertion_point(field_set_allocated:point_message.y)
}

// -------------------------------------------------------------------

// ecc_message

// optional string curve_name = 1;
inline bool ecc_message::_internal_has_curve_name() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool ecc_message::has_curve_name() const {
  return _internal_has_curve_name();
}
inline void ecc_message::clear_curve_name() {
  curve_name_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& ecc_message::curve_name() const {
  // @@protoc_insertion_point(field_get:ecc_message.curve_name)
  return _internal_curve_name();
}
inline void ecc_message::set_curve_name(const std::string& value) {
  _internal_set_curve_name(value);
  // @@protoc_insertion_point(field_set:ecc_message.curve_name)
}
inline std::string* ecc_message::mutable_curve_name() {
  // @@protoc_insertion_point(field_mutable:ecc_message.curve_name)
  return _internal_mutable_curve_name();
}
inline const std::string& ecc_message::_internal_curve_name() const {
  return curve_name_.GetNoArena();
}
inline void ecc_message::_internal_set_curve_name(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  curve_name_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
}
inline void ecc_message::set_curve_name(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  curve_name_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:ecc_message.curve_name)
}
inline void ecc_message::set_curve_name(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  curve_name_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:ecc_message.curve_name)
}
inline void ecc_message::set_curve_name(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000001u;
  curve_name_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:ecc_message.curve_name)
}
inline std::string* ecc_message::_internal_mutable_curve_name() {
  _has_bits_[0] |= 0x00000001u;
  return curve_name_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* ecc_message::release_curve_name() {
  // @@protoc_insertion_point(field_release:ecc_message.curve_name)
  if (!_internal_has_curve_name()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return curve_name_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void ecc_message::set_allocated_curve_name(std::string* curve_name) {
  if (curve_name != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  curve_name_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), curve_name);
  // @@protoc_insertion_point(field_set_allocated:ecc_message.curve_name)
}

// optional bytes curve_p = 2;
inline bool ecc_message::_internal_has_curve_p() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool ecc_message::has_curve_p() const {
  return _internal_has_curve_p();
}
inline void ecc_message::clear_curve_p() {
  curve_p_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& ecc_message::curve_p() const {
  // @@protoc_insertion_point(field_get:ecc_message.curve_p)
  return _internal_curve_p();
}
inline void ecc_message::set_curve_p(const std::string& value) {
  _internal_set_curve_p(value);
  // @@protoc_insertion_point(field_set:ecc_message.curve_p)
}
inline std::string* ecc_message::mutable_curve_p() {
  // @@protoc_insertion_point(field_mutable:ecc_message.curve_p)
  return _internal_mutable_curve_p();
}
inline const std::string& ecc_message::_internal_curve_p() const {
  return curve_p_.GetNoArena();
}
inline void ecc_message::_internal_set_curve_p(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  curve_p_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
}
inline void ecc_message::set_curve_p(std::string&& value) {
  _has_bits_[0] |= 0x00000002u;
  curve_p_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:ecc_message.curve_p)
}
inline void ecc_message::set_curve_p(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000002u;
  curve_p_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:ecc_message.curve_p)
}
inline void ecc_message::set_curve_p(const void* value, size_t size) {
  _has_bits_[0] |= 0x00000002u;
  curve_p_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:ecc_message.curve_p)
}
inline std::string* ecc_message::_internal_mutable_curve_p() {
  _has_bits_[0] |= 0x00000002u;
  return curve_p_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* ecc_message::release_curve_p() {
  // @@protoc_insertion_point(field_release:ecc_message.curve_p)
  if (!_internal_has_curve_p()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  return curve_p_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void ecc_message::set_allocated_curve_p(std::string* curve_p) {
  if (curve_p != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  curve_p_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), curve_p);
  // @@protoc_insertion_point(field_set_allocated:ecc_message.curve_p)
}

// optional bytes curve_a = 3;
inline bool ecc_message::_internal_has_curve_a() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool ecc_message::has_curve_a() const {
  return _internal_has_curve_a();
}
inline void ecc_message::clear_curve_a() {
  curve_a_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000004u;
}
inline const std::string& ecc_message::curve_a() const {
  // @@protoc_insertion_point(field_get:ecc_message.curve_a)
  return _internal_curve_a();
}
inline void ecc_message::set_curve_a(const std::string& value) {
  _internal_set_curve_a(value);
  // @@protoc_insertion_point(field_set:ecc_message.curve_a)
}
inline std::string* ecc_message::mutable_curve_a() {
  // @@protoc_insertion_point(field_mutable:ecc_message.curve_a)
  return _internal_mutable_curve_a();
}
inline const std::string& ecc_message::_internal_curve_a() const {
  return curve_a_.GetNoArena();
}
inline void ecc_message::_internal_set_curve_a(const std::string& value) {
  _has_bits_[0] |= 0x00000004u;
  curve_a_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
}
inline void ecc_message::set_curve_a(std::string&& value) {
  _has_bits_[0] |= 0x00000004u;
  curve_a_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:ecc_message.curve_a)
}
inline void ecc_message::set_curve_a(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000004u;
  curve_a_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:ecc_message.curve_a)
}
inline void ecc_message::set_curve_a(const void* value, size_t size) {
  _has_bits_[0] |= 0x00000004u;
  curve_a_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:ecc_message.curve_a)
}
inline std::string* ecc_message::_internal_mutable_curve_a() {
  _has_bits_[0] |= 0x00000004u;
  return curve_a_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* ecc_message::release_curve_a() {
  // @@protoc_insertion_point(field_release:ecc_message.curve_a)
  if (!_internal_has_curve_a()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000004u;
  return curve_a_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void ecc_message::set_allocated_curve_a(std::string* curve_a) {
  if (curve_a != nullptr) {
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  curve_a_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), curve_a);
  // @@protoc_insertion_point(field_set_allocated:ecc_message.curve_a)
}

// optional bytes curve_b = 4;
inline bool ecc_message::_internal_has_curve_b() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool ecc_message::has_curve_b() const {
  return _internal_has_curve_b();
}
inline void ecc_message::clear_curve_b() {
  curve_b_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000008u;
}
inline const std::string& ecc_message::curve_b() const {
  // @@protoc_insertion_point(field_get:ecc_message.curve_b)
  return _internal_curve_b();
}
inline void ecc_message::set_curve_b(const std::string& value) {
  _internal_set_curve_b(value);
  // @@protoc_insertion_point(field_set:ecc_message.curve_b)
}
inline std::string* ecc_message::mutable_curve_b() {
  // @@protoc_insertion_point(field_mutable:ecc_message.curve_b)
  return _internal_mutable_curve_b();
}
inline const std::string& ecc_message::_internal_curve_b() const {
  return curve_b_.GetNoArena();
}
inline void ecc_message::_internal_set_curve_b(const std::string& value) {
  _has_bits_[0] |= 0x00000008u;
  curve_b_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
}
inline void ecc_message::set_curve_b(std::string&& value) {
  _has_bits_[0] |= 0x00000008u;
  curve_b_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:ecc_message.curve_b)
}
inline void ecc_message::set_curve_b(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000008u;
  curve_b_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:ecc_message.curve_b)
}
inline void ecc_message::set_curve_b(const void* value, size_t size) {
  _has_bits_[0] |= 0x00000008u;
  curve_b_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:ecc_message.curve_b)
}
inline std::string* ecc_message::_internal_mutable_curve_b() {
  _has_bits_[0] |= 0x00000008u;
  return curve_b_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* ecc_message::release_curve_b() {
  // @@protoc_insertion_point(field_release:ecc_message.curve_b)
  if (!_internal_has_curve_b()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000008u;
  return curve_b_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void ecc_message::set_allocated_curve_b(std::string* curve_b) {
  if (curve_b != nullptr) {
    _has_bits_[0] |= 0x00000008u;
  } else {
    _has_bits_[0] &= ~0x00000008u;
  }
  curve_b_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), curve_b);
  // @@protoc_insertion_point(field_set_allocated:ecc_message.curve_b)
}

// optional .point_message base_point = 5;
inline bool ecc_message::_internal_has_base_point() const {
  bool value = (_has_bits_[0] & 0x00000040u) != 0;
  PROTOBUF_ASSUME(!value || base_point_ != nullptr);
  return value;
}
inline bool ecc_message::has_base_point() const {
  return _internal_has_base_point();
}
inline void ecc_message::clear_base_point() {
  if (base_point_ != nullptr) base_point_->Clear();
  _has_bits_[0] &= ~0x00000040u;
}
inline const ::point_message& ecc_message::_internal_base_point() const {
  const ::point_message* p = base_point_;
  return p != nullptr ? *p : *reinterpret_cast<const ::point_message*>(
      &::_point_message_default_instance_);
}
inline const ::point_message& ecc_message::base_point() const {
  // @@protoc_insertion_point(field_get:ecc_message.base_point)
  return _internal_base_point();
}
inline ::point_message* ecc_message::release_base_point() {
  // @@protoc_insertion_point(field_release:ecc_message.base_point)
  _has_bits_[0] &= ~0x00000040u;
  ::point_message* temp = base_point_;
  base_point_ = nullptr;
  return temp;
}
inline ::point_message* ecc_message::_internal_mutable_base_point() {
  _has_bits_[0] |= 0x00000040u;
  if (base_point_ == nullptr) {
    auto* p = CreateMaybeMessage<::point_message>(GetArenaNoVirtual());
    base_point_ = p;
  }
  return base_point_;
}
inline ::point_message* ecc_message::mutable_base_point() {
  // @@protoc_insertion_point(field_mutable:ecc_message.base_point)
  return _internal_mutable_base_point();
}
inline void ecc_message::set_allocated_base_point(::point_message* base_point) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete base_point_;
  }
  if (base_point) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      base_point = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, base_point, submessage_arena);
    }
    _has_bits_[0] |= 0x00000040u;
  } else {
    _has_bits_[0] &= ~0x00000040u;
  }
  base_point_ = base_point;
  // @@protoc_insertion_point(field_set_allocated:ecc_message.base_point)
}

// optional .point_message public_point = 6;
inline bool ecc_message::_internal_has_public_point() const {
  bool value = (_has_bits_[0] & 0x00000080u) != 0;
  PROTOBUF_ASSUME(!value || public_point_ != nullptr);
  return value;
}
inline bool ecc_message::has_public_point() const {
  return _internal_has_public_point();
}
inline void ecc_message::clear_public_point() {
  if (public_point_ != nullptr) public_point_->Clear();
  _has_bits_[0] &= ~0x00000080u;
}
inline const ::point_message& ecc_message::_internal_public_point() const {
  const ::point_message* p = public_point_;
  return p != nullptr ? *p : *reinterpret_cast<const ::point_message*>(
      &::_point_message_default_instance_);
}
inline const ::point_message& ecc_message::public_point() const {
  // @@protoc_insertion_point(field_get:ecc_message.public_point)
  return _internal_public_point();
}
inline ::point_message* ecc_message::release_public_point() {
  // @@protoc_insertion_point(field_release:ecc_message.public_point)
  _has_bits_[0] &= ~0x00000080u;
  ::point_message* temp = public_point_;
  public_point_ = nullptr;
  return temp;
}
inline ::point_message* ecc_message::_internal_mutable_public_point() {
  _has_bits_[0] |= 0x00000080u;
  if (public_point_ == nullptr) {
    auto* p = CreateMaybeMessage<::point_message>(GetArenaNoVirtual());
    public_point_ = p;
  }
  return public_point_;
}
inline ::point_message* ecc_message::mutable_public_point() {
  // @@protoc_insertion_point(field_mutable:ecc_message.public_point)
  return _internal_mutable_public_point();
}
inline void ecc_message::set_allocated_public_point(::point_message* public_point) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete public_point_;
  }
  if (public_point) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      public_point = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, public_point, submessage_arena);
    }
    _has_bits_[0] |= 0x00000080u;
  } else {
    _has_bits_[0] &= ~0x00000080u;
  }
  public_point_ = public_point;
  // @@protoc_insertion_point(field_set_allocated:ecc_message.public_point)
}

// optional bytes order_of_base_point = 7;
inline bool ecc_message::_internal_has_order_of_base_point() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool ecc_message::has_order_of_base_point() const {
  return _internal_has_order_of_base_point();
}
inline void ecc_message::clear_order_of_base_point() {
  order_of_base_point_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000010u;
}
inline const std::string& ecc_message::order_of_base_point() const {
  // @@protoc_insertion_point(field_get:ecc_message.order_of_base_point)
  return _internal_order_of_base_point();
}
inline void ecc_message::set_order_of_base_point(const std::string& value) {
  _internal_set_order_of_base_point(value);
  // @@protoc_insertion_point(field_set:ecc_message.order_of_base_point)
}
inline std::string* ecc_message::mutable_order_of_base_point() {
  // @@protoc_insertion_point(field_mutable:ecc_message.order_of_base_point)
  return _internal_mutable_order_of_base_point();
}
inline const std::string& ecc_message::_internal_order_of_base_point() const {
  return order_of_base_point_.GetNoArena();
}
inline void ecc_message::_internal_set_order_of_base_point(const std::string& value) {
  _has_bits_[0] |= 0x00000010u;
  order_of_base_point_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
}
inline void ecc_message::set_order_of_base_point(std::string&& value) {
  _has_bits_[0] |= 0x00000010u;
  order_of_base_point_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:ecc_message.order_of_base_point)
}
inline void ecc_message::set_order_of_base_point(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000010u;
  order_of_base_point_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:ecc_message.order_of_base_point)
}
inline void ecc_message::set_order_of_base_point(const void* value, size_t size) {
  _has_bits_[0] |= 0x00000010u;
  order_of_base_point_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:ecc_message.order_of_base_point)
}
inline std::string* ecc_message::_internal_mutable_order_of_base_point() {
  _has_bits_[0] |= 0x00000010u;
  return order_of_base_point_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* ecc_message::release_order_of_base_point() {
  // @@protoc_insertion_point(field_release:ecc_message.order_of_base_point)
  if (!_internal_has_order_of_base_point()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000010u;
  return order_of_base_point_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void ecc_message::set_allocated_order_of_base_point(std::string* order_of_base_point) {
  if (order_of_base_point != nullptr) {
    _has_bits_[0] |= 0x00000010u;
  } else {
    _has_bits_[0] &= ~0x00000010u;
  }
  order_of_base_point_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), order_of_base_point);
  // @@protoc_insertion_point(field_set_allocated:ecc_message.order_of_base_point)
}

// optional bytes private_multiplier = 8;
inline bool ecc_message::_internal_has_private_multiplier() const {
  bool value = (_has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool ecc_message::has_private_multiplier() const {
  return _internal_has_private_multiplier();
}
inline void ecc_message::clear_private_multiplier() {
  private_multiplier_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000020u;
}
inline const std::string& ecc_message::private_multiplier() const {
  // @@protoc_insertion_point(field_get:ecc_message.private_multiplier)
  return _internal_private_multiplier();
}
inline void ecc_message::set_private_multiplier(const std::string& value) {
  _internal_set_private_multiplier(value);
  // @@protoc_insertion_point(field_set:ecc_message.private_multiplier)
}
inline std::string* ecc_message::mutable_private_multiplier() {
  // @@protoc_insertion_point(field_mutable:ecc_message.private_multiplier)
  return _internal_mutable_private_multiplier();
}
inline const std::string& ecc_message::_internal_private_multiplier() const {
  return private_multiplier_.GetNoArena();
}
inline void ecc_message::_internal_set_private_multiplier(const std::string& value) {
  _has_bits_[0] |= 0x00000020u;
  private_multiplier_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
}
inline void ecc_message::set_private_multiplier(std::string&& value) {
  _has_bits_[0] |= 0x00000020u;
  private_multiplier_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:ecc_message.private_multiplier)
}
inline void ecc_message::set_private_multiplier(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000020u;
  private_multiplier_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:ecc_message.private_multiplier)
}
inline void ecc_message::set_private_multiplier(const void* value, size_t size) {
  _has_bits_[0] |= 0x00000020u;
  private_multiplier_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:ecc_message.private_multiplier)
}
inline std::string* ecc_message::_internal_mutable_private_multiplier() {
  _has_bits_[0] |= 0x00000020u;
  return private_multiplier_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* ecc_message::release_private_multiplier() {
  // @@protoc_insertion_point(field_release:ecc_message.private_multiplier)
  if (!_internal_has_private_multiplier()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000020u;
  return private_multiplier_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void ecc_message::set_allocated_private_multiplier(std::string* private_multiplier) {
  if (private_multiplier != nullptr) {
    _has_bits_[0] |= 0x00000020u;
  } else {
    _has_bits_[0] &= ~0x00000020u;
  }
  private_multiplier_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), private_multiplier);
  // @@protoc_insertion_point(field_set_allocated:ecc_message.private_multiplier)
}

// -------------------------------------------------------------------

// key_message

// optional string key_name = 1;
inline bool key_message::_internal_has_key_name() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool key_message::has_key_name() const {
  return _internal_has_key_name();
}
inline void key_message::clear_key_name() {
  key_name_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& key_message::key_name() const {
  // @@protoc_insertion_point(field_get:key_message.key_name)
  return _internal_key_name();
}
inline void key_message::set_key_name(const std::string& value) {
  _internal_set_key_name(value);
  // @@protoc_insertion_point(field_set:key_message.key_name)
}
inline std::string* key_message::mutable_key_name() {
  // @@protoc_insertion_point(field_mutable:key_message.key_name)
  return _internal_mutable_key_name();
}
inline const std::string& key_message::_internal_key_name() const {
  return key_name_.GetNoArena();
}
inline void key_message::_internal_set_key_name(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  key_name_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
}
inline void key_message::set_key_name(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  key_name_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:key_message.key_name)
}
inline void key_message::set_key_name(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  key_name_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:key_message.key_name)
}
inline void key_message::set_key_name(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000001u;
  key_name_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:key_message.key_name)
}
inline std::string* key_message::_internal_mutable_key_name() {
  _has_bits_[0] |= 0x00000001u;
  return key_name_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* key_message::release_key_name() {
  // @@protoc_insertion_point(field_release:key_message.key_name)
  if (!_internal_has_key_name()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return key_name_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void key_message::set_allocated_key_name(std::string* key_name) {
  if (key_name != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  key_name_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), key_name);
  // @@protoc_insertion_point(field_set_allocated:key_message.key_name)
}

// optional string key_type = 2;
inline bool key_message::_internal_has_key_type() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool key_message::has_key_type() const {
  return _internal_has_key_type();
}
inline void key_message::clear_key_type() {
  key_type_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& key_message::key_type() const {
  // @@protoc_insertion_point(field_get:key_message.key_type)
  return _internal_key_type();
}
inline void key_message::set_key_type(const std::string& value) {
  _internal_set_key_type(value);
  // @@protoc_insertion_point(field_set:key_message.key_type)
}
inline std::string* key_message::mutable_key_type() {
  // @@protoc_insertion_point(field_mutable:key_message.key_type)
  return _internal_mutable_key_type();
}
inline const std::string& key_message::_internal_key_type() const {
  return key_type_.GetNoArena();
}
inline void key_message::_internal_set_key_type(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  key_type_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
}
inline void key_message::set_key_type(std::string&& value) {
  _has_bits_[0] |= 0x00000002u;
  key_type_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:key_message.key_type)
}
inline void key_message::set_key_type(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000002u;
  key_type_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:key_message.key_type)
}
inline void key_message::set_key_type(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000002u;
  key_type_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:key_message.key_type)
}
inline std::string* key_message::_internal_mutable_key_type() {
  _has_bits_[0] |= 0x00000002u;
  return key_type_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* key_message::release_key_type() {
  // @@protoc_insertion_point(field_release:key_message.key_type)
  if (!_internal_has_key_type()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  return key_type_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void key_message::set_allocated_key_type(std::string* key_type) {
  if (key_type != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  key_type_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), key_type);
  // @@protoc_insertion_point(field_set_allocated:key_message.key_type)
}

// optional string key_format = 3;
inline bool key_message::_internal_has_key_format() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool key_message::has_key_format() const {
  return _internal_has_key_format();
}
inline void key_message::clear_key_format() {
  key_format_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000004u;
}
inline const std::string& key_message::key_format() const {
  // @@protoc_insertion_point(field_get:key_message.key_format)
  return _internal_key_format();
}
inline void key_message::set_key_format(const std::string& value) {
  _internal_set_key_format(value);
  // @@protoc_insertion_point(field_set:key_message.key_format)
}
inline std::string* key_message::mutable_key_format() {
  // @@protoc_insertion_point(field_mutable:key_message.key_format)
  return _internal_mutable_key_format();
}
inline const std::string& key_message::_internal_key_format() const {
  return key_format_.GetNoArena();
}
inline void key_message::_internal_set_key_format(const std::string& value) {
  _has_bits_[0] |= 0x00000004u;
  key_format_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
}
inline void key_message::set_key_format(std::string&& value) {
  _has_bits_[0] |= 0x00000004u;
  key_format_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:key_message.key_format)
}
inline void key_message::set_key_format(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000004u;
  key_format_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:key_message.key_format)
}
inline void key_message::set_key_format(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000004u;
  key_format_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:key_message.key_format)
}
inline std::string* key_message::_internal_mutable_key_format() {
  _has_bits_[0] |= 0x00000004u;
  return key_format_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* key_message::release_key_format() {
  // @@protoc_insertion_point(field_release:key_message.key_format)
  if (!_internal_has_key_format()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000004u;
  return key_format_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void key_message::set_allocated_key_format(std::string* key_format) {
  if (key_format != nullptr) {
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  key_format_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), key_format);
  // @@protoc_insertion_point(field_set_allocated:key_message.key_format)
}

// optional .rsa_message rsa_key = 4;
inline bool key_message::_internal_has_rsa_key() const {
  bool value = (_has_bits_[0] & 0x00000100u) != 0;
  PROTOBUF_ASSUME(!value || rsa_key_ != nullptr);
  return value;
}
inline bool key_message::has_rsa_key() const {
  return _internal_has_rsa_key();
}
inline void key_message::clear_rsa_key() {
  if (rsa_key_ != nullptr) rsa_key_->Clear();
  _has_bits_[0] &= ~0x00000100u;
}
inline const ::rsa_message& key_message::_internal_rsa_key() const {
  const ::rsa_message* p = rsa_key_;
  return p != nullptr ? *p : *reinterpret_cast<const ::rsa_message*>(
      &::_rsa_message_default_instance_);
}
inline const ::rsa_message& key_message::rsa_key() const {
  // @@protoc_insertion_point(field_get:key_message.rsa_key)
  return _internal_rsa_key();
}
inline ::rsa_message* key_message::release_rsa_key() {
  // @@protoc_insertion_point(field_release:key_message.rsa_key)
  _has_bits_[0] &= ~0x00000100u;
  ::rsa_message* temp = rsa_key_;
  rsa_key_ = nullptr;
  return temp;
}
inline ::rsa_message* key_message::_internal_mutable_rsa_key() {
  _has_bits_[0] |= 0x00000100u;
  if (rsa_key_ == nullptr) {
    auto* p = CreateMaybeMessage<::rsa_message>(GetArenaNoVirtual());
    rsa_key_ = p;
  }
  return rsa_key_;
}
inline ::rsa_message* key_message::mutable_rsa_key() {
  // @@protoc_insertion_point(field_mutable:key_message.rsa_key)
  return _internal_mutable_rsa_key();
}
inline void key_message::set_allocated_rsa_key(::rsa_message* rsa_key) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete rsa_key_;
  }
  if (rsa_key) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      rsa_key = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, rsa_key, submessage_arena);
    }
    _has_bits_[0] |= 0x00000100u;
  } else {
    _has_bits_[0] &= ~0x00000100u;
  }
  rsa_key_ = rsa_key;
  // @@protoc_insertion_point(field_set_allocated:key_message.rsa_key)
}

// optional .ecc_message ecc_key = 5;
inline bool key_message::_internal_has_ecc_key() const {
  bool value = (_has_bits_[0] & 0x00000200u) != 0;
  PROTOBUF_ASSUME(!value || ecc_key_ != nullptr);
  return value;
}
inline bool key_message::has_ecc_key() const {
  return _internal_has_ecc_key();
}
inline void key_message::clear_ecc_key() {
  if (ecc_key_ != nullptr) ecc_key_->Clear();
  _has_bits_[0] &= ~0x00000200u;
}
inline const ::ecc_message& key_message::_internal_ecc_key() const {
  const ::ecc_message* p = ecc_key_;
  return p != nullptr ? *p : *reinterpret_cast<const ::ecc_message*>(
      &::_ecc_message_default_instance_);
}
inline const ::ecc_message& key_message::ecc_key() const {
  // @@protoc_insertion_point(field_get:key_message.ecc_key)
  return _internal_ecc_key();
}
inline ::ecc_message* key_message::release_ecc_key() {
  // @@protoc_insertion_point(field_release:key_message.ecc_key)
  _has_bits_[0] &= ~0x00000200u;
  ::ecc_message* temp = ecc_key_;
  ecc_key_ = nullptr;
  return temp;
}
inline ::ecc_message* key_message::_internal_mutable_ecc_key() {
  _has_bits_[0] |= 0x00000200u;
  if (ecc_key_ == nullptr) {
    auto* p = CreateMaybeMessage<::ecc_message>(GetArenaNoVirtual());
    ecc_key_ = p;
  }
  return ecc_key_;
}
inline ::ecc_message* key_message::mutable_ecc_key() {
  // @@protoc_insertion_point(field_mutable:key_message.ecc_key)
  return _internal_mutable_ecc_key();
}
inline void key_message::set_allocated_ecc_key(::ecc_message* ecc_key) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete ecc_key_;
  }
  if (ecc_key) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      ecc_key = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, ecc_key, submessage_arena);
    }
    _has_bits_[0] |= 0x00000200u;
  } else {
    _has_bits_[0] &= ~0x00000200u;
  }
  ecc_key_ = ecc_key;
  // @@protoc_insertion_point(field_set_allocated:key_message.ecc_key)
}

// optional bytes secret_key_bits = 6;
inline bool key_message::_internal_has_secret_key_bits() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool key_message::has_secret_key_bits() const {
  return _internal_has_secret_key_bits();
}
inline void key_message::clear_secret_key_bits() {
  secret_key_bits_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000008u;
}
inline const std::string& key_message::secret_key_bits() const {
  // @@protoc_insertion_point(field_get:key_message.secret_key_bits)
  return _internal_secret_key_bits();
}
inline void key_message::set_secret_key_bits(const std::string& value) {
  _internal_set_secret_key_bits(value);
  // @@protoc_insertion_point(field_set:key_message.secret_key_bits)
}
inline std::string* key_message::mutable_secret_key_bits() {
  // @@protoc_insertion_point(field_mutable:key_message.secret_key_bits)
  return _internal_mutable_secret_key_bits();
}
inline const std::string& key_message::_internal_secret_key_bits() const {
  return secret_key_bits_.GetNoArena();
}
inline void key_message::_internal_set_secret_key_bits(const std::string& value) {
  _has_bits_[0] |= 0x00000008u;
  secret_key_bits_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
}
inline void key_message::set_secret_key_bits(std::string&& value) {
  _has_bits_[0] |= 0x00000008u;
  secret_key_bits_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:key_message.secret_key_bits)
}
inline void key_message::set_secret_key_bits(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000008u;
  secret_key_bits_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:key_message.secret_key_bits)
}
inline void key_message::set_secret_key_bits(const void* value, size_t size) {
  _has_bits_[0] |= 0x00000008u;
  secret_key_bits_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:key_message.secret_key_bits)
}
inline std::string* key_message::_internal_mutable_secret_key_bits() {
  _has_bits_[0] |= 0x00000008u;
  return secret_key_bits_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* key_message::release_secret_key_bits() {
  // @@protoc_insertion_point(field_release:key_message.secret_key_bits)
  if (!_internal_has_secret_key_bits()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000008u;
  return secret_key_bits_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void key_message::set_allocated_secret_key_bits(std::string* secret_key_bits) {
  if (secret_key_bits != nullptr) {
    _has_bits_[0] |= 0x00000008u;
  } else {
    _has_bits_[0] &= ~0x00000008u;
  }
  secret_key_bits_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), secret_key_bits);
  // @@protoc_insertion_point(field_set_allocated:key_message.secret_key_bits)
}

// optional bytes certificate = 7;
inline bool key_message::_internal_has_certificate() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool key_message::has_certificate() const {
  return _internal_has_certificate();
}
inline void key_message::clear_certificate() {
  certificate_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000010u;
}
inline const std::string& key_message::certificate() const {
  // @@protoc_insertion_point(field_get:key_message.certificate)
  return _internal_certificate();
}
inline void key_message::set_certificate(const std::string& value) {
  _internal_set_certificate(value);
  // @@protoc_insertion_point(field_set:key_message.certificate)
}
inline std::string* key_message::mutable_certificate() {
  // @@protoc_insertion_point(field_mutable:key_message.certificate)
  return _internal_mutable_certificate();
}
inline const std::string& key_message::_internal_certificate() const {
  return certificate_.GetNoArena();
}
inline void key_message::_internal_set_certificate(const std::string& value) {
  _has_bits_[0] |= 0x00000010u;
  certificate_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
}
inline void key_message::set_certificate(std::string&& value) {
  _has_bits_[0] |= 0x00000010u;
  certificate_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:key_message.certificate)
}
inline void key_message::set_certificate(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000010u;
  certificate_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:key_message.certificate)
}
inline void key_message::set_certificate(const void* value, size_t size) {
  _has_bits_[0] |= 0x00000010u;
  certificate_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:key_message.certificate)
}
inline std::string* key_message::_internal_mutable_certificate() {
  _has_bits_[0] |= 0x00000010u;
  return certificate_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* key_message::release_certificate() {
  // @@protoc_insertion_point(field_release:key_message.certificate)
  if (!_internal_has_certificate()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000010u;
  return certificate_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void key_message::set_allocated_certificate(std::string* certificate) {
  if (certificate != nullptr) {
    _has_bits_[0] |= 0x00000010u;
  } else {
    _has_bits_[0] &= ~0x00000010u;
  }
  certificate_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), certificate);
  // @@protoc_insertion_point(field_set_allocated:key_message.certificate)
}

// optional bytes other_key_formats = 8;
inline bool key_message::_internal_has_other_key_formats() const {
  bool value = (_has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool key_message::has_other_key_formats() const {
  return _internal_has_other_key_formats();
}
inline void key_message::clear_other_key_formats() {
  other_key_formats_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000020u;
}
inline const std::string& key_message::other_key_formats() const {
  // @@protoc_insertion_point(field_get:key_message.other_key_formats)
  return _internal_other_key_formats();
}
inline void key_message::set_other_key_formats(const std::string& value) {
  _internal_set_other_key_formats(value);
  // @@protoc_insertion_point(field_set:key_message.other_key_formats)
}
inline std::string* key_message::mutable_other_key_formats() {
  // @@protoc_insertion_point(field_mutable:key_message.other_key_formats)
  return _internal_mutable_other_key_formats();
}
inline const std::string& key_message::_internal_other_key_formats() const {
  return other_key_formats_.GetNoArena();
}
inline void key_message::_internal_set_other_key_formats(const std::string& value) {
  _has_bits_[0] |= 0x00000020u;
  other_key_formats_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
}
inline void key_message::set_other_key_formats(std::string&& value) {
  _has_bits_[0] |= 0x00000020u;
  other_key_formats_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:key_message.other_key_formats)
}
inline void key_message::set_other_key_formats(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000020u;
  other_key_formats_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:key_message.other_key_formats)
}
inline void key_message::set_other_key_formats(const void* value, size_t size) {
  _has_bits_[0] |= 0x00000020u;
  other_key_formats_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:key_message.other_key_formats)
}
inline std::string* key_message::_internal_mutable_other_key_formats() {
  _has_bits_[0] |= 0x00000020u;
  return other_key_formats_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* key_message::release_other_key_formats() {
  // @@protoc_insertion_point(field_release:key_message.other_key_formats)
  if (!_internal_has_other_key_formats()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000020u;
  return other_key_formats_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void key_message::set_allocated_other_key_formats(std::string* other_key_formats) {
  if (other_key_formats != nullptr) {
    _has_bits_[0] |= 0x00000020u;
  } else {
    _has_bits_[0] &= ~0x00000020u;
  }
  other_key_formats_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), other_key_formats);
  // @@protoc_insertion_point(field_set_allocated:key_message.other_key_formats)
}

// optional string not_before = 9;
inline bool key_message::_internal_has_not_before() const {
  bool value = (_has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline bool key_message::has_not_before() const {
  return _internal_has_not_before();
}
inline void key_message::clear_not_before() {
  not_before_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000040u;
}
inline const std::string& key_message::not_before() const {
  // @@protoc_insertion_point(field_get:key_message.not_before)
  return _internal_not_before();
}
inline void key_message::set_not_before(const std::string& value) {
  _internal_set_not_before(value);
  // @@protoc_insertion_point(field_set:key_message.not_before)
}
inline std::string* key_message::mutable_not_before() {
  // @@protoc_insertion_point(field_mutable:key_message.not_before)
  return _internal_mutable_not_before();
}
inline const std::string& key_message::_internal_not_before() const {
  return not_before_.GetNoArena();
}
inline void key_message::_internal_set_not_before(const std::string& value) {
  _has_bits_[0] |= 0x00000040u;
  not_before_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
}
inline void key_message::set_not_before(std::string&& value) {
  _has_bits_[0] |= 0x00000040u;
  not_before_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:key_message.not_before)
}
inline void key_message::set_not_before(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000040u;
  not_before_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:key_message.not_before)
}
inline void key_message::set_not_before(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000040u;
  not_before_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:key_message.not_before)
}
inline std::string* key_message::_internal_mutable_not_before() {
  _has_bits_[0] |= 0x00000040u;
  return not_before_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* key_message::release_not_before() {
  // @@protoc_insertion_point(field_release:key_message.not_before)
  if (!_internal_has_not_before()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000040u;
  return not_before_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void key_message::set_allocated_not_before(std::string* not_before) {
  if (not_before != nullptr) {
    _has_bits_[0] |= 0x00000040u;
  } else {
    _has_bits_[0] &= ~0x00000040u;
  }
  not_before_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), not_before);
  // @@protoc_insertion_point(field_set_allocated:key_message.not_before)
}

// optional string not_after = 10;
inline bool key_message::_internal_has_not_after() const {
  bool value = (_has_bits_[0] & 0x00000080u) != 0;
  return value;
}
inline bool key_message::has_not_after() const {
  return _internal_has_not_after();
}
inline void key_message::clear_not_after() {
  not_after_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000080u;
}
inline const std::string& key_message::not_after() const {
  // @@protoc_insertion_point(field_get:key_message.not_after)
  return _internal_not_after();
}
inline void key_message::set_not_after(const std::string& value) {
  _internal_set_not_after(value);
  // @@protoc_insertion_point(field_set:key_message.not_after)
}
inline std::string* key_message::mutable_not_after() {
  // @@protoc_insertion_point(field_mutable:key_message.not_after)
  return _internal_mutable_not_after();
}
inline const std::string& key_message::_internal_not_after() const {
  return not_after_.GetNoArena();
}
inline void key_message::_internal_set_not_after(const std::string& value) {
  _has_bits_[0] |= 0x00000080u;
  not_after_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
}
inline void key_message::set_not_after(std::string&& value) {
  _has_bits_[0] |= 0x00000080u;
  not_after_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:key_message.not_after)
}
inline void key_message::set_not_after(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000080u;
  not_after_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:key_message.not_after)
}
inline void key_message::set_not_after(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000080u;
  not_after_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:key_message.not_after)
}
inline std::string* key_message::_internal_mutable_not_after() {
  _has_bits_[0] |= 0x00000080u;
  return not_after_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* key_message::release_not_after() {
  // @@protoc_insertion_point(field_release:key_message.not_after)
  if (!_internal_has_not_after()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000080u;
  return not_after_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void key_message::set_allocated_not_after(std::string* not_after) {
  if (not_after != nullptr) {
    _has_bits_[0] |= 0x00000080u;
  } else {
    _has_bits_[0] &= ~0x00000080u;
  }
  not_after_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), not_after);
  // @@protoc_insertion_point(field_set_allocated:key_message.not_after)
}

// -------------------------------------------------------------------

// protected_blob_message

// optional bytes encrypted_key = 1;
inline bool protected_blob_message::_internal_has_encrypted_key() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool protected_blob_message::has_encrypted_key() const {
  return _internal_has_encrypted_key();
}
inline void protected_blob_message::clear_encrypted_key() {
  encrypted_key_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& protected_blob_message::encrypted_key() const {
  // @@protoc_insertion_point(field_get:protected_blob_message.encrypted_key)
  return _internal_encrypted_key();
}
inline void protected_blob_message::set_encrypted_key(const std::string& value) {
  _internal_set_encrypted_key(value);
  // @@protoc_insertion_point(field_set:protected_blob_message.encrypted_key)
}
inline std::string* protected_blob_message::mutable_encrypted_key() {
  // @@protoc_insertion_point(field_mutable:protected_blob_message.encrypted_key)
  return _internal_mutable_encrypted_key();
}
inline const std::string& protected_blob_message::_internal_encrypted_key() const {
  return encrypted_key_.GetNoArena();
}
inline void protected_blob_message::_internal_set_encrypted_key(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  encrypted_key_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
}
inline void protected_blob_message::set_encrypted_key(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  encrypted_key_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:protected_blob_message.encrypted_key)
}
inline void protected_blob_message::set_encrypted_key(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  encrypted_key_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:protected_blob_message.encrypted_key)
}
inline void protected_blob_message::set_encrypted_key(const void* value, size_t size) {
  _has_bits_[0] |= 0x00000001u;
  encrypted_key_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:protected_blob_message.encrypted_key)
}
inline std::string* protected_blob_message::_internal_mutable_encrypted_key() {
  _has_bits_[0] |= 0x00000001u;
  return encrypted_key_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* protected_blob_message::release_encrypted_key() {
  // @@protoc_insertion_point(field_release:protected_blob_message.encrypted_key)
  if (!_internal_has_encrypted_key()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return encrypted_key_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void protected_blob_message::set_allocated_encrypted_key(std::string* encrypted_key) {
  if (encrypted_key != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  encrypted_key_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), encrypted_key);
  // @@protoc_insertion_point(field_set_allocated:protected_blob_message.encrypted_key)
}

// optional bytes encrypted_data = 2;
inline bool protected_blob_message::_internal_has_encrypted_data() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool protected_blob_message::has_encrypted_data() const {
  return _internal_has_encrypted_data();
}
inline void protected_blob_message::clear_encrypted_data() {
  encrypted_data_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& protected_blob_message::encrypted_data() const {
  // @@protoc_insertion_point(field_get:protected_blob_message.encrypted_data)
  return _internal_encrypted_data();
}
inline void protected_blob_message::set_encrypted_data(const std::string& value) {
  _internal_set_encrypted_data(value);
  // @@protoc_insertion_point(field_set:protected_blob_message.encrypted_data)
}
inline std::string* protected_blob_message::mutable_encrypted_data() {
  // @@protoc_insertion_point(field_mutable:protected_blob_message.encrypted_data)
  return _internal_mutable_encrypted_data();
}
inline const std::string& protected_blob_message::_internal_encrypted_data() const {
  return encrypted_data_.GetNoArena();
}
inline void protected_blob_message::_internal_set_encrypted_data(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  encrypted_data_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
}
inline void protected_blob_message::set_encrypted_data(std::string&& value) {
  _has_bits_[0] |= 0x00000002u;
  encrypted_data_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:protected_blob_message.encrypted_data)
}
inline void protected_blob_message::set_encrypted_data(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000002u;
  encrypted_data_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:protected_blob_message.encrypted_data)
}
inline void protected_blob_message::set_encrypted_data(const void* value, size_t size) {
  _has_bits_[0] |= 0x00000002u;
  encrypted_data_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:protected_blob_message.encrypted_data)
}
inline std::string* protected_blob_message::_internal_mutable_encrypted_data() {
  _has_bits_[0] |= 0x00000002u;
  return encrypted_data_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* protected_blob_message::release_encrypted_data() {
  // @@protoc_insertion_point(field_release:protected_blob_message.encrypted_data)
  if (!_internal_has_encrypted_data()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  return encrypted_data_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void protected_blob_message::set_allocated_encrypted_data(std::string* encrypted_data) {
  if (encrypted_data != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  encrypted_data_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), encrypted_data);
  // @@protoc_insertion_point(field_set_allocated:protected_blob_message.encrypted_data)
}

// -------------------------------------------------------------------

// property

// optional string property_name = 1;
inline bool property::_internal_has_property_name() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool property::has_property_name() const {
  return _internal_has_property_name();
}
inline void property::clear_property_name() {
  property_name_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& property::property_name() const {
  // @@protoc_insertion_point(field_get:property.property_name)
  return _internal_property_name();
}
inline void property::set_property_name(const std::string& value) {
  _internal_set_property_name(value);
  // @@protoc_insertion_point(field_set:property.property_name)
}
inline std::string* property::mutable_property_name() {
  // @@protoc_insertion_point(field_mutable:property.property_name)
  return _internal_mutable_property_name();
}
inline const std::string& property::_internal_property_name() const {
  return property_name_.GetNoArena();
}
inline void property::_internal_set_property_name(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  property_name_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
}
inline void property::set_property_name(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  property_name_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:property.property_name)
}
inline void property::set_property_name(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  property_name_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:property.property_name)
}
inline void property::set_property_name(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000001u;
  property_name_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:property.property_name)
}
inline std::string* property::_internal_mutable_property_name() {
  _has_bits_[0] |= 0x00000001u;
  return property_name_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* property::release_property_name() {
  // @@protoc_insertion_point(field_release:property.property_name)
  if (!_internal_has_property_name()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return property_name_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void property::set_allocated_property_name(std::string* property_name) {
  if (property_name != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  property_name_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), property_name);
  // @@protoc_insertion_point(field_set_allocated:property.property_name)
}

// optional string value_type = 2;
inline bool property::_internal_has_value_type() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool property::has_value_type() const {
  return _internal_has_value_type();
}
inline void property::clear_value_type() {
  value_type_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& property::value_type() const {
  // @@protoc_insertion_point(field_get:property.value_type)
  return _internal_value_type();
}
inline void property::set_value_type(const std::string& value) {
  _internal_set_value_type(value);
  // @@protoc_insertion_point(field_set:property.value_type)
}
inline std::string* property::mutable_value_type() {
  // @@protoc_insertion_point(field_mutable:property.value_type)
  return _internal_mutable_value_type();
}
inline const std::string& property::_internal_value_type() const {
  return value_type_.GetNoArena();
}
inline void property::_internal_set_value_type(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  value_type_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
}
inline void property::set_value_type(std::string&& value) {
  _has_bits_[0] |= 0x00000002u;
  value_type_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:property.value_type)
}
inline void property::set_value_type(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000002u;
  value_type_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:property.value_type)
}
inline void property::set_value_type(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000002u;
  value_type_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:property.value_type)
}
inline std::string* property::_internal_mutable_value_type() {
  _has_bits_[0] |= 0x00000002u;
  return value_type_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* property::release_value_type() {
  // @@protoc_insertion_point(field_release:property.value_type)
  if (!_internal_has_value_type()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  return value_type_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void property::set_allocated_value_type(std::string* value_type) {
  if (value_type != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  value_type_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value_type);
  // @@protoc_insertion_point(field_set_allocated:property.value_type)
}

// optional string comparator = 3;
inline bool property::_internal_has_comparator() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool property::has_comparator() const {
  return _internal_has_comparator();
}
inline void property::clear_comparator() {
  comparator_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000004u;
}
inline const std::string& property::comparator() const {
  // @@protoc_insertion_point(field_get:property.comparator)
  return _internal_comparator();
}
inline void property::set_comparator(const std::string& value) {
  _internal_set_comparator(value);
  // @@protoc_insertion_point(field_set:property.comparator)
}
inline std::string* property::mutable_comparator() {
  // @@protoc_insertion_point(field_mutable:property.comparator)
  return _internal_mutable_comparator();
}
inline const std::string& property::_internal_comparator() const {
  return comparator_.GetNoArena();
}
inline void property::_internal_set_comparator(const std::string& value) {
  _has_bits_[0] |= 0x00000004u;
  comparator_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
}
inline void property::set_comparator(std::string&& value) {
  _has_bits_[0] |= 0x00000004u;
  comparator_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:property.comparator)
}
inline void property::set_comparator(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000004u;
  comparator_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:property.comparator)
}
inline void property::set_comparator(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000004u;
  comparator_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:property.comparator)
}
inline std::string* property::_internal_mutable_comparator() {
  _has_bits_[0] |= 0x00000004u;
  return comparator_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* property::release_comparator() {
  // @@protoc_insertion_point(field_release:property.comparator)
  if (!_internal_has_comparator()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000004u;
  return comparator_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void property::set_allocated_comparator(std::string* comparator) {
  if (comparator != nullptr) {
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  comparator_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), comparator);
  // @@protoc_insertion_point(field_set_allocated:property.comparator)
}

// optional string string_value = 4;
inline bool property::_internal_has_string_value() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool property::has_string_value() const {
  return _internal_has_string_value();
}
inline void property::clear_string_value() {
  string_value_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000008u;
}
inline const std::string& property::string_value() const {
  // @@protoc_insertion_point(field_get:property.string_value)
  return _internal_string_value();
}
inline void property::set_string_value(const std::string& value) {
  _internal_set_string_value(value);
  // @@protoc_insertion_point(field_set:property.string_value)
}
inline std::string* property::mutable_string_value() {
  // @@protoc_insertion_point(field_mutable:property.string_value)
  return _internal_mutable_string_value();
}
inline const std::string& property::_internal_string_value() const {
  return string_value_.GetNoArena();
}
inline void property::_internal_set_string_value(const std::string& value) {
  _has_bits_[0] |= 0x00000008u;
  string_value_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
}
inline void property::set_string_value(std::string&& value) {
  _has_bits_[0] |= 0x00000008u;
  string_value_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:property.string_value)
}
inline void property::set_string_value(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000008u;
  string_value_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:property.string_value)
}
inline void property::set_string_value(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000008u;
  string_value_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:property.string_value)
}
inline std::string* property::_internal_mutable_string_value() {
  _has_bits_[0] |= 0x00000008u;
  return string_value_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* property::release_string_value() {
  // @@protoc_insertion_point(field_release:property.string_value)
  if (!_internal_has_string_value()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000008u;
  return string_value_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void property::set_allocated_string_value(std::string* string_value) {
  if (string_value != nullptr) {
    _has_bits_[0] |= 0x00000008u;
  } else {
    _has_bits_[0] &= ~0x00000008u;
  }
  string_value_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), string_value);
  // @@protoc_insertion_point(field_set_allocated:property.string_value)
}

// optional uint64 int_value = 5;
inline bool property::_internal_has_int_value() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool property::has_int_value() const {
  return _internal_has_int_value();
}
inline void property::clear_int_value() {
  int_value_ = PROTOBUF_ULONGLONG(0);
  _has_bits_[0] &= ~0x00000010u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 property::_internal_int_value() const {
  return int_value_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 property::int_value() const {
  // @@protoc_insertion_point(field_get:property.int_value)
  return _internal_int_value();
}
inline void property::_internal_set_int_value(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _has_bits_[0] |= 0x00000010u;
  int_value_ = value;
}
inline void property::set_int_value(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _internal_set_int_value(value);
  // @@protoc_insertion_point(field_set:property.int_value)
}

// -------------------------------------------------------------------

// properties

// repeated .property props = 1;
inline int properties::_internal_props_size() const {
  return props_.size();
}
inline int properties::props_size() const {
  return _internal_props_size();
}
inline void properties::clear_props() {
  props_.Clear();
}
inline ::property* properties::mutable_props(int index) {
  // @@protoc_insertion_point(field_mutable:properties.props)
  return props_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::property >*
properties::mutable_props() {
  // @@protoc_insertion_point(field_mutable_list:properties.props)
  return &props_;
}
inline const ::property& properties::_internal_props(int index) const {
  return props_.Get(index);
}
inline const ::property& properties::props(int index) const {
  // @@protoc_insertion_point(field_get:properties.props)
  return _internal_props(index);
}
inline ::property* properties::_internal_add_props() {
  return props_.Add();
}
inline ::property* properties::add_props() {
  // @@protoc_insertion_point(field_add:properties.props)
  return _internal_add_props();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::property >&
properties::props() const {
  // @@protoc_insertion_point(field_list:properties.props)
  return props_;
}

// -------------------------------------------------------------------

// platform

// optional string platform_type = 1;
inline bool platform::_internal_has_platform_type() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool platform::has_platform_type() const {
  return _internal_has_platform_type();
}
inline void platform::clear_platform_type() {
  platform_type_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& platform::platform_type() const {
  // @@protoc_insertion_point(field_get:platform.platform_type)
  return _internal_platform_type();
}
inline void platform::set_platform_type(const std::string& value) {
  _internal_set_platform_type(value);
  // @@protoc_insertion_point(field_set:platform.platform_type)
}
inline std::string* platform::mutable_platform_type() {
  // @@protoc_insertion_point(field_mutable:platform.platform_type)
  return _internal_mutable_platform_type();
}
inline const std::string& platform::_internal_platform_type() const {
  return platform_type_.GetNoArena();
}
inline void platform::_internal_set_platform_type(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  platform_type_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
}
inline void platform::set_platform_type(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  platform_type_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:platform.platform_type)
}
inline void platform::set_platform_type(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  platform_type_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:platform.platform_type)
}
inline void platform::set_platform_type(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000001u;
  platform_type_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:platform.platform_type)
}
inline std::string* platform::_internal_mutable_platform_type() {
  _has_bits_[0] |= 0x00000001u;
  return platform_type_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* platform::release_platform_type() {
  // @@protoc_insertion_point(field_release:platform.platform_type)
  if (!_internal_has_platform_type()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return platform_type_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void platform::set_allocated_platform_type(std::string* platform_type) {
  if (platform_type != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  platform_type_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), platform_type);
  // @@protoc_insertion_point(field_set_allocated:platform.platform_type)
}

// optional .key_message attest_key = 2;
inline bool platform::_internal_has_attest_key() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || attest_key_ != nullptr);
  return value;
}
inline bool platform::has_attest_key() const {
  return _internal_has_attest_key();
}
inline void platform::clear_attest_key() {
  if (attest_key_ != nullptr) attest_key_->Clear();
  _has_bits_[0] &= ~0x00000002u;
}
inline const ::key_message& platform::_internal_attest_key() const {
  const ::key_message* p = attest_key_;
  return p != nullptr ? *p : *reinterpret_cast<const ::key_message*>(
      &::_key_message_default_instance_);
}
inline const ::key_message& platform::attest_key() const {
  // @@protoc_insertion_point(field_get:platform.attest_key)
  return _internal_attest_key();
}
inline ::key_message* platform::release_attest_key() {
  // @@protoc_insertion_point(field_release:platform.attest_key)
  _has_bits_[0] &= ~0x00000002u;
  ::key_message* temp = attest_key_;
  attest_key_ = nullptr;
  return temp;
}
inline ::key_message* platform::_internal_mutable_attest_key() {
  _has_bits_[0] |= 0x00000002u;
  if (attest_key_ == nullptr) {
    auto* p = CreateMaybeMessage<::key_message>(GetArenaNoVirtual());
    attest_key_ = p;
  }
  return attest_key_;
}
inline ::key_message* platform::mutable_attest_key() {
  // @@protoc_insertion_point(field_mutable:platform.attest_key)
  return _internal_mutable_attest_key();
}
inline void platform::set_allocated_attest_key(::key_message* attest_key) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete attest_key_;
  }
  if (attest_key) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      attest_key = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, attest_key, submessage_arena);
    }
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  attest_key_ = attest_key;
  // @@protoc_insertion_point(field_set_allocated:platform.attest_key)
}

// optional .properties props = 3;
inline bool platform::_internal_has_props() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || props_ != nullptr);
  return value;
}
inline bool platform::has_props() const {
  return _internal_has_props();
}
inline void platform::clear_props() {
  if (props_ != nullptr) props_->Clear();
  _has_bits_[0] &= ~0x00000004u;
}
inline const ::properties& platform::_internal_props() const {
  const ::properties* p = props_;
  return p != nullptr ? *p : *reinterpret_cast<const ::properties*>(
      &::_properties_default_instance_);
}
inline const ::properties& platform::props() const {
  // @@protoc_insertion_point(field_get:platform.props)
  return _internal_props();
}
inline ::properties* platform::release_props() {
  // @@protoc_insertion_point(field_release:platform.props)
  _has_bits_[0] &= ~0x00000004u;
  ::properties* temp = props_;
  props_ = nullptr;
  return temp;
}
inline ::properties* platform::_internal_mutable_props() {
  _has_bits_[0] |= 0x00000004u;
  if (props_ == nullptr) {
    auto* p = CreateMaybeMessage<::properties>(GetArenaNoVirtual());
    props_ = p;
  }
  return props_;
}
inline ::properties* platform::mutable_props() {
  // @@protoc_insertion_point(field_mutable:platform.props)
  return _internal_mutable_props();
}
inline void platform::set_allocated_props(::properties* props) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete props_;
  }
  if (props) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      props = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, props, submessage_arena);
    }
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  props_ = props;
  // @@protoc_insertion_point(field_set_allocated:platform.props)
}

// optional bool has_key = 4;
inline bool platform::_internal_has_has_key() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool platform::has_has_key() const {
  return _internal_has_has_key();
}
inline void platform::clear_has_key() {
  has_key_ = false;
  _has_bits_[0] &= ~0x00000008u;
}
inline bool platform::_internal_has_key() const {
  return has_key_;
}
inline bool platform::has_key() const {
  // @@protoc_insertion_point(field_get:platform.has_key)
  return _internal_has_key();
}
inline void platform::_internal_set_has_key(bool value) {
  _has_bits_[0] |= 0x00000008u;
  has_key_ = value;
}
inline void platform::set_has_key(bool value) {
  _internal_set_has_key(value);
  // @@protoc_insertion_point(field_set:platform.has_key)
}

// -------------------------------------------------------------------

// environment

// optional .platform the_platform = 1;
inline bool environment::_internal_has_the_platform() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || the_platform_ != nullptr);
  return value;
}
inline bool environment::has_the_platform() const {
  return _internal_has_the_platform();
}
inline void environment::clear_the_platform() {
  if (the_platform_ != nullptr) the_platform_->Clear();
  _has_bits_[0] &= ~0x00000002u;
}
inline const ::platform& environment::_internal_the_platform() const {
  const ::platform* p = the_platform_;
  return p != nullptr ? *p : *reinterpret_cast<const ::platform*>(
      &::_platform_default_instance_);
}
inline const ::platform& environment::the_platform() const {
  // @@protoc_insertion_point(field_get:environment.the_platform)
  return _internal_the_platform();
}
inline ::platform* environment::release_the_platform() {
  // @@protoc_insertion_point(field_release:environment.the_platform)
  _has_bits_[0] &= ~0x00000002u;
  ::platform* temp = the_platform_;
  the_platform_ = nullptr;
  return temp;
}
inline ::platform* environment::_internal_mutable_the_platform() {
  _has_bits_[0] |= 0x00000002u;
  if (the_platform_ == nullptr) {
    auto* p = CreateMaybeMessage<::platform>(GetArenaNoVirtual());
    the_platform_ = p;
  }
  return the_platform_;
}
inline ::platform* environment::mutable_the_platform() {
  // @@protoc_insertion_point(field_mutable:environment.the_platform)
  return _internal_mutable_the_platform();
}
inline void environment::set_allocated_the_platform(::platform* the_platform) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete the_platform_;
  }
  if (the_platform) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      the_platform = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, the_platform, submessage_arena);
    }
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  the_platform_ = the_platform;
  // @@protoc_insertion_point(field_set_allocated:environment.the_platform)
}

// optional bytes the_measurement = 2;
inline bool environment::_internal_has_the_measurement() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool environment::has_the_measurement() const {
  return _internal_has_the_measurement();
}
inline void environment::clear_the_measurement() {
  the_measurement_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& environment::the_measurement() const {
  // @@protoc_insertion_point(field_get:environment.the_measurement)
  return _internal_the_measurement();
}
inline void environment::set_the_measurement(const std::string& value) {
  _internal_set_the_measurement(value);
  // @@protoc_insertion_point(field_set:environment.the_measurement)
}
inline std::string* environment::mutable_the_measurement() {
  // @@protoc_insertion_point(field_mutable:environment.the_measurement)
  return _internal_mutable_the_measurement();
}
inline const std::string& environment::_internal_the_measurement() const {
  return the_measurement_.GetNoArena();
}
inline void environment::_internal_set_the_measurement(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  the_measurement_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
}
inline void environment::set_the_measurement(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  the_measurement_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:environment.the_measurement)
}
inline void environment::set_the_measurement(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  the_measurement_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:environment.the_measurement)
}
inline void environment::set_the_measurement(const void* value, size_t size) {
  _has_bits_[0] |= 0x00000001u;
  the_measurement_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:environment.the_measurement)
}
inline std::string* environment::_internal_mutable_the_measurement() {
  _has_bits_[0] |= 0x00000001u;
  return the_measurement_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* environment::release_the_measurement() {
  // @@protoc_insertion_point(field_release:environment.the_measurement)
  if (!_internal_has_the_measurement()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return the_measurement_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void environment::set_allocated_the_measurement(std::string* the_measurement) {
  if (the_measurement != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  the_measurement_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), the_measurement);
  // @@protoc_insertion_point(field_set_allocated:environment.the_measurement)
}

// -------------------------------------------------------------------

// entity_message

// optional string entity_type = 1;
inline bool entity_message::_internal_has_entity_type() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool entity_message::has_entity_type() const {
  return _internal_has_entity_type();
}
inline void entity_message::clear_entity_type() {
  entity_type_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& entity_message::entity_type() const {
  // @@protoc_insertion_point(field_get:entity_message.entity_type)
  return _internal_entity_type();
}
inline void entity_message::set_entity_type(const std::string& value) {
  _internal_set_entity_type(value);
  // @@protoc_insertion_point(field_set:entity_message.entity_type)
}
inline std::string* entity_message::mutable_entity_type() {
  // @@protoc_insertion_point(field_mutable:entity_message.entity_type)
  return _internal_mutable_entity_type();
}
inline const std::string& entity_message::_internal_entity_type() const {
  return entity_type_.GetNoArena();
}
inline void entity_message::_internal_set_entity_type(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  entity_type_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
}
inline void entity_message::set_entity_type(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  entity_type_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:entity_message.entity_type)
}
inline void entity_message::set_entity_type(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  entity_type_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:entity_message.entity_type)
}
inline void entity_message::set_entity_type(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000001u;
  entity_type_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:entity_message.entity_type)
}
inline std::string* entity_message::_internal_mutable_entity_type() {
  _has_bits_[0] |= 0x00000001u;
  return entity_type_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* entity_message::release_entity_type() {
  // @@protoc_insertion_point(field_release:entity_message.entity_type)
  if (!_internal_has_entity_type()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return entity_type_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void entity_message::set_allocated_entity_type(std::string* entity_type) {
  if (entity_type != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  entity_type_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), entity_type);
  // @@protoc_insertion_point(field_set_allocated:entity_message.entity_type)
}

// optional .key_message key = 2;
inline bool entity_message::_internal_has_key() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || key_ != nullptr);
  return value;
}
inline bool entity_message::has_key() const {
  return _internal_has_key();
}
inline void entity_message::clear_key() {
  if (key_ != nullptr) key_->Clear();
  _has_bits_[0] &= ~0x00000004u;
}
inline const ::key_message& entity_message::_internal_key() const {
  const ::key_message* p = key_;
  return p != nullptr ? *p : *reinterpret_cast<const ::key_message*>(
      &::_key_message_default_instance_);
}
inline const ::key_message& entity_message::key() const {
  // @@protoc_insertion_point(field_get:entity_message.key)
  return _internal_key();
}
inline ::key_message* entity_message::release_key() {
  // @@protoc_insertion_point(field_release:entity_message.key)
  _has_bits_[0] &= ~0x00000004u;
  ::key_message* temp = key_;
  key_ = nullptr;
  return temp;
}
inline ::key_message* entity_message::_internal_mutable_key() {
  _has_bits_[0] |= 0x00000004u;
  if (key_ == nullptr) {
    auto* p = CreateMaybeMessage<::key_message>(GetArenaNoVirtual());
    key_ = p;
  }
  return key_;
}
inline ::key_message* entity_message::mutable_key() {
  // @@protoc_insertion_point(field_mutable:entity_message.key)
  return _internal_mutable_key();
}
inline void entity_message::set_allocated_key(::key_message* key) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete key_;
  }
  if (key) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      key = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, key, submessage_arena);
    }
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  key_ = key;
  // @@protoc_insertion_point(field_set_allocated:entity_message.key)
}

// optional bytes measurement = 3;
inline bool entity_message::_internal_has_measurement() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool entity_message::has_measurement() const {
  return _internal_has_measurement();
}
inline void entity_message::clear_measurement() {
  measurement_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& entity_message::measurement() const {
  // @@protoc_insertion_point(field_get:entity_message.measurement)
  return _internal_measurement();
}
inline void entity_message::set_measurement(const std::string& value) {
  _internal_set_measurement(value);
  // @@protoc_insertion_point(field_set:entity_message.measurement)
}
inline std::string* entity_message::mutable_measurement() {
  // @@protoc_insertion_point(field_mutable:entity_message.measurement)
  return _internal_mutable_measurement();
}
inline const std::string& entity_message::_internal_measurement() const {
  return measurement_.GetNoArena();
}
inline void entity_message::_internal_set_measurement(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  measurement_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
}
inline void entity_message::set_measurement(std::string&& value) {
  _has_bits_[0] |= 0x00000002u;
  measurement_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:entity_message.measurement)
}
inline void entity_message::set_measurement(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000002u;
  measurement_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:entity_message.measurement)
}
inline void entity_message::set_measurement(const void* value, size_t size) {
  _has_bits_[0] |= 0x00000002u;
  measurement_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:entity_message.measurement)
}
inline std::string* entity_message::_internal_mutable_measurement() {
  _has_bits_[0] |= 0x00000002u;
  return measurement_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* entity_message::release_measurement() {
  // @@protoc_insertion_point(field_release:entity_message.measurement)
  if (!_internal_has_measurement()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  return measurement_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void entity_message::set_allocated_measurement(std::string* measurement) {
  if (measurement != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  measurement_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), measurement);
  // @@protoc_insertion_point(field_set_allocated:entity_message.measurement)
}

// optional .platform platform_ent = 4;
inline bool entity_message::_internal_has_platform_ent() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  PROTOBUF_ASSUME(!value || platform_ent_ != nullptr);
  return value;
}
inline bool entity_message::has_platform_ent() const {
  return _internal_has_platform_ent();
}
inline void entity_message::clear_platform_ent() {
  if (platform_ent_ != nullptr) platform_ent_->Clear();
  _has_bits_[0] &= ~0x00000008u;
}
inline const ::platform& entity_message::_internal_platform_ent() const {
  const ::platform* p = platform_ent_;
  return p != nullptr ? *p : *reinterpret_cast<const ::platform*>(
      &::_platform_default_instance_);
}
inline const ::platform& entity_message::platform_ent() const {
  // @@protoc_insertion_point(field_get:entity_message.platform_ent)
  return _internal_platform_ent();
}
inline ::platform* entity_message::release_platform_ent() {
  // @@protoc_insertion_point(field_release:entity_message.platform_ent)
  _has_bits_[0] &= ~0x00000008u;
  ::platform* temp = platform_ent_;
  platform_ent_ = nullptr;
  return temp;
}
inline ::platform* entity_message::_internal_mutable_platform_ent() {
  _has_bits_[0] |= 0x00000008u;
  if (platform_ent_ == nullptr) {
    auto* p = CreateMaybeMessage<::platform>(GetArenaNoVirtual());
    platform_ent_ = p;
  }
  return platform_ent_;
}
inline ::platform* entity_message::mutable_platform_ent() {
  // @@protoc_insertion_point(field_mutable:entity_message.platform_ent)
  return _internal_mutable_platform_ent();
}
inline void entity_message::set_allocated_platform_ent(::platform* platform_ent) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete platform_ent_;
  }
  if (platform_ent) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      platform_ent = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, platform_ent, submessage_arena);
    }
    _has_bits_[0] |= 0x00000008u;
  } else {
    _has_bits_[0] &= ~0x00000008u;
  }
  platform_ent_ = platform_ent;
  // @@protoc_insertion_point(field_set_allocated:entity_message.platform_ent)
}

// optional .environment environment_ent = 5;
inline bool entity_message::_internal_has_environment_ent() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  PROTOBUF_ASSUME(!value || environment_ent_ != nullptr);
  return value;
}
inline bool entity_message::has_environment_ent() const {
  return _internal_has_environment_ent();
}
inline void entity_message::clear_environment_ent() {
  if (environment_ent_ != nullptr) environment_ent_->Clear();
  _has_bits_[0] &= ~0x00000010u;
}
inline const ::environment& entity_message::_internal_environment_ent() const {
  const ::environment* p = environment_ent_;
  return p != nullptr ? *p : *reinterpret_cast<const ::environment*>(
      &::_environment_default_instance_);
}
inline const ::environment& entity_message::environment_ent() const {
  // @@protoc_insertion_point(field_get:entity_message.environment_ent)
  return _internal_environment_ent();
}
inline ::environment* entity_message::release_environment_ent() {
  // @@protoc_insertion_point(field_release:entity_message.environment_ent)
  _has_bits_[0] &= ~0x00000010u;
  ::environment* temp = environment_ent_;
  environment_ent_ = nullptr;
  return temp;
}
inline ::environment* entity_message::_internal_mutable_environment_ent() {
  _has_bits_[0] |= 0x00000010u;
  if (environment_ent_ == nullptr) {
    auto* p = CreateMaybeMessage<::environment>(GetArenaNoVirtual());
    environment_ent_ = p;
  }
  return environment_ent_;
}
inline ::environment* entity_message::mutable_environment_ent() {
  // @@protoc_insertion_point(field_mutable:entity_message.environment_ent)
  return _internal_mutable_environment_ent();
}
inline void entity_message::set_allocated_environment_ent(::environment* environment_ent) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete environment_ent_;
  }
  if (environment_ent) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      environment_ent = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, environment_ent, submessage_arena);
    }
    _has_bits_[0] |= 0x00000010u;
  } else {
    _has_bits_[0] &= ~0x00000010u;
  }
  environment_ent_ = environment_ent;
  // @@protoc_insertion_point(field_set_allocated:entity_message.environment_ent)
}

// -------------------------------------------------------------------

// vse_clause

// optional .entity_message subject = 1;
inline bool vse_clause::_internal_has_subject() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || subject_ != nullptr);
  return value;
}
inline bool vse_clause::has_subject() const {
  return _internal_has_subject();
}
inline void vse_clause::clear_subject() {
  if (subject_ != nullptr) subject_->Clear();
  _has_bits_[0] &= ~0x00000002u;
}
inline const ::entity_message& vse_clause::_internal_subject() const {
  const ::entity_message* p = subject_;
  return p != nullptr ? *p : *reinterpret_cast<const ::entity_message*>(
      &::_entity_message_default_instance_);
}
inline const ::entity_message& vse_clause::subject() const {
  // @@protoc_insertion_point(field_get:vse_clause.subject)
  return _internal_subject();
}
inline ::entity_message* vse_clause::release_subject() {
  // @@protoc_insertion_point(field_release:vse_clause.subject)
  _has_bits_[0] &= ~0x00000002u;
  ::entity_message* temp = subject_;
  subject_ = nullptr;
  return temp;
}
inline ::entity_message* vse_clause::_internal_mutable_subject() {
  _has_bits_[0] |= 0x00000002u;
  if (subject_ == nullptr) {
    auto* p = CreateMaybeMessage<::entity_message>(GetArenaNoVirtual());
    subject_ = p;
  }
  return subject_;
}
inline ::entity_message* vse_clause::mutable_subject() {
  // @@protoc_insertion_point(field_mutable:vse_clause.subject)
  return _internal_mutable_subject();
}
inline void vse_clause::set_allocated_subject(::entity_message* subject) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete subject_;
  }
  if (subject) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      subject = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, subject, submessage_arena);
    }
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  subject_ = subject;
  // @@protoc_insertion_point(field_set_allocated:vse_clause.subject)
}

// optional string verb = 2;
inline bool vse_clause::_internal_has_verb() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool vse_clause::has_verb() const {
  return _internal_has_verb();
}
inline void vse_clause::clear_verb() {
  verb_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& vse_clause::verb() const {
  // @@protoc_insertion_point(field_get:vse_clause.verb)
  return _internal_verb();
}
inline void vse_clause::set_verb(const std::string& value) {
  _internal_set_verb(value);
  // @@protoc_insertion_point(field_set:vse_clause.verb)
}
inline std::string* vse_clause::mutable_verb() {
  // @@protoc_insertion_point(field_mutable:vse_clause.verb)
  return _internal_mutable_verb();
}
inline const std::string& vse_clause::_internal_verb() const {
  return verb_.GetNoArena();
}
inline void vse_clause::_internal_set_verb(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  verb_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
}
inline void vse_clause::set_verb(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  verb_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:vse_clause.verb)
}
inline void vse_clause::set_verb(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  verb_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:vse_clause.verb)
}
inline void vse_clause::set_verb(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000001u;
  verb_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:vse_clause.verb)
}
inline std::string* vse_clause::_internal_mutable_verb() {
  _has_bits_[0] |= 0x00000001u;
  return verb_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* vse_clause::release_verb() {
  // @@protoc_insertion_point(field_release:vse_clause.verb)
  if (!_internal_has_verb()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return verb_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void vse_clause::set_allocated_verb(std::string* verb) {
  if (verb != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  verb_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), verb);
  // @@protoc_insertion_point(field_set_allocated:vse_clause.verb)
}

// optional .entity_message object = 3;
inline bool vse_clause::_internal_has_object() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || object_ != nullptr);
  return value;
}
inline bool vse_clause::has_object() const {
  return _internal_has_object();
}
inline void vse_clause::clear_object() {
  if (object_ != nullptr) object_->Clear();
  _has_bits_[0] &= ~0x00000004u;
}
inline const ::entity_message& vse_clause::_internal_object() const {
  const ::entity_message* p = object_;
  return p != nullptr ? *p : *reinterpret_cast<const ::entity_message*>(
      &::_entity_message_default_instance_);
}
inline const ::entity_message& vse_clause::object() const {
  // @@protoc_insertion_point(field_get:vse_clause.object)
  return _internal_object();
}
inline ::entity_message* vse_clause::release_object() {
  // @@protoc_insertion_point(field_release:vse_clause.object)
  _has_bits_[0] &= ~0x00000004u;
  ::entity_message* temp = object_;
  object_ = nullptr;
  return temp;
}
inline ::entity_message* vse_clause::_internal_mutable_object() {
  _has_bits_[0] |= 0x00000004u;
  if (object_ == nullptr) {
    auto* p = CreateMaybeMessage<::entity_message>(GetArenaNoVirtual());
    object_ = p;
  }
  return object_;
}
inline ::entity_message* vse_clause::mutable_object() {
  // @@protoc_insertion_point(field_mutable:vse_clause.object)
  return _internal_mutable_object();
}
inline void vse_clause::set_allocated_object(::entity_message* object) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete object_;
  }
  if (object) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      object = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, object, submessage_arena);
    }
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  object_ = object;
  // @@protoc_insertion_point(field_set_allocated:vse_clause.object)
}

// optional .vse_clause clause = 4;
inline bool vse_clause::_internal_has_clause() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  PROTOBUF_ASSUME(!value || clause_ != nullptr);
  return value;
}
inline bool vse_clause::has_clause() const {
  return _internal_has_clause();
}
inline void vse_clause::clear_clause() {
  if (clause_ != nullptr) clause_->Clear();
  _has_bits_[0] &= ~0x00000008u;
}
inline const ::vse_clause& vse_clause::_internal_clause() const {
  const ::vse_clause* p = clause_;
  return p != nullptr ? *p : *reinterpret_cast<const ::vse_clause*>(
      &::_vse_clause_default_instance_);
}
inline const ::vse_clause& vse_clause::clause() const {
  // @@protoc_insertion_point(field_get:vse_clause.clause)
  return _internal_clause();
}
inline ::vse_clause* vse_clause::release_clause() {
  // @@protoc_insertion_point(field_release:vse_clause.clause)
  _has_bits_[0] &= ~0x00000008u;
  ::vse_clause* temp = clause_;
  clause_ = nullptr;
  return temp;
}
inline ::vse_clause* vse_clause::_internal_mutable_clause() {
  _has_bits_[0] |= 0x00000008u;
  if (clause_ == nullptr) {
    auto* p = CreateMaybeMessage<::vse_clause>(GetArenaNoVirtual());
    clause_ = p;
  }
  return clause_;
}
inline ::vse_clause* vse_clause::mutable_clause() {
  // @@protoc_insertion_point(field_mutable:vse_clause.clause)
  return _internal_mutable_clause();
}
inline void vse_clause::set_allocated_clause(::vse_clause* clause) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete clause_;
  }
  if (clause) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      clause = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, clause, submessage_arena);
    }
    _has_bits_[0] |= 0x00000008u;
  } else {
    _has_bits_[0] &= ~0x00000008u;
  }
  clause_ = clause;
  // @@protoc_insertion_point(field_set_allocated:vse_clause.clause)
}

// -------------------------------------------------------------------

// vse_clauses

// repeated .vse_clause clauses = 1;
inline int vse_clauses::_internal_clauses_size() const {
  return clauses_.size();
}
inline int vse_clauses::clauses_size() const {
  return _internal_clauses_size();
}
inline void vse_clauses::clear_clauses() {
  clauses_.Clear();
}
inline ::vse_clause* vse_clauses::mutable_clauses(int index) {
  // @@protoc_insertion_point(field_mutable:vse_clauses.clauses)
  return clauses_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vse_clause >*
vse_clauses::mutable_clauses() {
  // @@protoc_insertion_point(field_mutable_list:vse_clauses.clauses)
  return &clauses_;
}
inline const ::vse_clause& vse_clauses::_internal_clauses(int index) const {
  return clauses_.Get(index);
}
inline const ::vse_clause& vse_clauses::clauses(int index) const {
  // @@protoc_insertion_point(field_get:vse_clauses.clauses)
  return _internal_clauses(index);
}
inline ::vse_clause* vse_clauses::_internal_add_clauses() {
  return clauses_.Add();
}
inline ::vse_clause* vse_clauses::add_clauses() {
  // @@protoc_insertion_point(field_add:vse_clauses.clauses)
  return _internal_add_clauses();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vse_clause >&
vse_clauses::clauses() const {
  // @@protoc_insertion_point(field_list:vse_clauses.clauses)
  return clauses_;
}

// -------------------------------------------------------------------

// claim_message

// optional string claim_format = 1;
inline bool claim_message::_internal_has_claim_format() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool claim_message::has_claim_format() const {
  return _internal_has_claim_format();
}
inline void claim_message::clear_claim_format() {
  claim_format_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& claim_message::claim_format() const {
  // @@protoc_insertion_point(field_get:claim_message.claim_format)
  return _internal_claim_format();
}
inline void claim_message::set_claim_format(const std::string& value) {
  _internal_set_claim_format(value);
  // @@protoc_insertion_point(field_set:claim_message.claim_format)
}
inline std::string* claim_message::mutable_claim_format() {
  // @@protoc_insertion_point(field_mutable:claim_message.claim_format)
  return _internal_mutable_claim_format();
}
inline const std::string& claim_message::_internal_claim_format() const {
  return claim_format_.GetNoArena();
}
inline void claim_message::_internal_set_claim_format(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  claim_format_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
}
inline void claim_message::set_claim_format(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  claim_format_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:claim_message.claim_format)
}
inline void claim_message::set_claim_format(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  claim_format_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:claim_message.claim_format)
}
inline void claim_message::set_claim_format(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000001u;
  claim_format_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:claim_message.claim_format)
}
inline std::string* claim_message::_internal_mutable_claim_format() {
  _has_bits_[0] |= 0x00000001u;
  return claim_format_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* claim_message::release_claim_format() {
  // @@protoc_insertion_point(field_release:claim_message.claim_format)
  if (!_internal_has_claim_format()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return claim_format_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void claim_message::set_allocated_claim_format(std::string* claim_format) {
  if (claim_format != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  claim_format_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), claim_format);
  // @@protoc_insertion_point(field_set_allocated:claim_message.claim_format)
}

// optional string claim_descriptor = 2;
inline bool claim_message::_internal_has_claim_descriptor() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool claim_message::has_claim_descriptor() const {
  return _internal_has_claim_descriptor();
}
inline void claim_message::clear_claim_descriptor() {
  claim_descriptor_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& claim_message::claim_descriptor() const {
  // @@protoc_insertion_point(field_get:claim_message.claim_descriptor)
  return _internal_claim_descriptor();
}
inline void claim_message::set_claim_descriptor(const std::string& value) {
  _internal_set_claim_descriptor(value);
  // @@protoc_insertion_point(field_set:claim_message.claim_descriptor)
}
inline std::string* claim_message::mutable_claim_descriptor() {
  // @@protoc_insertion_point(field_mutable:claim_message.claim_descriptor)
  return _internal_mutable_claim_descriptor();
}
inline const std::string& claim_message::_internal_claim_descriptor() const {
  return claim_descriptor_.GetNoArena();
}
inline void claim_message::_internal_set_claim_descriptor(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  claim_descriptor_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
}
inline void claim_message::set_claim_descriptor(std::string&& value) {
  _has_bits_[0] |= 0x00000002u;
  claim_descriptor_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:claim_message.claim_descriptor)
}
inline void claim_message::set_claim_descriptor(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000002u;
  claim_descriptor_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:claim_message.claim_descriptor)
}
inline void claim_message::set_claim_descriptor(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000002u;
  claim_descriptor_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:claim_message.claim_descriptor)
}
inline std::string* claim_message::_internal_mutable_claim_descriptor() {
  _has_bits_[0] |= 0x00000002u;
  return claim_descriptor_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* claim_message::release_claim_descriptor() {
  // @@protoc_insertion_point(field_release:claim_message.claim_descriptor)
  if (!_internal_has_claim_descriptor()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  return claim_descriptor_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void claim_message::set_allocated_claim_descriptor(std::string* claim_descriptor) {
  if (claim_descriptor != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  claim_descriptor_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), claim_descriptor);
  // @@protoc_insertion_point(field_set_allocated:claim_message.claim_descriptor)
}

// optional string not_before = 3;
inline bool claim_message::_internal_has_not_before() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool claim_message::has_not_before() const {
  return _internal_has_not_before();
}
inline void claim_message::clear_not_before() {
  not_before_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000004u;
}
inline const std::string& claim_message::not_before() const {
  // @@protoc_insertion_point(field_get:claim_message.not_before)
  return _internal_not_before();
}
inline void claim_message::set_not_before(const std::string& value) {
  _internal_set_not_before(value);
  // @@protoc_insertion_point(field_set:claim_message.not_before)
}
inline std::string* claim_message::mutable_not_before() {
  // @@protoc_insertion_point(field_mutable:claim_message.not_before)
  return _internal_mutable_not_before();
}
inline const std::string& claim_message::_internal_not_before() const {
  return not_before_.GetNoArena();
}
inline void claim_message::_internal_set_not_before(const std::string& value) {
  _has_bits_[0] |= 0x00000004u;
  not_before_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
}
inline void claim_message::set_not_before(std::string&& value) {
  _has_bits_[0] |= 0x00000004u;
  not_before_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:claim_message.not_before)
}
inline void claim_message::set_not_before(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000004u;
  not_before_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:claim_message.not_before)
}
inline void claim_message::set_not_before(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000004u;
  not_before_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:claim_message.not_before)
}
inline std::string* claim_message::_internal_mutable_not_before() {
  _has_bits_[0] |= 0x00000004u;
  return not_before_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* claim_message::release_not_before() {
  // @@protoc_insertion_point(field_release:claim_message.not_before)
  if (!_internal_has_not_before()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000004u;
  return not_before_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void claim_message::set_allocated_not_before(std::string* not_before) {
  if (not_before != nullptr) {
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  not_before_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), not_before);
  // @@protoc_insertion_point(field_set_allocated:claim_message.not_before)
}

// optional string not_after = 4;
inline bool claim_message::_internal_has_not_after() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool claim_message::has_not_after() const {
  return _internal_has_not_after();
}
inline void claim_message::clear_not_after() {
  not_after_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000008u;
}
inline const std::string& claim_message::not_after() const {
  // @@protoc_insertion_point(field_get:claim_message.not_after)
  return _internal_not_after();
}
inline void claim_message::set_not_after(const std::string& value) {
  _internal_set_not_after(value);
  // @@protoc_insertion_point(field_set:claim_message.not_after)
}
inline std::string* claim_message::mutable_not_after() {
  // @@protoc_insertion_point(field_mutable:claim_message.not_after)
  return _internal_mutable_not_after();
}
inline const std::string& claim_message::_internal_not_after() const {
  return not_after_.GetNoArena();
}
inline void claim_message::_internal_set_not_after(const std::string& value) {
  _has_bits_[0] |= 0x00000008u;
  not_after_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
}
inline void claim_message::set_not_after(std::string&& value) {
  _has_bits_[0] |= 0x00000008u;
  not_after_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:claim_message.not_after)
}
inline void claim_message::set_not_after(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000008u;
  not_after_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:claim_message.not_after)
}
inline void claim_message::set_not_after(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000008u;
  not_after_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:claim_message.not_after)
}
inline std::string* claim_message::_internal_mutable_not_after() {
  _has_bits_[0] |= 0x00000008u;
  return not_after_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* claim_message::release_not_after() {
  // @@protoc_insertion_point(field_release:claim_message.not_after)
  if (!_internal_has_not_after()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000008u;
  return not_after_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void claim_message::set_allocated_not_after(std::string* not_after) {
  if (not_after != nullptr) {
    _has_bits_[0] |= 0x00000008u;
  } else {
    _has_bits_[0] &= ~0x00000008u;
  }
  not_after_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), not_after);
  // @@protoc_insertion_point(field_set_allocated:claim_message.not_after)
}

// optional bytes serialized_claim = 5;
inline bool claim_message::_internal_has_serialized_claim() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool claim_message::has_serialized_claim() const {
  return _internal_has_serialized_claim();
}
inline void claim_message::clear_serialized_claim() {
  serialized_claim_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000010u;
}
inline const std::string& claim_message::serialized_claim() const {
  // @@protoc_insertion_point(field_get:claim_message.serialized_claim)
  return _internal_serialized_claim();
}
inline void claim_message::set_serialized_claim(const std::string& value) {
  _internal_set_serialized_claim(value);
  // @@protoc_insertion_point(field_set:claim_message.serialized_claim)
}
inline std::string* claim_message::mutable_serialized_claim() {
  // @@protoc_insertion_point(field_mutable:claim_message.serialized_claim)
  return _internal_mutable_serialized_claim();
}
inline const std::string& claim_message::_internal_serialized_claim() const {
  return serialized_claim_.GetNoArena();
}
inline void claim_message::_internal_set_serialized_claim(const std::string& value) {
  _has_bits_[0] |= 0x00000010u;
  serialized_claim_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
}
inline void claim_message::set_serialized_claim(std::string&& value) {
  _has_bits_[0] |= 0x00000010u;
  serialized_claim_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:claim_message.serialized_claim)
}
inline void claim_message::set_serialized_claim(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000010u;
  serialized_claim_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:claim_message.serialized_claim)
}
inline void claim_message::set_serialized_claim(const void* value, size_t size) {
  _has_bits_[0] |= 0x00000010u;
  serialized_claim_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:claim_message.serialized_claim)
}
inline std::string* claim_message::_internal_mutable_serialized_claim() {
  _has_bits_[0] |= 0x00000010u;
  return serialized_claim_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* claim_message::release_serialized_claim() {
  // @@protoc_insertion_point(field_release:claim_message.serialized_claim)
  if (!_internal_has_serialized_claim()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000010u;
  return serialized_claim_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void claim_message::set_allocated_serialized_claim(std::string* serialized_claim) {
  if (serialized_claim != nullptr) {
    _has_bits_[0] |= 0x00000010u;
  } else {
    _has_bits_[0] &= ~0x00000010u;
  }
  serialized_claim_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), serialized_claim);
  // @@protoc_insertion_point(field_set_allocated:claim_message.serialized_claim)
}

// -------------------------------------------------------------------

// attestation_user_data

// optional string enclave_type = 1;
inline bool attestation_user_data::_internal_has_enclave_type() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool attestation_user_data::has_enclave_type() const {
  return _internal_has_enclave_type();
}
inline void attestation_user_data::clear_enclave_type() {
  enclave_type_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& attestation_user_data::enclave_type() const {
  // @@protoc_insertion_point(field_get:attestation_user_data.enclave_type)
  return _internal_enclave_type();
}
inline void attestation_user_data::set_enclave_type(const std::string& value) {
  _internal_set_enclave_type(value);
  // @@protoc_insertion_point(field_set:attestation_user_data.enclave_type)
}
inline std::string* attestation_user_data::mutable_enclave_type() {
  // @@protoc_insertion_point(field_mutable:attestation_user_data.enclave_type)
  return _internal_mutable_enclave_type();
}
inline const std::string& attestation_user_data::_internal_enclave_type() const {
  return enclave_type_.GetNoArena();
}
inline void attestation_user_data::_internal_set_enclave_type(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  enclave_type_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
}
inline void attestation_user_data::set_enclave_type(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  enclave_type_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:attestation_user_data.enclave_type)
}
inline void attestation_user_data::set_enclave_type(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  enclave_type_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:attestation_user_data.enclave_type)
}
inline void attestation_user_data::set_enclave_type(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000001u;
  enclave_type_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:attestation_user_data.enclave_type)
}
inline std::string* attestation_user_data::_internal_mutable_enclave_type() {
  _has_bits_[0] |= 0x00000001u;
  return enclave_type_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* attestation_user_data::release_enclave_type() {
  // @@protoc_insertion_point(field_release:attestation_user_data.enclave_type)
  if (!_internal_has_enclave_type()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return enclave_type_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void attestation_user_data::set_allocated_enclave_type(std::string* enclave_type) {
  if (enclave_type != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  enclave_type_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), enclave_type);
  // @@protoc_insertion_point(field_set_allocated:attestation_user_data.enclave_type)
}

// optional string time = 2;
inline bool attestation_user_data::_internal_has_time() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool attestation_user_data::has_time() const {
  return _internal_has_time();
}
inline void attestation_user_data::clear_time() {
  time_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& attestation_user_data::time() const {
  // @@protoc_insertion_point(field_get:attestation_user_data.time)
  return _internal_time();
}
inline void attestation_user_data::set_time(const std::string& value) {
  _internal_set_time(value);
  // @@protoc_insertion_point(field_set:attestation_user_data.time)
}
inline std::string* attestation_user_data::mutable_time() {
  // @@protoc_insertion_point(field_mutable:attestation_user_data.time)
  return _internal_mutable_time();
}
inline const std::string& attestation_user_data::_internal_time() const {
  return time_.GetNoArena();
}
inline void attestation_user_data::_internal_set_time(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  time_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
}
inline void attestation_user_data::set_time(std::string&& value) {
  _has_bits_[0] |= 0x00000002u;
  time_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:attestation_user_data.time)
}
inline void attestation_user_data::set_time(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000002u;
  time_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:attestation_user_data.time)
}
inline void attestation_user_data::set_time(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000002u;
  time_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:attestation_user_data.time)
}
inline std::string* attestation_user_data::_internal_mutable_time() {
  _has_bits_[0] |= 0x00000002u;
  return time_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* attestation_user_data::release_time() {
  // @@protoc_insertion_point(field_release:attestation_user_data.time)
  if (!_internal_has_time()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  return time_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void attestation_user_data::set_allocated_time(std::string* time) {
  if (time != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  time_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), time);
  // @@protoc_insertion_point(field_set_allocated:attestation_user_data.time)
}

// optional .key_message enclave_key = 3;
inline bool attestation_user_data::_internal_has_enclave_key() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || enclave_key_ != nullptr);
  return value;
}
inline bool attestation_user_data::has_enclave_key() const {
  return _internal_has_enclave_key();
}
inline void attestation_user_data::clear_enclave_key() {
  if (enclave_key_ != nullptr) enclave_key_->Clear();
  _has_bits_[0] &= ~0x00000004u;
}
inline const ::key_message& attestation_user_data::_internal_enclave_key() const {
  const ::key_message* p = enclave_key_;
  return p != nullptr ? *p : *reinterpret_cast<const ::key_message*>(
      &::_key_message_default_instance_);
}
inline const ::key_message& attestation_user_data::enclave_key() const {
  // @@protoc_insertion_point(field_get:attestation_user_data.enclave_key)
  return _internal_enclave_key();
}
inline ::key_message* attestation_user_data::release_enclave_key() {
  // @@protoc_insertion_point(field_release:attestation_user_data.enclave_key)
  _has_bits_[0] &= ~0x00000004u;
  ::key_message* temp = enclave_key_;
  enclave_key_ = nullptr;
  return temp;
}
inline ::key_message* attestation_user_data::_internal_mutable_enclave_key() {
  _has_bits_[0] |= 0x00000004u;
  if (enclave_key_ == nullptr) {
    auto* p = CreateMaybeMessage<::key_message>(GetArenaNoVirtual());
    enclave_key_ = p;
  }
  return enclave_key_;
}
inline ::key_message* attestation_user_data::mutable_enclave_key() {
  // @@protoc_insertion_point(field_mutable:attestation_user_data.enclave_key)
  return _internal_mutable_enclave_key();
}
inline void attestation_user_data::set_allocated_enclave_key(::key_message* enclave_key) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete enclave_key_;
  }
  if (enclave_key) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      enclave_key = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, enclave_key, submessage_arena);
    }
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  enclave_key_ = enclave_key;
  // @@protoc_insertion_point(field_set_allocated:attestation_user_data.enclave_key)
}

// optional .key_message policy_key = 4;
inline bool attestation_user_data::_internal_has_policy_key() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  PROTOBUF_ASSUME(!value || policy_key_ != nullptr);
  return value;
}
inline bool attestation_user_data::has_policy_key() const {
  return _internal_has_policy_key();
}
inline void attestation_user_data::clear_policy_key() {
  if (policy_key_ != nullptr) policy_key_->Clear();
  _has_bits_[0] &= ~0x00000008u;
}
inline const ::key_message& attestation_user_data::_internal_policy_key() const {
  const ::key_message* p = policy_key_;
  return p != nullptr ? *p : *reinterpret_cast<const ::key_message*>(
      &::_key_message_default_instance_);
}
inline const ::key_message& attestation_user_data::policy_key() const {
  // @@protoc_insertion_point(field_get:attestation_user_data.policy_key)
  return _internal_policy_key();
}
inline ::key_message* attestation_user_data::release_policy_key() {
  // @@protoc_insertion_point(field_release:attestation_user_data.policy_key)
  _has_bits_[0] &= ~0x00000008u;
  ::key_message* temp = policy_key_;
  policy_key_ = nullptr;
  return temp;
}
inline ::key_message* attestation_user_data::_internal_mutable_policy_key() {
  _has_bits_[0] |= 0x00000008u;
  if (policy_key_ == nullptr) {
    auto* p = CreateMaybeMessage<::key_message>(GetArenaNoVirtual());
    policy_key_ = p;
  }
  return policy_key_;
}
inline ::key_message* attestation_user_data::mutable_policy_key() {
  // @@protoc_insertion_point(field_mutable:attestation_user_data.policy_key)
  return _internal_mutable_policy_key();
}
inline void attestation_user_data::set_allocated_policy_key(::key_message* policy_key) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete policy_key_;
  }
  if (policy_key) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      policy_key = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, policy_key, submessage_arena);
    }
    _has_bits_[0] |= 0x00000008u;
  } else {
    _has_bits_[0] &= ~0x00000008u;
  }
  policy_key_ = policy_key;
  // @@protoc_insertion_point(field_set_allocated:attestation_user_data.policy_key)
}

// -------------------------------------------------------------------

// vse_attestation_report_info

// optional string enclave_type = 1;
inline bool vse_attestation_report_info::_internal_has_enclave_type() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool vse_attestation_report_info::has_enclave_type() const {
  return _internal_has_enclave_type();
}
inline void vse_attestation_report_info::clear_enclave_type() {
  enclave_type_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& vse_attestation_report_info::enclave_type() const {
  // @@protoc_insertion_point(field_get:vse_attestation_report_info.enclave_type)
  return _internal_enclave_type();
}
inline void vse_attestation_report_info::set_enclave_type(const std::string& value) {
  _internal_set_enclave_type(value);
  // @@protoc_insertion_point(field_set:vse_attestation_report_info.enclave_type)
}
inline std::string* vse_attestation_report_info::mutable_enclave_type() {
  // @@protoc_insertion_point(field_mutable:vse_attestation_report_info.enclave_type)
  return _internal_mutable_enclave_type();
}
inline const std::string& vse_attestation_report_info::_internal_enclave_type() const {
  return enclave_type_.GetNoArena();
}
inline void vse_attestation_report_info::_internal_set_enclave_type(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  enclave_type_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
}
inline void vse_attestation_report_info::set_enclave_type(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  enclave_type_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:vse_attestation_report_info.enclave_type)
}
inline void vse_attestation_report_info::set_enclave_type(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  enclave_type_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:vse_attestation_report_info.enclave_type)
}
inline void vse_attestation_report_info::set_enclave_type(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000001u;
  enclave_type_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:vse_attestation_report_info.enclave_type)
}
inline std::string* vse_attestation_report_info::_internal_mutable_enclave_type() {
  _has_bits_[0] |= 0x00000001u;
  return enclave_type_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* vse_attestation_report_info::release_enclave_type() {
  // @@protoc_insertion_point(field_release:vse_attestation_report_info.enclave_type)
  if (!_internal_has_enclave_type()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return enclave_type_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void vse_attestation_report_info::set_allocated_enclave_type(std::string* enclave_type) {
  if (enclave_type != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  enclave_type_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), enclave_type);
  // @@protoc_insertion_point(field_set_allocated:vse_attestation_report_info.enclave_type)
}

// optional bytes verified_measurement = 2;
inline bool vse_attestation_report_info::_internal_has_verified_measurement() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool vse_attestation_report_info::has_verified_measurement() const {
  return _internal_has_verified_measurement();
}
inline void vse_attestation_report_info::clear_verified_measurement() {
  verified_measurement_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& vse_attestation_report_info::verified_measurement() const {
  // @@protoc_insertion_point(field_get:vse_attestation_report_info.verified_measurement)
  return _internal_verified_measurement();
}
inline void vse_attestation_report_info::set_verified_measurement(const std::string& value) {
  _internal_set_verified_measurement(value);
  // @@protoc_insertion_point(field_set:vse_attestation_report_info.verified_measurement)
}
inline std::string* vse_attestation_report_info::mutable_verified_measurement() {
  // @@protoc_insertion_point(field_mutable:vse_attestation_report_info.verified_measurement)
  return _internal_mutable_verified_measurement();
}
inline const std::string& vse_attestation_report_info::_internal_verified_measurement() const {
  return verified_measurement_.GetNoArena();
}
inline void vse_attestation_report_info::_internal_set_verified_measurement(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  verified_measurement_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
}
inline void vse_attestation_report_info::set_verified_measurement(std::string&& value) {
  _has_bits_[0] |= 0x00000002u;
  verified_measurement_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:vse_attestation_report_info.verified_measurement)
}
inline void vse_attestation_report_info::set_verified_measurement(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000002u;
  verified_measurement_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:vse_attestation_report_info.verified_measurement)
}
inline void vse_attestation_report_info::set_verified_measurement(const void* value, size_t size) {
  _has_bits_[0] |= 0x00000002u;
  verified_measurement_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:vse_attestation_report_info.verified_measurement)
}
inline std::string* vse_attestation_report_info::_internal_mutable_verified_measurement() {
  _has_bits_[0] |= 0x00000002u;
  return verified_measurement_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* vse_attestation_report_info::release_verified_measurement() {
  // @@protoc_insertion_point(field_release:vse_attestation_report_info.verified_measurement)
  if (!_internal_has_verified_measurement()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  return verified_measurement_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void vse_attestation_report_info::set_allocated_verified_measurement(std::string* verified_measurement) {
  if (verified_measurement != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  verified_measurement_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), verified_measurement);
  // @@protoc_insertion_point(field_set_allocated:vse_attestation_report_info.verified_measurement)
}

// optional string not_before = 3;
inline bool vse_attestation_report_info::_internal_has_not_before() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool vse_attestation_report_info::has_not_before() const {
  return _internal_has_not_before();
}
inline void vse_attestation_report_info::clear_not_before() {
  not_before_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000004u;
}
inline const std::string& vse_attestation_report_info::not_before() const {
  // @@protoc_insertion_point(field_get:vse_attestation_report_info.not_before)
  return _internal_not_before();
}
inline void vse_attestation_report_info::set_not_before(const std::string& value) {
  _internal_set_not_before(value);
  // @@protoc_insertion_point(field_set:vse_attestation_report_info.not_before)
}
inline std::string* vse_attestation_report_info::mutable_not_before() {
  // @@protoc_insertion_point(field_mutable:vse_attestation_report_info.not_before)
  return _internal_mutable_not_before();
}
inline const std::string& vse_attestation_report_info::_internal_not_before() const {
  return not_before_.GetNoArena();
}
inline void vse_attestation_report_info::_internal_set_not_before(const std::string& value) {
  _has_bits_[0] |= 0x00000004u;
  not_before_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
}
inline void vse_attestation_report_info::set_not_before(std::string&& value) {
  _has_bits_[0] |= 0x00000004u;
  not_before_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:vse_attestation_report_info.not_before)
}
inline void vse_attestation_report_info::set_not_before(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000004u;
  not_before_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:vse_attestation_report_info.not_before)
}
inline void vse_attestation_report_info::set_not_before(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000004u;
  not_before_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:vse_attestation_report_info.not_before)
}
inline std::string* vse_attestation_report_info::_internal_mutable_not_before() {
  _has_bits_[0] |= 0x00000004u;
  return not_before_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* vse_attestation_report_info::release_not_before() {
  // @@protoc_insertion_point(field_release:vse_attestation_report_info.not_before)
  if (!_internal_has_not_before()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000004u;
  return not_before_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void vse_attestation_report_info::set_allocated_not_before(std::string* not_before) {
  if (not_before != nullptr) {
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  not_before_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), not_before);
  // @@protoc_insertion_point(field_set_allocated:vse_attestation_report_info.not_before)
}

// optional string not_after = 4;
inline bool vse_attestation_report_info::_internal_has_not_after() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool vse_attestation_report_info::has_not_after() const {
  return _internal_has_not_after();
}
inline void vse_attestation_report_info::clear_not_after() {
  not_after_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000008u;
}
inline const std::string& vse_attestation_report_info::not_after() const {
  // @@protoc_insertion_point(field_get:vse_attestation_report_info.not_after)
  return _internal_not_after();
}
inline void vse_attestation_report_info::set_not_after(const std::string& value) {
  _internal_set_not_after(value);
  // @@protoc_insertion_point(field_set:vse_attestation_report_info.not_after)
}
inline std::string* vse_attestation_report_info::mutable_not_after() {
  // @@protoc_insertion_point(field_mutable:vse_attestation_report_info.not_after)
  return _internal_mutable_not_after();
}
inline const std::string& vse_attestation_report_info::_internal_not_after() const {
  return not_after_.GetNoArena();
}
inline void vse_attestation_report_info::_internal_set_not_after(const std::string& value) {
  _has_bits_[0] |= 0x00000008u;
  not_after_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
}
inline void vse_attestation_report_info::set_not_after(std::string&& value) {
  _has_bits_[0] |= 0x00000008u;
  not_after_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:vse_attestation_report_info.not_after)
}
inline void vse_attestation_report_info::set_not_after(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000008u;
  not_after_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:vse_attestation_report_info.not_after)
}
inline void vse_attestation_report_info::set_not_after(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000008u;
  not_after_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:vse_attestation_report_info.not_after)
}
inline std::string* vse_attestation_report_info::_internal_mutable_not_after() {
  _has_bits_[0] |= 0x00000008u;
  return not_after_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* vse_attestation_report_info::release_not_after() {
  // @@protoc_insertion_point(field_release:vse_attestation_report_info.not_after)
  if (!_internal_has_not_after()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000008u;
  return not_after_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void vse_attestation_report_info::set_allocated_not_after(std::string* not_after) {
  if (not_after != nullptr) {
    _has_bits_[0] |= 0x00000008u;
  } else {
    _has_bits_[0] &= ~0x00000008u;
  }
  not_after_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), not_after);
  // @@protoc_insertion_point(field_set_allocated:vse_attestation_report_info.not_after)
}

// optional bytes user_data = 5;
inline bool vse_attestation_report_info::_internal_has_user_data() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool vse_attestation_report_info::has_user_data() const {
  return _internal_has_user_data();
}
inline void vse_attestation_report_info::clear_user_data() {
  user_data_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000010u;
}
inline const std::string& vse_attestation_report_info::user_data() const {
  // @@protoc_insertion_point(field_get:vse_attestation_report_info.user_data)
  return _internal_user_data();
}
inline void vse_attestation_report_info::set_user_data(const std::string& value) {
  _internal_set_user_data(value);
  // @@protoc_insertion_point(field_set:vse_attestation_report_info.user_data)
}
inline std::string* vse_attestation_report_info::mutable_user_data() {
  // @@protoc_insertion_point(field_mutable:vse_attestation_report_info.user_data)
  return _internal_mutable_user_data();
}
inline const std::string& vse_attestation_report_info::_internal_user_data() const {
  return user_data_.GetNoArena();
}
inline void vse_attestation_report_info::_internal_set_user_data(const std::string& value) {
  _has_bits_[0] |= 0x00000010u;
  user_data_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
}
inline void vse_attestation_report_info::set_user_data(std::string&& value) {
  _has_bits_[0] |= 0x00000010u;
  user_data_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:vse_attestation_report_info.user_data)
}
inline void vse_attestation_report_info::set_user_data(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000010u;
  user_data_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:vse_attestation_report_info.user_data)
}
inline void vse_attestation_report_info::set_user_data(const void* value, size_t size) {
  _has_bits_[0] |= 0x00000010u;
  user_data_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:vse_attestation_report_info.user_data)
}
inline std::string* vse_attestation_report_info::_internal_mutable_user_data() {
  _has_bits_[0] |= 0x00000010u;
  return user_data_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* vse_attestation_report_info::release_user_data() {
  // @@protoc_insertion_point(field_release:vse_attestation_report_info.user_data)
  if (!_internal_has_user_data()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000010u;
  return user_data_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void vse_attestation_report_info::set_allocated_user_data(std::string* user_data) {
  if (user_data != nullptr) {
    _has_bits_[0] |= 0x00000010u;
  } else {
    _has_bits_[0] &= ~0x00000010u;
  }
  user_data_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), user_data);
  // @@protoc_insertion_point(field_set_allocated:vse_attestation_report_info.user_data)
}

// -------------------------------------------------------------------

// signed_report

// optional string report_format = 1;
inline bool signed_report::_internal_has_report_format() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool signed_report::has_report_format() const {
  return _internal_has_report_format();
}
inline void signed_report::clear_report_format() {
  report_format_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& signed_report::report_format() const {
  // @@protoc_insertion_point(field_get:signed_report.report_format)
  return _internal_report_format();
}
inline void signed_report::set_report_format(const std::string& value) {
  _internal_set_report_format(value);
  // @@protoc_insertion_point(field_set:signed_report.report_format)
}
inline std::string* signed_report::mutable_report_format() {
  // @@protoc_insertion_point(field_mutable:signed_report.report_format)
  return _internal_mutable_report_format();
}
inline const std::string& signed_report::_internal_report_format() const {
  return report_format_.GetNoArena();
}
inline void signed_report::_internal_set_report_format(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  report_format_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
}
inline void signed_report::set_report_format(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  report_format_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:signed_report.report_format)
}
inline void signed_report::set_report_format(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  report_format_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:signed_report.report_format)
}
inline void signed_report::set_report_format(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000001u;
  report_format_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:signed_report.report_format)
}
inline std::string* signed_report::_internal_mutable_report_format() {
  _has_bits_[0] |= 0x00000001u;
  return report_format_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* signed_report::release_report_format() {
  // @@protoc_insertion_point(field_release:signed_report.report_format)
  if (!_internal_has_report_format()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return report_format_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void signed_report::set_allocated_report_format(std::string* report_format) {
  if (report_format != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  report_format_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), report_format);
  // @@protoc_insertion_point(field_set_allocated:signed_report.report_format)
}

// optional bytes report = 2;
inline bool signed_report::_internal_has_report() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool signed_report::has_report() const {
  return _internal_has_report();
}
inline void signed_report::clear_report() {
  report_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& signed_report::report() const {
  // @@protoc_insertion_point(field_get:signed_report.report)
  return _internal_report();
}
inline void signed_report::set_report(const std::string& value) {
  _internal_set_report(value);
  // @@protoc_insertion_point(field_set:signed_report.report)
}
inline std::string* signed_report::mutable_report() {
  // @@protoc_insertion_point(field_mutable:signed_report.report)
  return _internal_mutable_report();
}
inline const std::string& signed_report::_internal_report() const {
  return report_.GetNoArena();
}
inline void signed_report::_internal_set_report(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  report_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
}
inline void signed_report::set_report(std::string&& value) {
  _has_bits_[0] |= 0x00000002u;
  report_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:signed_report.report)
}
inline void signed_report::set_report(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000002u;
  report_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:signed_report.report)
}
inline void signed_report::set_report(const void* value, size_t size) {
  _has_bits_[0] |= 0x00000002u;
  report_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:signed_report.report)
}
inline std::string* signed_report::_internal_mutable_report() {
  _has_bits_[0] |= 0x00000002u;
  return report_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* signed_report::release_report() {
  // @@protoc_insertion_point(field_release:signed_report.report)
  if (!_internal_has_report()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  return report_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void signed_report::set_allocated_report(std::string* report) {
  if (report != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  report_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), report);
  // @@protoc_insertion_point(field_set_allocated:signed_report.report)
}

// optional .key_message signing_key = 3;
inline bool signed_report::_internal_has_signing_key() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  PROTOBUF_ASSUME(!value || signing_key_ != nullptr);
  return value;
}
inline bool signed_report::has_signing_key() const {
  return _internal_has_signing_key();
}
inline void signed_report::clear_signing_key() {
  if (signing_key_ != nullptr) signing_key_->Clear();
  _has_bits_[0] &= ~0x00000010u;
}
inline const ::key_message& signed_report::_internal_signing_key() const {
  const ::key_message* p = signing_key_;
  return p != nullptr ? *p : *reinterpret_cast<const ::key_message*>(
      &::_key_message_default_instance_);
}
inline const ::key_message& signed_report::signing_key() const {
  // @@protoc_insertion_point(field_get:signed_report.signing_key)
  return _internal_signing_key();
}
inline ::key_message* signed_report::release_signing_key() {
  // @@protoc_insertion_point(field_release:signed_report.signing_key)
  _has_bits_[0] &= ~0x00000010u;
  ::key_message* temp = signing_key_;
  signing_key_ = nullptr;
  return temp;
}
inline ::key_message* signed_report::_internal_mutable_signing_key() {
  _has_bits_[0] |= 0x00000010u;
  if (signing_key_ == nullptr) {
    auto* p = CreateMaybeMessage<::key_message>(GetArenaNoVirtual());
    signing_key_ = p;
  }
  return signing_key_;
}
inline ::key_message* signed_report::mutable_signing_key() {
  // @@protoc_insertion_point(field_mutable:signed_report.signing_key)
  return _internal_mutable_signing_key();
}
inline void signed_report::set_allocated_signing_key(::key_message* signing_key) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete signing_key_;
  }
  if (signing_key) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      signing_key = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, signing_key, submessage_arena);
    }
    _has_bits_[0] |= 0x00000010u;
  } else {
    _has_bits_[0] &= ~0x00000010u;
  }
  signing_key_ = signing_key;
  // @@protoc_insertion_point(field_set_allocated:signed_report.signing_key)
}

// optional string signing_algorithm = 4;
inline bool signed_report::_internal_has_signing_algorithm() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool signed_report::has_signing_algorithm() const {
  return _internal_has_signing_algorithm();
}
inline void signed_report::clear_signing_algorithm() {
  signing_algorithm_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000004u;
}
inline const std::string& signed_report::signing_algorithm() const {
  // @@protoc_insertion_point(field_get:signed_report.signing_algorithm)
  return _internal_signing_algorithm();
}
inline void signed_report::set_signing_algorithm(const std::string& value) {
  _internal_set_signing_algorithm(value);
  // @@protoc_insertion_point(field_set:signed_report.signing_algorithm)
}
inline std::string* signed_report::mutable_signing_algorithm() {
  // @@protoc_insertion_point(field_mutable:signed_report.signing_algorithm)
  return _internal_mutable_signing_algorithm();
}
inline const std::string& signed_report::_internal_signing_algorithm() const {
  return signing_algorithm_.GetNoArena();
}
inline void signed_report::_internal_set_signing_algorithm(const std::string& value) {
  _has_bits_[0] |= 0x00000004u;
  signing_algorithm_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
}
inline void signed_report::set_signing_algorithm(std::string&& value) {
  _has_bits_[0] |= 0x00000004u;
  signing_algorithm_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:signed_report.signing_algorithm)
}
inline void signed_report::set_signing_algorithm(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000004u;
  signing_algorithm_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:signed_report.signing_algorithm)
}
inline void signed_report::set_signing_algorithm(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000004u;
  signing_algorithm_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:signed_report.signing_algorithm)
}
inline std::string* signed_report::_internal_mutable_signing_algorithm() {
  _has_bits_[0] |= 0x00000004u;
  return signing_algorithm_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* signed_report::release_signing_algorithm() {
  // @@protoc_insertion_point(field_release:signed_report.signing_algorithm)
  if (!_internal_has_signing_algorithm()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000004u;
  return signing_algorithm_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void signed_report::set_allocated_signing_algorithm(std::string* signing_algorithm) {
  if (signing_algorithm != nullptr) {
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  signing_algorithm_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), signing_algorithm);
  // @@protoc_insertion_point(field_set_allocated:signed_report.signing_algorithm)
}

// optional bytes signature = 5;
inline bool signed_report::_internal_has_signature() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool signed_report::has_signature() const {
  return _internal_has_signature();
}
inline void signed_report::clear_signature() {
  signature_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000008u;
}
inline const std::string& signed_report::signature() const {
  // @@protoc_insertion_point(field_get:signed_report.signature)
  return _internal_signature();
}
inline void signed_report::set_signature(const std::string& value) {
  _internal_set_signature(value);
  // @@protoc_insertion_point(field_set:signed_report.signature)
}
inline std::string* signed_report::mutable_signature() {
  // @@protoc_insertion_point(field_mutable:signed_report.signature)
  return _internal_mutable_signature();
}
inline const std::string& signed_report::_internal_signature() const {
  return signature_.GetNoArena();
}
inline void signed_report::_internal_set_signature(const std::string& value) {
  _has_bits_[0] |= 0x00000008u;
  signature_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
}
inline void signed_report::set_signature(std::string&& value) {
  _has_bits_[0] |= 0x00000008u;
  signature_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:signed_report.signature)
}
inline void signed_report::set_signature(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000008u;
  signature_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:signed_report.signature)
}
inline void signed_report::set_signature(const void* value, size_t size) {
  _has_bits_[0] |= 0x00000008u;
  signature_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:signed_report.signature)
}
inline std::string* signed_report::_internal_mutable_signature() {
  _has_bits_[0] |= 0x00000008u;
  return signature_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* signed_report::release_signature() {
  // @@protoc_insertion_point(field_release:signed_report.signature)
  if (!_internal_has_signature()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000008u;
  return signature_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void signed_report::set_allocated_signature(std::string* signature) {
  if (signature != nullptr) {
    _has_bits_[0] |= 0x00000008u;
  } else {
    _has_bits_[0] &= ~0x00000008u;
  }
  signature_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), signature);
  // @@protoc_insertion_point(field_set_allocated:signed_report.signature)
}

// -------------------------------------------------------------------

// signed_claim_message

// optional bytes serialized_claim_message = 1;
inline bool signed_claim_message::_internal_has_serialized_claim_message() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool signed_claim_message::has_serialized_claim_message() const {
  return _internal_has_serialized_claim_message();
}
inline void signed_claim_message::clear_serialized_claim_message() {
  serialized_claim_message_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& signed_claim_message::serialized_claim_message() const {
  // @@protoc_insertion_point(field_get:signed_claim_message.serialized_claim_message)
  return _internal_serialized_claim_message();
}
inline void signed_claim_message::set_serialized_claim_message(const std::string& value) {
  _internal_set_serialized_claim_message(value);
  // @@protoc_insertion_point(field_set:signed_claim_message.serialized_claim_message)
}
inline std::string* signed_claim_message::mutable_serialized_claim_message() {
  // @@protoc_insertion_point(field_mutable:signed_claim_message.serialized_claim_message)
  return _internal_mutable_serialized_claim_message();
}
inline const std::string& signed_claim_message::_internal_serialized_claim_message() const {
  return serialized_claim_message_.GetNoArena();
}
inline void signed_claim_message::_internal_set_serialized_claim_message(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  serialized_claim_message_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
}
inline void signed_claim_message::set_serialized_claim_message(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  serialized_claim_message_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:signed_claim_message.serialized_claim_message)
}
inline void signed_claim_message::set_serialized_claim_message(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  serialized_claim_message_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:signed_claim_message.serialized_claim_message)
}
inline void signed_claim_message::set_serialized_claim_message(const void* value, size_t size) {
  _has_bits_[0] |= 0x00000001u;
  serialized_claim_message_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:signed_claim_message.serialized_claim_message)
}
inline std::string* signed_claim_message::_internal_mutable_serialized_claim_message() {
  _has_bits_[0] |= 0x00000001u;
  return serialized_claim_message_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* signed_claim_message::release_serialized_claim_message() {
  // @@protoc_insertion_point(field_release:signed_claim_message.serialized_claim_message)
  if (!_internal_has_serialized_claim_message()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return serialized_claim_message_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void signed_claim_message::set_allocated_serialized_claim_message(std::string* serialized_claim_message) {
  if (serialized_claim_message != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  serialized_claim_message_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), serialized_claim_message);
  // @@protoc_insertion_point(field_set_allocated:signed_claim_message.serialized_claim_message)
}

// optional .key_message signing_key = 2;
inline bool signed_claim_message::_internal_has_signing_key() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  PROTOBUF_ASSUME(!value || signing_key_ != nullptr);
  return value;
}
inline bool signed_claim_message::has_signing_key() const {
  return _internal_has_signing_key();
}
inline void signed_claim_message::clear_signing_key() {
  if (signing_key_ != nullptr) signing_key_->Clear();
  _has_bits_[0] &= ~0x00000008u;
}
inline const ::key_message& signed_claim_message::_internal_signing_key() const {
  const ::key_message* p = signing_key_;
  return p != nullptr ? *p : *reinterpret_cast<const ::key_message*>(
      &::_key_message_default_instance_);
}
inline const ::key_message& signed_claim_message::signing_key() const {
  // @@protoc_insertion_point(field_get:signed_claim_message.signing_key)
  return _internal_signing_key();
}
inline ::key_message* signed_claim_message::release_signing_key() {
  // @@protoc_insertion_point(field_release:signed_claim_message.signing_key)
  _has_bits_[0] &= ~0x00000008u;
  ::key_message* temp = signing_key_;
  signing_key_ = nullptr;
  return temp;
}
inline ::key_message* signed_claim_message::_internal_mutable_signing_key() {
  _has_bits_[0] |= 0x00000008u;
  if (signing_key_ == nullptr) {
    auto* p = CreateMaybeMessage<::key_message>(GetArenaNoVirtual());
    signing_key_ = p;
  }
  return signing_key_;
}
inline ::key_message* signed_claim_message::mutable_signing_key() {
  // @@protoc_insertion_point(field_mutable:signed_claim_message.signing_key)
  return _internal_mutable_signing_key();
}
inline void signed_claim_message::set_allocated_signing_key(::key_message* signing_key) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete signing_key_;
  }
  if (signing_key) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      signing_key = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, signing_key, submessage_arena);
    }
    _has_bits_[0] |= 0x00000008u;
  } else {
    _has_bits_[0] &= ~0x00000008u;
  }
  signing_key_ = signing_key;
  // @@protoc_insertion_point(field_set_allocated:signed_claim_message.signing_key)
}

// optional string signing_algorithm = 3;
inline bool signed_claim_message::_internal_has_signing_algorithm() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool signed_claim_message::has_signing_algorithm() const {
  return _internal_has_signing_algorithm();
}
inline void signed_claim_message::clear_signing_algorithm() {
  signing_algorithm_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& signed_claim_message::signing_algorithm() const {
  // @@protoc_insertion_point(field_get:signed_claim_message.signing_algorithm)
  return _internal_signing_algorithm();
}
inline void signed_claim_message::set_signing_algorithm(const std::string& value) {
  _internal_set_signing_algorithm(value);
  // @@protoc_insertion_point(field_set:signed_claim_message.signing_algorithm)
}
inline std::string* signed_claim_message::mutable_signing_algorithm() {
  // @@protoc_insertion_point(field_mutable:signed_claim_message.signing_algorithm)
  return _internal_mutable_signing_algorithm();
}
inline const std::string& signed_claim_message::_internal_signing_algorithm() const {
  return signing_algorithm_.GetNoArena();
}
inline void signed_claim_message::_internal_set_signing_algorithm(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  signing_algorithm_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
}
inline void signed_claim_message::set_signing_algorithm(std::string&& value) {
  _has_bits_[0] |= 0x00000002u;
  signing_algorithm_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:signed_claim_message.signing_algorithm)
}
inline void signed_claim_message::set_signing_algorithm(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000002u;
  signing_algorithm_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:signed_claim_message.signing_algorithm)
}
inline void signed_claim_message::set_signing_algorithm(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000002u;
  signing_algorithm_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:signed_claim_message.signing_algorithm)
}
inline std::string* signed_claim_message::_internal_mutable_signing_algorithm() {
  _has_bits_[0] |= 0x00000002u;
  return signing_algorithm_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* signed_claim_message::release_signing_algorithm() {
  // @@protoc_insertion_point(field_release:signed_claim_message.signing_algorithm)
  if (!_internal_has_signing_algorithm()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  return signing_algorithm_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void signed_claim_message::set_allocated_signing_algorithm(std::string* signing_algorithm) {
  if (signing_algorithm != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  signing_algorithm_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), signing_algorithm);
  // @@protoc_insertion_point(field_set_allocated:signed_claim_message.signing_algorithm)
}

// optional bytes signature = 4;
inline bool signed_claim_message::_internal_has_signature() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool signed_claim_message::has_signature() const {
  return _internal_has_signature();
}
inline void signed_claim_message::clear_signature() {
  signature_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000004u;
}
inline const std::string& signed_claim_message::signature() const {
  // @@protoc_insertion_point(field_get:signed_claim_message.signature)
  return _internal_signature();
}
inline void signed_claim_message::set_signature(const std::string& value) {
  _internal_set_signature(value);
  // @@protoc_insertion_point(field_set:signed_claim_message.signature)
}
inline std::string* signed_claim_message::mutable_signature() {
  // @@protoc_insertion_point(field_mutable:signed_claim_message.signature)
  return _internal_mutable_signature();
}
inline const std::string& signed_claim_message::_internal_signature() const {
  return signature_.GetNoArena();
}
inline void signed_claim_message::_internal_set_signature(const std::string& value) {
  _has_bits_[0] |= 0x00000004u;
  signature_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
}
inline void signed_claim_message::set_signature(std::string&& value) {
  _has_bits_[0] |= 0x00000004u;
  signature_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:signed_claim_message.signature)
}
inline void signed_claim_message::set_signature(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000004u;
  signature_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:signed_claim_message.signature)
}
inline void signed_claim_message::set_signature(const void* value, size_t size) {
  _has_bits_[0] |= 0x00000004u;
  signature_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:signed_claim_message.signature)
}
inline std::string* signed_claim_message::_internal_mutable_signature() {
  _has_bits_[0] |= 0x00000004u;
  return signature_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* signed_claim_message::release_signature() {
  // @@protoc_insertion_point(field_release:signed_claim_message.signature)
  if (!_internal_has_signature()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000004u;
  return signature_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void signed_claim_message::set_allocated_signature(std::string* signature) {
  if (signature != nullptr) {
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  signature_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), signature);
  // @@protoc_insertion_point(field_set_allocated:signed_claim_message.signature)
}

// -------------------------------------------------------------------

// evidence

// optional string evidence_type = 1;
inline bool evidence::_internal_has_evidence_type() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool evidence::has_evidence_type() const {
  return _internal_has_evidence_type();
}
inline void evidence::clear_evidence_type() {
  evidence_type_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& evidence::evidence_type() const {
  // @@protoc_insertion_point(field_get:evidence.evidence_type)
  return _internal_evidence_type();
}
inline void evidence::set_evidence_type(const std::string& value) {
  _internal_set_evidence_type(value);
  // @@protoc_insertion_point(field_set:evidence.evidence_type)
}
inline std::string* evidence::mutable_evidence_type() {
  // @@protoc_insertion_point(field_mutable:evidence.evidence_type)
  return _internal_mutable_evidence_type();
}
inline const std::string& evidence::_internal_evidence_type() const {
  return evidence_type_.GetNoArena();
}
inline void evidence::_internal_set_evidence_type(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  evidence_type_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
}
inline void evidence::set_evidence_type(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  evidence_type_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:evidence.evidence_type)
}
inline void evidence::set_evidence_type(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  evidence_type_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:evidence.evidence_type)
}
inline void evidence::set_evidence_type(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000001u;
  evidence_type_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:evidence.evidence_type)
}
inline std::string* evidence::_internal_mutable_evidence_type() {
  _has_bits_[0] |= 0x00000001u;
  return evidence_type_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* evidence::release_evidence_type() {
  // @@protoc_insertion_point(field_release:evidence.evidence_type)
  if (!_internal_has_evidence_type()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return evidence_type_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void evidence::set_allocated_evidence_type(std::string* evidence_type) {
  if (evidence_type != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  evidence_type_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), evidence_type);
  // @@protoc_insertion_point(field_set_allocated:evidence.evidence_type)
}

// optional bytes serialized_evidence = 2;
inline bool evidence::_internal_has_serialized_evidence() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool evidence::has_serialized_evidence() const {
  return _internal_has_serialized_evidence();
}
inline void evidence::clear_serialized_evidence() {
  serialized_evidence_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& evidence::serialized_evidence() const {
  // @@protoc_insertion_point(field_get:evidence.serialized_evidence)
  return _internal_serialized_evidence();
}
inline void evidence::set_serialized_evidence(const std::string& value) {
  _internal_set_serialized_evidence(value);
  // @@protoc_insertion_point(field_set:evidence.serialized_evidence)
}
inline std::string* evidence::mutable_serialized_evidence() {
  // @@protoc_insertion_point(field_mutable:evidence.serialized_evidence)
  return _internal_mutable_serialized_evidence();
}
inline const std::string& evidence::_internal_serialized_evidence() const {
  return serialized_evidence_.GetNoArena();
}
inline void evidence::_internal_set_serialized_evidence(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  serialized_evidence_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
}
inline void evidence::set_serialized_evidence(std::string&& value) {
  _has_bits_[0] |= 0x00000002u;
  serialized_evidence_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:evidence.serialized_evidence)
}
inline void evidence::set_serialized_evidence(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000002u;
  serialized_evidence_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:evidence.serialized_evidence)
}
inline void evidence::set_serialized_evidence(const void* value, size_t size) {
  _has_bits_[0] |= 0x00000002u;
  serialized_evidence_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:evidence.serialized_evidence)
}
inline std::string* evidence::_internal_mutable_serialized_evidence() {
  _has_bits_[0] |= 0x00000002u;
  return serialized_evidence_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* evidence::release_serialized_evidence() {
  // @@protoc_insertion_point(field_release:evidence.serialized_evidence)
  if (!_internal_has_serialized_evidence()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  return serialized_evidence_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void evidence::set_allocated_serialized_evidence(std::string* serialized_evidence) {
  if (serialized_evidence != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  serialized_evidence_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), serialized_evidence);
  // @@protoc_insertion_point(field_set_allocated:evidence.serialized_evidence)
}

// -------------------------------------------------------------------

// evidence_list

// repeated .evidence assertion = 1;
inline int evidence_list::_internal_assertion_size() const {
  return assertion_.size();
}
inline int evidence_list::assertion_size() const {
  return _internal_assertion_size();
}
inline void evidence_list::clear_assertion() {
  assertion_.Clear();
}
inline ::evidence* evidence_list::mutable_assertion(int index) {
  // @@protoc_insertion_point(field_mutable:evidence_list.assertion)
  return assertion_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::evidence >*
evidence_list::mutable_assertion() {
  // @@protoc_insertion_point(field_mutable_list:evidence_list.assertion)
  return &assertion_;
}
inline const ::evidence& evidence_list::_internal_assertion(int index) const {
  return assertion_.Get(index);
}
inline const ::evidence& evidence_list::assertion(int index) const {
  // @@protoc_insertion_point(field_get:evidence_list.assertion)
  return _internal_assertion(index);
}
inline ::evidence* evidence_list::_internal_add_assertion() {
  return assertion_.Add();
}
inline ::evidence* evidence_list::add_assertion() {
  // @@protoc_insertion_point(field_add:evidence_list.assertion)
  return _internal_add_assertion();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::evidence >&
evidence_list::assertion() const {
  // @@protoc_insertion_point(field_list:evidence_list.assertion)
  return assertion_;
}

// -------------------------------------------------------------------

// keystone_attestation_message

// optional bytes what_was_said = 1;
inline bool keystone_attestation_message::_internal_has_what_was_said() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool keystone_attestation_message::has_what_was_said() const {
  return _internal_has_what_was_said();
}
inline void keystone_attestation_message::clear_what_was_said() {
  what_was_said_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& keystone_attestation_message::what_was_said() const {
  // @@protoc_insertion_point(field_get:keystone_attestation_message.what_was_said)
  return _internal_what_was_said();
}
inline void keystone_attestation_message::set_what_was_said(const std::string& value) {
  _internal_set_what_was_said(value);
  // @@protoc_insertion_point(field_set:keystone_attestation_message.what_was_said)
}
inline std::string* keystone_attestation_message::mutable_what_was_said() {
  // @@protoc_insertion_point(field_mutable:keystone_attestation_message.what_was_said)
  return _internal_mutable_what_was_said();
}
inline const std::string& keystone_attestation_message::_internal_what_was_said() const {
  return what_was_said_.GetNoArena();
}
inline void keystone_attestation_message::_internal_set_what_was_said(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  what_was_said_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
}
inline void keystone_attestation_message::set_what_was_said(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  what_was_said_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:keystone_attestation_message.what_was_said)
}
inline void keystone_attestation_message::set_what_was_said(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  what_was_said_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:keystone_attestation_message.what_was_said)
}
inline void keystone_attestation_message::set_what_was_said(const void* value, size_t size) {
  _has_bits_[0] |= 0x00000001u;
  what_was_said_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:keystone_attestation_message.what_was_said)
}
inline std::string* keystone_attestation_message::_internal_mutable_what_was_said() {
  _has_bits_[0] |= 0x00000001u;
  return what_was_said_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* keystone_attestation_message::release_what_was_said() {
  // @@protoc_insertion_point(field_release:keystone_attestation_message.what_was_said)
  if (!_internal_has_what_was_said()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return what_was_said_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void keystone_attestation_message::set_allocated_what_was_said(std::string* what_was_said) {
  if (what_was_said != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  what_was_said_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), what_was_said);
  // @@protoc_insertion_point(field_set_allocated:keystone_attestation_message.what_was_said)
}

// optional bytes reported_attestation = 2;
inline bool keystone_attestation_message::_internal_has_reported_attestation() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool keystone_attestation_message::has_reported_attestation() const {
  return _internal_has_reported_attestation();
}
inline void keystone_attestation_message::clear_reported_attestation() {
  reported_attestation_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& keystone_attestation_message::reported_attestation() const {
  // @@protoc_insertion_point(field_get:keystone_attestation_message.reported_attestation)
  return _internal_reported_attestation();
}
inline void keystone_attestation_message::set_reported_attestation(const std::string& value) {
  _internal_set_reported_attestation(value);
  // @@protoc_insertion_point(field_set:keystone_attestation_message.reported_attestation)
}
inline std::string* keystone_attestation_message::mutable_reported_attestation() {
  // @@protoc_insertion_point(field_mutable:keystone_attestation_message.reported_attestation)
  return _internal_mutable_reported_attestation();
}
inline const std::string& keystone_attestation_message::_internal_reported_attestation() const {
  return reported_attestation_.GetNoArena();
}
inline void keystone_attestation_message::_internal_set_reported_attestation(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  reported_attestation_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
}
inline void keystone_attestation_message::set_reported_attestation(std::string&& value) {
  _has_bits_[0] |= 0x00000002u;
  reported_attestation_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:keystone_attestation_message.reported_attestation)
}
inline void keystone_attestation_message::set_reported_attestation(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000002u;
  reported_attestation_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:keystone_attestation_message.reported_attestation)
}
inline void keystone_attestation_message::set_reported_attestation(const void* value, size_t size) {
  _has_bits_[0] |= 0x00000002u;
  reported_attestation_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:keystone_attestation_message.reported_attestation)
}
inline std::string* keystone_attestation_message::_internal_mutable_reported_attestation() {
  _has_bits_[0] |= 0x00000002u;
  return reported_attestation_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* keystone_attestation_message::release_reported_attestation() {
  // @@protoc_insertion_point(field_release:keystone_attestation_message.reported_attestation)
  if (!_internal_has_reported_attestation()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  return reported_attestation_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void keystone_attestation_message::set_allocated_reported_attestation(std::string* reported_attestation) {
  if (reported_attestation != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  reported_attestation_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), reported_attestation);
  // @@protoc_insertion_point(field_set_allocated:keystone_attestation_message.reported_attestation)
}

// -------------------------------------------------------------------

// sev_attestation_message

// optional bytes what_was_said = 1;
inline bool sev_attestation_message::_internal_has_what_was_said() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool sev_attestation_message::has_what_was_said() const {
  return _internal_has_what_was_said();
}
inline void sev_attestation_message::clear_what_was_said() {
  what_was_said_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& sev_attestation_message::what_was_said() const {
  // @@protoc_insertion_point(field_get:sev_attestation_message.what_was_said)
  return _internal_what_was_said();
}
inline void sev_attestation_message::set_what_was_said(const std::string& value) {
  _internal_set_what_was_said(value);
  // @@protoc_insertion_point(field_set:sev_attestation_message.what_was_said)
}
inline std::string* sev_attestation_message::mutable_what_was_said() {
  // @@protoc_insertion_point(field_mutable:sev_attestation_message.what_was_said)
  return _internal_mutable_what_was_said();
}
inline const std::string& sev_attestation_message::_internal_what_was_said() const {
  return what_was_said_.GetNoArena();
}
inline void sev_attestation_message::_internal_set_what_was_said(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  what_was_said_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
}
inline void sev_attestation_message::set_what_was_said(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  what_was_said_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:sev_attestation_message.what_was_said)
}
inline void sev_attestation_message::set_what_was_said(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  what_was_said_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:sev_attestation_message.what_was_said)
}
inline void sev_attestation_message::set_what_was_said(const void* value, size_t size) {
  _has_bits_[0] |= 0x00000001u;
  what_was_said_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:sev_attestation_message.what_was_said)
}
inline std::string* sev_attestation_message::_internal_mutable_what_was_said() {
  _has_bits_[0] |= 0x00000001u;
  return what_was_said_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* sev_attestation_message::release_what_was_said() {
  // @@protoc_insertion_point(field_release:sev_attestation_message.what_was_said)
  if (!_internal_has_what_was_said()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return what_was_said_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void sev_attestation_message::set_allocated_what_was_said(std::string* what_was_said) {
  if (what_was_said != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  what_was_said_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), what_was_said);
  // @@protoc_insertion_point(field_set_allocated:sev_attestation_message.what_was_said)
}

// optional bytes reported_attestation = 2;
inline bool sev_attestation_message::_internal_has_reported_attestation() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool sev_attestation_message::has_reported_attestation() const {
  return _internal_has_reported_attestation();
}
inline void sev_attestation_message::clear_reported_attestation() {
  reported_attestation_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& sev_attestation_message::reported_attestation() const {
  // @@protoc_insertion_point(field_get:sev_attestation_message.reported_attestation)
  return _internal_reported_attestation();
}
inline void sev_attestation_message::set_reported_attestation(const std::string& value) {
  _internal_set_reported_attestation(value);
  // @@protoc_insertion_point(field_set:sev_attestation_message.reported_attestation)
}
inline std::string* sev_attestation_message::mutable_reported_attestation() {
  // @@protoc_insertion_point(field_mutable:sev_attestation_message.reported_attestation)
  return _internal_mutable_reported_attestation();
}
inline const std::string& sev_attestation_message::_internal_reported_attestation() const {
  return reported_attestation_.GetNoArena();
}
inline void sev_attestation_message::_internal_set_reported_attestation(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  reported_attestation_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
}
inline void sev_attestation_message::set_reported_attestation(std::string&& value) {
  _has_bits_[0] |= 0x00000002u;
  reported_attestation_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:sev_attestation_message.reported_attestation)
}
inline void sev_attestation_message::set_reported_attestation(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000002u;
  reported_attestation_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:sev_attestation_message.reported_attestation)
}
inline void sev_attestation_message::set_reported_attestation(const void* value, size_t size) {
  _has_bits_[0] |= 0x00000002u;
  reported_attestation_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:sev_attestation_message.reported_attestation)
}
inline std::string* sev_attestation_message::_internal_mutable_reported_attestation() {
  _has_bits_[0] |= 0x00000002u;
  return reported_attestation_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* sev_attestation_message::release_reported_attestation() {
  // @@protoc_insertion_point(field_release:sev_attestation_message.reported_attestation)
  if (!_internal_has_reported_attestation()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  return reported_attestation_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void sev_attestation_message::set_allocated_reported_attestation(std::string* reported_attestation) {
  if (reported_attestation != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  reported_attestation_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), reported_attestation);
  // @@protoc_insertion_point(field_set_allocated:sev_attestation_message.reported_attestation)
}

// -------------------------------------------------------------------

// gramine_attestation_message

// optional bytes what_was_said = 1;
inline bool gramine_attestation_message::_internal_has_what_was_said() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool gramine_attestation_message::has_what_was_said() const {
  return _internal_has_what_was_said();
}
inline void gramine_attestation_message::clear_what_was_said() {
  what_was_said_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& gramine_attestation_message::what_was_said() const {
  // @@protoc_insertion_point(field_get:gramine_attestation_message.what_was_said)
  return _internal_what_was_said();
}
inline void gramine_attestation_message::set_what_was_said(const std::string& value) {
  _internal_set_what_was_said(value);
  // @@protoc_insertion_point(field_set:gramine_attestation_message.what_was_said)
}
inline std::string* gramine_attestation_message::mutable_what_was_said() {
  // @@protoc_insertion_point(field_mutable:gramine_attestation_message.what_was_said)
  return _internal_mutable_what_was_said();
}
inline const std::string& gramine_attestation_message::_internal_what_was_said() const {
  return what_was_said_.GetNoArena();
}
inline void gramine_attestation_message::_internal_set_what_was_said(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  what_was_said_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
}
inline void gramine_attestation_message::set_what_was_said(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  what_was_said_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:gramine_attestation_message.what_was_said)
}
inline void gramine_attestation_message::set_what_was_said(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  what_was_said_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:gramine_attestation_message.what_was_said)
}
inline void gramine_attestation_message::set_what_was_said(const void* value, size_t size) {
  _has_bits_[0] |= 0x00000001u;
  what_was_said_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:gramine_attestation_message.what_was_said)
}
inline std::string* gramine_attestation_message::_internal_mutable_what_was_said() {
  _has_bits_[0] |= 0x00000001u;
  return what_was_said_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* gramine_attestation_message::release_what_was_said() {
  // @@protoc_insertion_point(field_release:gramine_attestation_message.what_was_said)
  if (!_internal_has_what_was_said()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return what_was_said_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void gramine_attestation_message::set_allocated_what_was_said(std::string* what_was_said) {
  if (what_was_said != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  what_was_said_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), what_was_said);
  // @@protoc_insertion_point(field_set_allocated:gramine_attestation_message.what_was_said)
}

// optional bytes reported_attestation = 2;
inline bool gramine_attestation_message::_internal_has_reported_attestation() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool gramine_attestation_message::has_reported_attestation() const {
  return _internal_has_reported_attestation();
}
inline void gramine_attestation_message::clear_reported_attestation() {
  reported_attestation_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& gramine_attestation_message::reported_attestation() const {
  // @@protoc_insertion_point(field_get:gramine_attestation_message.reported_attestation)
  return _internal_reported_attestation();
}
inline void gramine_attestation_message::set_reported_attestation(const std::string& value) {
  _internal_set_reported_attestation(value);
  // @@protoc_insertion_point(field_set:gramine_attestation_message.reported_attestation)
}
inline std::string* gramine_attestation_message::mutable_reported_attestation() {
  // @@protoc_insertion_point(field_mutable:gramine_attestation_message.reported_attestation)
  return _internal_mutable_reported_attestation();
}
inline const std::string& gramine_attestation_message::_internal_reported_attestation() const {
  return reported_attestation_.GetNoArena();
}
inline void gramine_attestation_message::_internal_set_reported_attestation(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  reported_attestation_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
}
inline void gramine_attestation_message::set_reported_attestation(std::string&& value) {
  _has_bits_[0] |= 0x00000002u;
  reported_attestation_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:gramine_attestation_message.reported_attestation)
}
inline void gramine_attestation_message::set_reported_attestation(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000002u;
  reported_attestation_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:gramine_attestation_message.reported_attestation)
}
inline void gramine_attestation_message::set_reported_attestation(const void* value, size_t size) {
  _has_bits_[0] |= 0x00000002u;
  reported_attestation_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:gramine_attestation_message.reported_attestation)
}
inline std::string* gramine_attestation_message::_internal_mutable_reported_attestation() {
  _has_bits_[0] |= 0x00000002u;
  return reported_attestation_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* gramine_attestation_message::release_reported_attestation() {
  // @@protoc_insertion_point(field_release:gramine_attestation_message.reported_attestation)
  if (!_internal_has_reported_attestation()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  return reported_attestation_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void gramine_attestation_message::set_allocated_reported_attestation(std::string* reported_attestation) {
  if (reported_attestation != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  reported_attestation_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), reported_attestation);
  // @@protoc_insertion_point(field_set_allocated:gramine_attestation_message.reported_attestation)
}

// -------------------------------------------------------------------

// evidence_package

// optional string prover_type = 1;
inline bool evidence_package::_internal_has_prover_type() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool evidence_package::has_prover_type() const {
  return _internal_has_prover_type();
}
inline void evidence_package::clear_prover_type() {
  prover_type_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& evidence_package::prover_type() const {
  // @@protoc_insertion_point(field_get:evidence_package.prover_type)
  return _internal_prover_type();
}
inline void evidence_package::set_prover_type(const std::string& value) {
  _internal_set_prover_type(value);
  // @@protoc_insertion_point(field_set:evidence_package.prover_type)
}
inline std::string* evidence_package::mutable_prover_type() {
  // @@protoc_insertion_point(field_mutable:evidence_package.prover_type)
  return _internal_mutable_prover_type();
}
inline const std::string& evidence_package::_internal_prover_type() const {
  return prover_type_.GetNoArena();
}
inline void evidence_package::_internal_set_prover_type(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  prover_type_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
}
inline void evidence_package::set_prover_type(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  prover_type_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:evidence_package.prover_type)
}
inline void evidence_package::set_prover_type(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  prover_type_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:evidence_package.prover_type)
}
inline void evidence_package::set_prover_type(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000001u;
  prover_type_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:evidence_package.prover_type)
}
inline std::string* evidence_package::_internal_mutable_prover_type() {
  _has_bits_[0] |= 0x00000001u;
  return prover_type_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* evidence_package::release_prover_type() {
  // @@protoc_insertion_point(field_release:evidence_package.prover_type)
  if (!_internal_has_prover_type()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return prover_type_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void evidence_package::set_allocated_prover_type(std::string* prover_type) {
  if (prover_type != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  prover_type_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), prover_type);
  // @@protoc_insertion_point(field_set_allocated:evidence_package.prover_type)
}

// repeated .evidence fact_assertion = 2;
inline int evidence_package::_internal_fact_assertion_size() const {
  return fact_assertion_.size();
}
inline int evidence_package::fact_assertion_size() const {
  return _internal_fact_assertion_size();
}
inline void evidence_package::clear_fact_assertion() {
  fact_assertion_.Clear();
}
inline ::evidence* evidence_package::mutable_fact_assertion(int index) {
  // @@protoc_insertion_point(field_mutable:evidence_package.fact_assertion)
  return fact_assertion_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::evidence >*
evidence_package::mutable_fact_assertion() {
  // @@protoc_insertion_point(field_mutable_list:evidence_package.fact_assertion)
  return &fact_assertion_;
}
inline const ::evidence& evidence_package::_internal_fact_assertion(int index) const {
  return fact_assertion_.Get(index);
}
inline const ::evidence& evidence_package::fact_assertion(int index) const {
  // @@protoc_insertion_point(field_get:evidence_package.fact_assertion)
  return _internal_fact_assertion(index);
}
inline ::evidence* evidence_package::_internal_add_fact_assertion() {
  return fact_assertion_.Add();
}
inline ::evidence* evidence_package::add_fact_assertion() {
  // @@protoc_insertion_point(field_add:evidence_package.fact_assertion)
  return _internal_add_fact_assertion();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::evidence >&
evidence_package::fact_assertion() const {
  // @@protoc_insertion_point(field_list:evidence_package.fact_assertion)
  return fact_assertion_;
}

// -------------------------------------------------------------------

// certifier_rules

// repeated string rule = 1;
inline int certifier_rules::_internal_rule_size() const {
  return rule_.size();
}
inline int certifier_rules::rule_size() const {
  return _internal_rule_size();
}
inline void certifier_rules::clear_rule() {
  rule_.Clear();
}
inline std::string* certifier_rules::add_rule() {
  // @@protoc_insertion_point(field_add_mutable:certifier_rules.rule)
  return _internal_add_rule();
}
inline const std::string& certifier_rules::_internal_rule(int index) const {
  return rule_.Get(index);
}
inline const std::string& certifier_rules::rule(int index) const {
  // @@protoc_insertion_point(field_get:certifier_rules.rule)
  return _internal_rule(index);
}
inline std::string* certifier_rules::mutable_rule(int index) {
  // @@protoc_insertion_point(field_mutable:certifier_rules.rule)
  return rule_.Mutable(index);
}
inline void certifier_rules::set_rule(int index, const std::string& value) {
  // @@protoc_insertion_point(field_set:certifier_rules.rule)
  rule_.Mutable(index)->assign(value);
}
inline void certifier_rules::set_rule(int index, std::string&& value) {
  // @@protoc_insertion_point(field_set:certifier_rules.rule)
  rule_.Mutable(index)->assign(std::move(value));
}
inline void certifier_rules::set_rule(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  rule_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:certifier_rules.rule)
}
inline void certifier_rules::set_rule(int index, const char* value, size_t size) {
  rule_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:certifier_rules.rule)
}
inline std::string* certifier_rules::_internal_add_rule() {
  return rule_.Add();
}
inline void certifier_rules::add_rule(const std::string& value) {
  rule_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:certifier_rules.rule)
}
inline void certifier_rules::add_rule(std::string&& value) {
  rule_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:certifier_rules.rule)
}
inline void certifier_rules::add_rule(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  rule_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:certifier_rules.rule)
}
inline void certifier_rules::add_rule(const char* value, size_t size) {
  rule_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:certifier_rules.rule)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
certifier_rules::rule() const {
  // @@protoc_insertion_point(field_list:certifier_rules.rule)
  return rule_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
certifier_rules::mutable_rule() {
  // @@protoc_insertion_point(field_mutable_list:certifier_rules.rule)
  return &rule_;
}

// -------------------------------------------------------------------

// proved_statements

// repeated .vse_clause proved = 1;
inline int proved_statements::_internal_proved_size() const {
  return proved_.size();
}
inline int proved_statements::proved_size() const {
  return _internal_proved_size();
}
inline void proved_statements::clear_proved() {
  proved_.Clear();
}
inline ::vse_clause* proved_statements::mutable_proved(int index) {
  // @@protoc_insertion_point(field_mutable:proved_statements.proved)
  return proved_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vse_clause >*
proved_statements::mutable_proved() {
  // @@protoc_insertion_point(field_mutable_list:proved_statements.proved)
  return &proved_;
}
inline const ::vse_clause& proved_statements::_internal_proved(int index) const {
  return proved_.Get(index);
}
inline const ::vse_clause& proved_statements::proved(int index) const {
  // @@protoc_insertion_point(field_get:proved_statements.proved)
  return _internal_proved(index);
}
inline ::vse_clause* proved_statements::_internal_add_proved() {
  return proved_.Add();
}
inline ::vse_clause* proved_statements::add_proved() {
  // @@protoc_insertion_point(field_add:proved_statements.proved)
  return _internal_add_proved();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vse_clause >&
proved_statements::proved() const {
  // @@protoc_insertion_point(field_list:proved_statements.proved)
  return proved_;
}

// -------------------------------------------------------------------

// proof_step

// optional .vse_clause s1 = 1;
inline bool proof_step::_internal_has_s1() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || s1_ != nullptr);
  return value;
}
inline bool proof_step::has_s1() const {
  return _internal_has_s1();
}
inline void proof_step::clear_s1() {
  if (s1_ != nullptr) s1_->Clear();
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::vse_clause& proof_step::_internal_s1() const {
  const ::vse_clause* p = s1_;
  return p != nullptr ? *p : *reinterpret_cast<const ::vse_clause*>(
      &::_vse_clause_default_instance_);
}
inline const ::vse_clause& proof_step::s1() const {
  // @@protoc_insertion_point(field_get:proof_step.s1)
  return _internal_s1();
}
inline ::vse_clause* proof_step::release_s1() {
  // @@protoc_insertion_point(field_release:proof_step.s1)
  _has_bits_[0] &= ~0x00000001u;
  ::vse_clause* temp = s1_;
  s1_ = nullptr;
  return temp;
}
inline ::vse_clause* proof_step::_internal_mutable_s1() {
  _has_bits_[0] |= 0x00000001u;
  if (s1_ == nullptr) {
    auto* p = CreateMaybeMessage<::vse_clause>(GetArenaNoVirtual());
    s1_ = p;
  }
  return s1_;
}
inline ::vse_clause* proof_step::mutable_s1() {
  // @@protoc_insertion_point(field_mutable:proof_step.s1)
  return _internal_mutable_s1();
}
inline void proof_step::set_allocated_s1(::vse_clause* s1) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete s1_;
  }
  if (s1) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      s1 = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, s1, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  s1_ = s1;
  // @@protoc_insertion_point(field_set_allocated:proof_step.s1)
}

// optional .vse_clause s2 = 2;
inline bool proof_step::_internal_has_s2() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || s2_ != nullptr);
  return value;
}
inline bool proof_step::has_s2() const {
  return _internal_has_s2();
}
inline void proof_step::clear_s2() {
  if (s2_ != nullptr) s2_->Clear();
  _has_bits_[0] &= ~0x00000002u;
}
inline const ::vse_clause& proof_step::_internal_s2() const {
  const ::vse_clause* p = s2_;
  return p != nullptr ? *p : *reinterpret_cast<const ::vse_clause*>(
      &::_vse_clause_default_instance_);
}
inline const ::vse_clause& proof_step::s2() const {
  // @@protoc_insertion_point(field_get:proof_step.s2)
  return _internal_s2();
}
inline ::vse_clause* proof_step::release_s2() {
  // @@protoc_insertion_point(field_release:proof_step.s2)
  _has_bits_[0] &= ~0x00000002u;
  ::vse_clause* temp = s2_;
  s2_ = nullptr;
  return temp;
}
inline ::vse_clause* proof_step::_internal_mutable_s2() {
  _has_bits_[0] |= 0x00000002u;
  if (s2_ == nullptr) {
    auto* p = CreateMaybeMessage<::vse_clause>(GetArenaNoVirtual());
    s2_ = p;
  }
  return s2_;
}
inline ::vse_clause* proof_step::mutable_s2() {
  // @@protoc_insertion_point(field_mutable:proof_step.s2)
  return _internal_mutable_s2();
}
inline void proof_step::set_allocated_s2(::vse_clause* s2) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete s2_;
  }
  if (s2) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      s2 = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, s2, submessage_arena);
    }
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  s2_ = s2;
  // @@protoc_insertion_point(field_set_allocated:proof_step.s2)
}

// optional .vse_clause conclusion = 3;
inline bool proof_step::_internal_has_conclusion() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || conclusion_ != nullptr);
  return value;
}
inline bool proof_step::has_conclusion() const {
  return _internal_has_conclusion();
}
inline void proof_step::clear_conclusion() {
  if (conclusion_ != nullptr) conclusion_->Clear();
  _has_bits_[0] &= ~0x00000004u;
}
inline const ::vse_clause& proof_step::_internal_conclusion() const {
  const ::vse_clause* p = conclusion_;
  return p != nullptr ? *p : *reinterpret_cast<const ::vse_clause*>(
      &::_vse_clause_default_instance_);
}
inline const ::vse_clause& proof_step::conclusion() const {
  // @@protoc_insertion_point(field_get:proof_step.conclusion)
  return _internal_conclusion();
}
inline ::vse_clause* proof_step::release_conclusion() {
  // @@protoc_insertion_point(field_release:proof_step.conclusion)
  _has_bits_[0] &= ~0x00000004u;
  ::vse_clause* temp = conclusion_;
  conclusion_ = nullptr;
  return temp;
}
inline ::vse_clause* proof_step::_internal_mutable_conclusion() {
  _has_bits_[0] |= 0x00000004u;
  if (conclusion_ == nullptr) {
    auto* p = CreateMaybeMessage<::vse_clause>(GetArenaNoVirtual());
    conclusion_ = p;
  }
  return conclusion_;
}
inline ::vse_clause* proof_step::mutable_conclusion() {
  // @@protoc_insertion_point(field_mutable:proof_step.conclusion)
  return _internal_mutable_conclusion();
}
inline void proof_step::set_allocated_conclusion(::vse_clause* conclusion) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete conclusion_;
  }
  if (conclusion) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      conclusion = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, conclusion, submessage_arena);
    }
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  conclusion_ = conclusion;
  // @@protoc_insertion_point(field_set_allocated:proof_step.conclusion)
}

// optional int32 rule_applied = 4;
inline bool proof_step::_internal_has_rule_applied() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool proof_step::has_rule_applied() const {
  return _internal_has_rule_applied();
}
inline void proof_step::clear_rule_applied() {
  rule_applied_ = 0;
  _has_bits_[0] &= ~0x00000008u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 proof_step::_internal_rule_applied() const {
  return rule_applied_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 proof_step::rule_applied() const {
  // @@protoc_insertion_point(field_get:proof_step.rule_applied)
  return _internal_rule_applied();
}
inline void proof_step::_internal_set_rule_applied(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000008u;
  rule_applied_ = value;
}
inline void proof_step::set_rule_applied(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_rule_applied(value);
  // @@protoc_insertion_point(field_set:proof_step.rule_applied)
}

// -------------------------------------------------------------------

// proof

// optional .vse_clause to_prove = 1;
inline bool proof::_internal_has_to_prove() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || to_prove_ != nullptr);
  return value;
}
inline bool proof::has_to_prove() const {
  return _internal_has_to_prove();
}
inline void proof::clear_to_prove() {
  if (to_prove_ != nullptr) to_prove_->Clear();
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::vse_clause& proof::_internal_to_prove() const {
  const ::vse_clause* p = to_prove_;
  return p != nullptr ? *p : *reinterpret_cast<const ::vse_clause*>(
      &::_vse_clause_default_instance_);
}
inline const ::vse_clause& proof::to_prove() const {
  // @@protoc_insertion_point(field_get:proof.to_prove)
  return _internal_to_prove();
}
inline ::vse_clause* proof::release_to_prove() {
  // @@protoc_insertion_point(field_release:proof.to_prove)
  _has_bits_[0] &= ~0x00000001u;
  ::vse_clause* temp = to_prove_;
  to_prove_ = nullptr;
  return temp;
}
inline ::vse_clause* proof::_internal_mutable_to_prove() {
  _has_bits_[0] |= 0x00000001u;
  if (to_prove_ == nullptr) {
    auto* p = CreateMaybeMessage<::vse_clause>(GetArenaNoVirtual());
    to_prove_ = p;
  }
  return to_prove_;
}
inline ::vse_clause* proof::mutable_to_prove() {
  // @@protoc_insertion_point(field_mutable:proof.to_prove)
  return _internal_mutable_to_prove();
}
inline void proof::set_allocated_to_prove(::vse_clause* to_prove) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete to_prove_;
  }
  if (to_prove) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      to_prove = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, to_prove, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  to_prove_ = to_prove;
  // @@protoc_insertion_point(field_set_allocated:proof.to_prove)
}

// repeated .vse_clause already_proved = 2;
inline int proof::_internal_already_proved_size() const {
  return already_proved_.size();
}
inline int proof::already_proved_size() const {
  return _internal_already_proved_size();
}
inline void proof::clear_already_proved() {
  already_proved_.Clear();
}
inline ::vse_clause* proof::mutable_already_proved(int index) {
  // @@protoc_insertion_point(field_mutable:proof.already_proved)
  return already_proved_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vse_clause >*
proof::mutable_already_proved() {
  // @@protoc_insertion_point(field_mutable_list:proof.already_proved)
  return &already_proved_;
}
inline const ::vse_clause& proof::_internal_already_proved(int index) const {
  return already_proved_.Get(index);
}
inline const ::vse_clause& proof::already_proved(int index) const {
  // @@protoc_insertion_point(field_get:proof.already_proved)
  return _internal_already_proved(index);
}
inline ::vse_clause* proof::_internal_add_already_proved() {
  return already_proved_.Add();
}
inline ::vse_clause* proof::add_already_proved() {
  // @@protoc_insertion_point(field_add:proof.already_proved)
  return _internal_add_already_proved();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vse_clause >&
proof::already_proved() const {
  // @@protoc_insertion_point(field_list:proof.already_proved)
  return already_proved_;
}

// repeated .proof_step steps = 3;
inline int proof::_internal_steps_size() const {
  return steps_.size();
}
inline int proof::steps_size() const {
  return _internal_steps_size();
}
inline void proof::clear_steps() {
  steps_.Clear();
}
inline ::proof_step* proof::mutable_steps(int index) {
  // @@protoc_insertion_point(field_mutable:proof.steps)
  return steps_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::proof_step >*
proof::mutable_steps() {
  // @@protoc_insertion_point(field_mutable_list:proof.steps)
  return &steps_;
}
inline const ::proof_step& proof::_internal_steps(int index) const {
  return steps_.Get(index);
}
inline const ::proof_step& proof::steps(int index) const {
  // @@protoc_insertion_point(field_get:proof.steps)
  return _internal_steps(index);
}
inline ::proof_step* proof::_internal_add_steps() {
  return steps_.Add();
}
inline ::proof_step* proof::add_steps() {
  // @@protoc_insertion_point(field_add:proof.steps)
  return _internal_add_steps();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::proof_step >&
proof::steps() const {
  // @@protoc_insertion_point(field_list:proof.steps)
  return steps_;
}

// -------------------------------------------------------------------

// trust_request_message

// optional string requesting_enclave_tag = 1;
inline bool trust_request_message::_internal_has_requesting_enclave_tag() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool trust_request_message::has_requesting_enclave_tag() const {
  return _internal_has_requesting_enclave_tag();
}
inline void trust_request_message::clear_requesting_enclave_tag() {
  requesting_enclave_tag_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& trust_request_message::requesting_enclave_tag() const {
  // @@protoc_insertion_point(field_get:trust_request_message.requesting_enclave_tag)
  return _internal_requesting_enclave_tag();
}
inline void trust_request_message::set_requesting_enclave_tag(const std::string& value) {
  _internal_set_requesting_enclave_tag(value);
  // @@protoc_insertion_point(field_set:trust_request_message.requesting_enclave_tag)
}
inline std::string* trust_request_message::mutable_requesting_enclave_tag() {
  // @@protoc_insertion_point(field_mutable:trust_request_message.requesting_enclave_tag)
  return _internal_mutable_requesting_enclave_tag();
}
inline const std::string& trust_request_message::_internal_requesting_enclave_tag() const {
  return requesting_enclave_tag_.GetNoArena();
}
inline void trust_request_message::_internal_set_requesting_enclave_tag(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  requesting_enclave_tag_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
}
inline void trust_request_message::set_requesting_enclave_tag(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  requesting_enclave_tag_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:trust_request_message.requesting_enclave_tag)
}
inline void trust_request_message::set_requesting_enclave_tag(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  requesting_enclave_tag_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:trust_request_message.requesting_enclave_tag)
}
inline void trust_request_message::set_requesting_enclave_tag(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000001u;
  requesting_enclave_tag_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:trust_request_message.requesting_enclave_tag)
}
inline std::string* trust_request_message::_internal_mutable_requesting_enclave_tag() {
  _has_bits_[0] |= 0x00000001u;
  return requesting_enclave_tag_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* trust_request_message::release_requesting_enclave_tag() {
  // @@protoc_insertion_point(field_release:trust_request_message.requesting_enclave_tag)
  if (!_internal_has_requesting_enclave_tag()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return requesting_enclave_tag_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void trust_request_message::set_allocated_requesting_enclave_tag(std::string* requesting_enclave_tag) {
  if (requesting_enclave_tag != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  requesting_enclave_tag_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), requesting_enclave_tag);
  // @@protoc_insertion_point(field_set_allocated:trust_request_message.requesting_enclave_tag)
}

// optional string providing_enclave_tag = 2;
inline bool trust_request_message::_internal_has_providing_enclave_tag() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool trust_request_message::has_providing_enclave_tag() const {
  return _internal_has_providing_enclave_tag();
}
inline void trust_request_message::clear_providing_enclave_tag() {
  providing_enclave_tag_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& trust_request_message::providing_enclave_tag() const {
  // @@protoc_insertion_point(field_get:trust_request_message.providing_enclave_tag)
  return _internal_providing_enclave_tag();
}
inline void trust_request_message::set_providing_enclave_tag(const std::string& value) {
  _internal_set_providing_enclave_tag(value);
  // @@protoc_insertion_point(field_set:trust_request_message.providing_enclave_tag)
}
inline std::string* trust_request_message::mutable_providing_enclave_tag() {
  // @@protoc_insertion_point(field_mutable:trust_request_message.providing_enclave_tag)
  return _internal_mutable_providing_enclave_tag();
}
inline const std::string& trust_request_message::_internal_providing_enclave_tag() const {
  return providing_enclave_tag_.GetNoArena();
}
inline void trust_request_message::_internal_set_providing_enclave_tag(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  providing_enclave_tag_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
}
inline void trust_request_message::set_providing_enclave_tag(std::string&& value) {
  _has_bits_[0] |= 0x00000002u;
  providing_enclave_tag_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:trust_request_message.providing_enclave_tag)
}
inline void trust_request_message::set_providing_enclave_tag(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000002u;
  providing_enclave_tag_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:trust_request_message.providing_enclave_tag)
}
inline void trust_request_message::set_providing_enclave_tag(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000002u;
  providing_enclave_tag_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:trust_request_message.providing_enclave_tag)
}
inline std::string* trust_request_message::_internal_mutable_providing_enclave_tag() {
  _has_bits_[0] |= 0x00000002u;
  return providing_enclave_tag_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* trust_request_message::release_providing_enclave_tag() {
  // @@protoc_insertion_point(field_release:trust_request_message.providing_enclave_tag)
  if (!_internal_has_providing_enclave_tag()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  return providing_enclave_tag_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void trust_request_message::set_allocated_providing_enclave_tag(std::string* providing_enclave_tag) {
  if (providing_enclave_tag != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  providing_enclave_tag_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), providing_enclave_tag);
  // @@protoc_insertion_point(field_set_allocated:trust_request_message.providing_enclave_tag)
}

// optional string submitted_evidence_type = 3;
inline bool trust_request_message::_internal_has_submitted_evidence_type() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool trust_request_message::has_submitted_evidence_type() const {
  return _internal_has_submitted_evidence_type();
}
inline void trust_request_message::clear_submitted_evidence_type() {
  submitted_evidence_type_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000004u;
}
inline const std::string& trust_request_message::submitted_evidence_type() const {
  // @@protoc_insertion_point(field_get:trust_request_message.submitted_evidence_type)
  return _internal_submitted_evidence_type();
}
inline void trust_request_message::set_submitted_evidence_type(const std::string& value) {
  _internal_set_submitted_evidence_type(value);
  // @@protoc_insertion_point(field_set:trust_request_message.submitted_evidence_type)
}
inline std::string* trust_request_message::mutable_submitted_evidence_type() {
  // @@protoc_insertion_point(field_mutable:trust_request_message.submitted_evidence_type)
  return _internal_mutable_submitted_evidence_type();
}
inline const std::string& trust_request_message::_internal_submitted_evidence_type() const {
  return submitted_evidence_type_.GetNoArena();
}
inline void trust_request_message::_internal_set_submitted_evidence_type(const std::string& value) {
  _has_bits_[0] |= 0x00000004u;
  submitted_evidence_type_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
}
inline void trust_request_message::set_submitted_evidence_type(std::string&& value) {
  _has_bits_[0] |= 0x00000004u;
  submitted_evidence_type_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:trust_request_message.submitted_evidence_type)
}
inline void trust_request_message::set_submitted_evidence_type(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000004u;
  submitted_evidence_type_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:trust_request_message.submitted_evidence_type)
}
inline void trust_request_message::set_submitted_evidence_type(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000004u;
  submitted_evidence_type_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:trust_request_message.submitted_evidence_type)
}
inline std::string* trust_request_message::_internal_mutable_submitted_evidence_type() {
  _has_bits_[0] |= 0x00000004u;
  return submitted_evidence_type_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* trust_request_message::release_submitted_evidence_type() {
  // @@protoc_insertion_point(field_release:trust_request_message.submitted_evidence_type)
  if (!_internal_has_submitted_evidence_type()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000004u;
  return submitted_evidence_type_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void trust_request_message::set_allocated_submitted_evidence_type(std::string* submitted_evidence_type) {
  if (submitted_evidence_type != nullptr) {
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  submitted_evidence_type_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), submitted_evidence_type);
  // @@protoc_insertion_point(field_set_allocated:trust_request_message.submitted_evidence_type)
}

// optional string purpose = 4;
inline bool trust_request_message::_internal_has_purpose() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool trust_request_message::has_purpose() const {
  return _internal_has_purpose();
}
inline void trust_request_message::clear_purpose() {
  purpose_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000008u;
}
inline const std::string& trust_request_message::purpose() const {
  // @@protoc_insertion_point(field_get:trust_request_message.purpose)
  return _internal_purpose();
}
inline void trust_request_message::set_purpose(const std::string& value) {
  _internal_set_purpose(value);
  // @@protoc_insertion_point(field_set:trust_request_message.purpose)
}
inline std::string* trust_request_message::mutable_purpose() {
  // @@protoc_insertion_point(field_mutable:trust_request_message.purpose)
  return _internal_mutable_purpose();
}
inline const std::string& trust_request_message::_internal_purpose() const {
  return purpose_.GetNoArena();
}
inline void trust_request_message::_internal_set_purpose(const std::string& value) {
  _has_bits_[0] |= 0x00000008u;
  purpose_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
}
inline void trust_request_message::set_purpose(std::string&& value) {
  _has_bits_[0] |= 0x00000008u;
  purpose_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:trust_request_message.purpose)
}
inline void trust_request_message::set_purpose(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000008u;
  purpose_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:trust_request_message.purpose)
}
inline void trust_request_message::set_purpose(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000008u;
  purpose_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:trust_request_message.purpose)
}
inline std::string* trust_request_message::_internal_mutable_purpose() {
  _has_bits_[0] |= 0x00000008u;
  return purpose_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* trust_request_message::release_purpose() {
  // @@protoc_insertion_point(field_release:trust_request_message.purpose)
  if (!_internal_has_purpose()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000008u;
  return purpose_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void trust_request_message::set_allocated_purpose(std::string* purpose) {
  if (purpose != nullptr) {
    _has_bits_[0] |= 0x00000008u;
  } else {
    _has_bits_[0] &= ~0x00000008u;
  }
  purpose_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), purpose);
  // @@protoc_insertion_point(field_set_allocated:trust_request_message.purpose)
}

// optional .evidence_package support = 5;
inline bool trust_request_message::_internal_has_support() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  PROTOBUF_ASSUME(!value || support_ != nullptr);
  return value;
}
inline bool trust_request_message::has_support() const {
  return _internal_has_support();
}
inline void trust_request_message::clear_support() {
  if (support_ != nullptr) support_->Clear();
  _has_bits_[0] &= ~0x00000010u;
}
inline const ::evidence_package& trust_request_message::_internal_support() const {
  const ::evidence_package* p = support_;
  return p != nullptr ? *p : *reinterpret_cast<const ::evidence_package*>(
      &::_evidence_package_default_instance_);
}
inline const ::evidence_package& trust_request_message::support() const {
  // @@protoc_insertion_point(field_get:trust_request_message.support)
  return _internal_support();
}
inline ::evidence_package* trust_request_message::release_support() {
  // @@protoc_insertion_point(field_release:trust_request_message.support)
  _has_bits_[0] &= ~0x00000010u;
  ::evidence_package* temp = support_;
  support_ = nullptr;
  return temp;
}
inline ::evidence_package* trust_request_message::_internal_mutable_support() {
  _has_bits_[0] |= 0x00000010u;
  if (support_ == nullptr) {
    auto* p = CreateMaybeMessage<::evidence_package>(GetArenaNoVirtual());
    support_ = p;
  }
  return support_;
}
inline ::evidence_package* trust_request_message::mutable_support() {
  // @@protoc_insertion_point(field_mutable:trust_request_message.support)
  return _internal_mutable_support();
}
inline void trust_request_message::set_allocated_support(::evidence_package* support) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete support_;
  }
  if (support) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      support = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, support, submessage_arena);
    }
    _has_bits_[0] |= 0x00000010u;
  } else {
    _has_bits_[0] &= ~0x00000010u;
  }
  support_ = support;
  // @@protoc_insertion_point(field_set_allocated:trust_request_message.support)
}

// -------------------------------------------------------------------

// trust_response_message

// optional string status = 1;
inline bool trust_response_message::_internal_has_status() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool trust_response_message::has_status() const {
  return _internal_has_status();
}
inline void trust_response_message::clear_status() {
  status_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& trust_response_message::status() const {
  // @@protoc_insertion_point(field_get:trust_response_message.status)
  return _internal_status();
}
inline void trust_response_message::set_status(const std::string& value) {
  _internal_set_status(value);
  // @@protoc_insertion_point(field_set:trust_response_message.status)
}
inline std::string* trust_response_message::mutable_status() {
  // @@protoc_insertion_point(field_mutable:trust_response_message.status)
  return _internal_mutable_status();
}
inline const std::string& trust_response_message::_internal_status() const {
  return status_.GetNoArena();
}
inline void trust_response_message::_internal_set_status(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  status_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
}
inline void trust_response_message::set_status(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  status_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:trust_response_message.status)
}
inline void trust_response_message::set_status(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  status_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:trust_response_message.status)
}
inline void trust_response_message::set_status(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000001u;
  status_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:trust_response_message.status)
}
inline std::string* trust_response_message::_internal_mutable_status() {
  _has_bits_[0] |= 0x00000001u;
  return status_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* trust_response_message::release_status() {
  // @@protoc_insertion_point(field_release:trust_response_message.status)
  if (!_internal_has_status()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return status_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void trust_response_message::set_allocated_status(std::string* status) {
  if (status != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  status_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), status);
  // @@protoc_insertion_point(field_set_allocated:trust_response_message.status)
}

// optional string requesting_enclave_tag = 2;
inline bool trust_response_message::_internal_has_requesting_enclave_tag() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool trust_response_message::has_requesting_enclave_tag() const {
  return _internal_has_requesting_enclave_tag();
}
inline void trust_response_message::clear_requesting_enclave_tag() {
  requesting_enclave_tag_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& trust_response_message::requesting_enclave_tag() const {
  // @@protoc_insertion_point(field_get:trust_response_message.requesting_enclave_tag)
  return _internal_requesting_enclave_tag();
}
inline void trust_response_message::set_requesting_enclave_tag(const std::string& value) {
  _internal_set_requesting_enclave_tag(value);
  // @@protoc_insertion_point(field_set:trust_response_message.requesting_enclave_tag)
}
inline std::string* trust_response_message::mutable_requesting_enclave_tag() {
  // @@protoc_insertion_point(field_mutable:trust_response_message.requesting_enclave_tag)
  return _internal_mutable_requesting_enclave_tag();
}
inline const std::string& trust_response_message::_internal_requesting_enclave_tag() const {
  return requesting_enclave_tag_.GetNoArena();
}
inline void trust_response_message::_internal_set_requesting_enclave_tag(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  requesting_enclave_tag_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
}
inline void trust_response_message::set_requesting_enclave_tag(std::string&& value) {
  _has_bits_[0] |= 0x00000002u;
  requesting_enclave_tag_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:trust_response_message.requesting_enclave_tag)
}
inline void trust_response_message::set_requesting_enclave_tag(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000002u;
  requesting_enclave_tag_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:trust_response_message.requesting_enclave_tag)
}
inline void trust_response_message::set_requesting_enclave_tag(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000002u;
  requesting_enclave_tag_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:trust_response_message.requesting_enclave_tag)
}
inline std::string* trust_response_message::_internal_mutable_requesting_enclave_tag() {
  _has_bits_[0] |= 0x00000002u;
  return requesting_enclave_tag_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* trust_response_message::release_requesting_enclave_tag() {
  // @@protoc_insertion_point(field_release:trust_response_message.requesting_enclave_tag)
  if (!_internal_has_requesting_enclave_tag()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  return requesting_enclave_tag_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void trust_response_message::set_allocated_requesting_enclave_tag(std::string* requesting_enclave_tag) {
  if (requesting_enclave_tag != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  requesting_enclave_tag_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), requesting_enclave_tag);
  // @@protoc_insertion_point(field_set_allocated:trust_response_message.requesting_enclave_tag)
}

// optional string providing_enclave_tag = 3;
inline bool trust_response_message::_internal_has_providing_enclave_tag() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool trust_response_message::has_providing_enclave_tag() const {
  return _internal_has_providing_enclave_tag();
}
inline void trust_response_message::clear_providing_enclave_tag() {
  providing_enclave_tag_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000004u;
}
inline const std::string& trust_response_message::providing_enclave_tag() const {
  // @@protoc_insertion_point(field_get:trust_response_message.providing_enclave_tag)
  return _internal_providing_enclave_tag();
}
inline void trust_response_message::set_providing_enclave_tag(const std::string& value) {
  _internal_set_providing_enclave_tag(value);
  // @@protoc_insertion_point(field_set:trust_response_message.providing_enclave_tag)
}
inline std::string* trust_response_message::mutable_providing_enclave_tag() {
  // @@protoc_insertion_point(field_mutable:trust_response_message.providing_enclave_tag)
  return _internal_mutable_providing_enclave_tag();
}
inline const std::string& trust_response_message::_internal_providing_enclave_tag() const {
  return providing_enclave_tag_.GetNoArena();
}
inline void trust_response_message::_internal_set_providing_enclave_tag(const std::string& value) {
  _has_bits_[0] |= 0x00000004u;
  providing_enclave_tag_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
}
inline void trust_response_message::set_providing_enclave_tag(std::string&& value) {
  _has_bits_[0] |= 0x00000004u;
  providing_enclave_tag_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:trust_response_message.providing_enclave_tag)
}
inline void trust_response_message::set_providing_enclave_tag(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000004u;
  providing_enclave_tag_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:trust_response_message.providing_enclave_tag)
}
inline void trust_response_message::set_providing_enclave_tag(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000004u;
  providing_enclave_tag_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:trust_response_message.providing_enclave_tag)
}
inline std::string* trust_response_message::_internal_mutable_providing_enclave_tag() {
  _has_bits_[0] |= 0x00000004u;
  return providing_enclave_tag_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* trust_response_message::release_providing_enclave_tag() {
  // @@protoc_insertion_point(field_release:trust_response_message.providing_enclave_tag)
  if (!_internal_has_providing_enclave_tag()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000004u;
  return providing_enclave_tag_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void trust_response_message::set_allocated_providing_enclave_tag(std::string* providing_enclave_tag) {
  if (providing_enclave_tag != nullptr) {
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  providing_enclave_tag_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), providing_enclave_tag);
  // @@protoc_insertion_point(field_set_allocated:trust_response_message.providing_enclave_tag)
}

// optional bytes artifact = 4;
inline bool trust_response_message::_internal_has_artifact() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool trust_response_message::has_artifact() const {
  return _internal_has_artifact();
}
inline void trust_response_message::clear_artifact() {
  artifact_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000008u;
}
inline const std::string& trust_response_message::artifact() const {
  // @@protoc_insertion_point(field_get:trust_response_message.artifact)
  return _internal_artifact();
}
inline void trust_response_message::set_artifact(const std::string& value) {
  _internal_set_artifact(value);
  // @@protoc_insertion_point(field_set:trust_response_message.artifact)
}
inline std::string* trust_response_message::mutable_artifact() {
  // @@protoc_insertion_point(field_mutable:trust_response_message.artifact)
  return _internal_mutable_artifact();
}
inline const std::string& trust_response_message::_internal_artifact() const {
  return artifact_.GetNoArena();
}
inline void trust_response_message::_internal_set_artifact(const std::string& value) {
  _has_bits_[0] |= 0x00000008u;
  artifact_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
}
inline void trust_response_message::set_artifact(std::string&& value) {
  _has_bits_[0] |= 0x00000008u;
  artifact_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:trust_response_message.artifact)
}
inline void trust_response_message::set_artifact(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000008u;
  artifact_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:trust_response_message.artifact)
}
inline void trust_response_message::set_artifact(const void* value, size_t size) {
  _has_bits_[0] |= 0x00000008u;
  artifact_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:trust_response_message.artifact)
}
inline std::string* trust_response_message::_internal_mutable_artifact() {
  _has_bits_[0] |= 0x00000008u;
  return artifact_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* trust_response_message::release_artifact() {
  // @@protoc_insertion_point(field_release:trust_response_message.artifact)
  if (!_internal_has_artifact()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000008u;
  return artifact_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void trust_response_message::set_allocated_artifact(std::string* artifact) {
  if (artifact != nullptr) {
    _has_bits_[0] |= 0x00000008u;
  } else {
    _has_bits_[0] &= ~0x00000008u;
  }
  artifact_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), artifact);
  // @@protoc_insertion_point(field_set_allocated:trust_response_message.artifact)
}

// -------------------------------------------------------------------

// storage_info_message

// optional string storage_type = 1;
inline bool storage_info_message::_internal_has_storage_type() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool storage_info_message::has_storage_type() const {
  return _internal_has_storage_type();
}
inline void storage_info_message::clear_storage_type() {
  storage_type_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& storage_info_message::storage_type() const {
  // @@protoc_insertion_point(field_get:storage_info_message.storage_type)
  return _internal_storage_type();
}
inline void storage_info_message::set_storage_type(const std::string& value) {
  _internal_set_storage_type(value);
  // @@protoc_insertion_point(field_set:storage_info_message.storage_type)
}
inline std::string* storage_info_message::mutable_storage_type() {
  // @@protoc_insertion_point(field_mutable:storage_info_message.storage_type)
  return _internal_mutable_storage_type();
}
inline const std::string& storage_info_message::_internal_storage_type() const {
  return storage_type_.GetNoArena();
}
inline void storage_info_message::_internal_set_storage_type(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  storage_type_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
}
inline void storage_info_message::set_storage_type(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  storage_type_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:storage_info_message.storage_type)
}
inline void storage_info_message::set_storage_type(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  storage_type_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:storage_info_message.storage_type)
}
inline void storage_info_message::set_storage_type(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000001u;
  storage_type_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:storage_info_message.storage_type)
}
inline std::string* storage_info_message::_internal_mutable_storage_type() {
  _has_bits_[0] |= 0x00000001u;
  return storage_type_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* storage_info_message::release_storage_type() {
  // @@protoc_insertion_point(field_release:storage_info_message.storage_type)
  if (!_internal_has_storage_type()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return storage_type_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void storage_info_message::set_allocated_storage_type(std::string* storage_type) {
  if (storage_type != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  storage_type_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), storage_type);
  // @@protoc_insertion_point(field_set_allocated:storage_info_message.storage_type)
}

// optional string storage_descriptor = 2;
inline bool storage_info_message::_internal_has_storage_descriptor() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool storage_info_message::has_storage_descriptor() const {
  return _internal_has_storage_descriptor();
}
inline void storage_info_message::clear_storage_descriptor() {
  storage_descriptor_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& storage_info_message::storage_descriptor() const {
  // @@protoc_insertion_point(field_get:storage_info_message.storage_descriptor)
  return _internal_storage_descriptor();
}
inline void storage_info_message::set_storage_descriptor(const std::string& value) {
  _internal_set_storage_descriptor(value);
  // @@protoc_insertion_point(field_set:storage_info_message.storage_descriptor)
}
inline std::string* storage_info_message::mutable_storage_descriptor() {
  // @@protoc_insertion_point(field_mutable:storage_info_message.storage_descriptor)
  return _internal_mutable_storage_descriptor();
}
inline const std::string& storage_info_message::_internal_storage_descriptor() const {
  return storage_descriptor_.GetNoArena();
}
inline void storage_info_message::_internal_set_storage_descriptor(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  storage_descriptor_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
}
inline void storage_info_message::set_storage_descriptor(std::string&& value) {
  _has_bits_[0] |= 0x00000002u;
  storage_descriptor_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:storage_info_message.storage_descriptor)
}
inline void storage_info_message::set_storage_descriptor(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000002u;
  storage_descriptor_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:storage_info_message.storage_descriptor)
}
inline void storage_info_message::set_storage_descriptor(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000002u;
  storage_descriptor_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:storage_info_message.storage_descriptor)
}
inline std::string* storage_info_message::_internal_mutable_storage_descriptor() {
  _has_bits_[0] |= 0x00000002u;
  return storage_descriptor_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* storage_info_message::release_storage_descriptor() {
  // @@protoc_insertion_point(field_release:storage_info_message.storage_descriptor)
  if (!_internal_has_storage_descriptor()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  return storage_descriptor_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void storage_info_message::set_allocated_storage_descriptor(std::string* storage_descriptor) {
  if (storage_descriptor != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  storage_descriptor_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), storage_descriptor);
  // @@protoc_insertion_point(field_set_allocated:storage_info_message.storage_descriptor)
}

// optional string address = 3;
inline bool storage_info_message::_internal_has_address() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool storage_info_message::has_address() const {
  return _internal_has_address();
}
inline void storage_info_message::clear_address() {
  address_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000004u;
}
inline const std::string& storage_info_message::address() const {
  // @@protoc_insertion_point(field_get:storage_info_message.address)
  return _internal_address();
}
inline void storage_info_message::set_address(const std::string& value) {
  _internal_set_address(value);
  // @@protoc_insertion_point(field_set:storage_info_message.address)
}
inline std::string* storage_info_message::mutable_address() {
  // @@protoc_insertion_point(field_mutable:storage_info_message.address)
  return _internal_mutable_address();
}
inline const std::string& storage_info_message::_internal_address() const {
  return address_.GetNoArena();
}
inline void storage_info_message::_internal_set_address(const std::string& value) {
  _has_bits_[0] |= 0x00000004u;
  address_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
}
inline void storage_info_message::set_address(std::string&& value) {
  _has_bits_[0] |= 0x00000004u;
  address_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:storage_info_message.address)
}
inline void storage_info_message::set_address(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000004u;
  address_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:storage_info_message.address)
}
inline void storage_info_message::set_address(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000004u;
  address_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:storage_info_message.address)
}
inline std::string* storage_info_message::_internal_mutable_address() {
  _has_bits_[0] |= 0x00000004u;
  return address_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* storage_info_message::release_address() {
  // @@protoc_insertion_point(field_release:storage_info_message.address)
  if (!_internal_has_address()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000004u;
  return address_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void storage_info_message::set_allocated_address(std::string* address) {
  if (address != nullptr) {
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  address_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), address);
  // @@protoc_insertion_point(field_set_allocated:storage_info_message.address)
}

// optional .key_message storage_key = 4;
inline bool storage_info_message::_internal_has_storage_key() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  PROTOBUF_ASSUME(!value || storage_key_ != nullptr);
  return value;
}
inline bool storage_info_message::has_storage_key() const {
  return _internal_has_storage_key();
}
inline void storage_info_message::clear_storage_key() {
  if (storage_key_ != nullptr) storage_key_->Clear();
  _has_bits_[0] &= ~0x00000010u;
}
inline const ::key_message& storage_info_message::_internal_storage_key() const {
  const ::key_message* p = storage_key_;
  return p != nullptr ? *p : *reinterpret_cast<const ::key_message*>(
      &::_key_message_default_instance_);
}
inline const ::key_message& storage_info_message::storage_key() const {
  // @@protoc_insertion_point(field_get:storage_info_message.storage_key)
  return _internal_storage_key();
}
inline ::key_message* storage_info_message::release_storage_key() {
  // @@protoc_insertion_point(field_release:storage_info_message.storage_key)
  _has_bits_[0] &= ~0x00000010u;
  ::key_message* temp = storage_key_;
  storage_key_ = nullptr;
  return temp;
}
inline ::key_message* storage_info_message::_internal_mutable_storage_key() {
  _has_bits_[0] |= 0x00000010u;
  if (storage_key_ == nullptr) {
    auto* p = CreateMaybeMessage<::key_message>(GetArenaNoVirtual());
    storage_key_ = p;
  }
  return storage_key_;
}
inline ::key_message* storage_info_message::mutable_storage_key() {
  // @@protoc_insertion_point(field_mutable:storage_info_message.storage_key)
  return _internal_mutable_storage_key();
}
inline void storage_info_message::set_allocated_storage_key(::key_message* storage_key) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete storage_key_;
  }
  if (storage_key) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      storage_key = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, storage_key, submessage_arena);
    }
    _has_bits_[0] |= 0x00000010u;
  } else {
    _has_bits_[0] &= ~0x00000010u;
  }
  storage_key_ = storage_key;
  // @@protoc_insertion_point(field_set_allocated:storage_info_message.storage_key)
}

// optional string tag = 5;
inline bool storage_info_message::_internal_has_tag() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool storage_info_message::has_tag() const {
  return _internal_has_tag();
}
inline void storage_info_message::clear_tag() {
  tag_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000008u;
}
inline const std::string& storage_info_message::tag() const {
  // @@protoc_insertion_point(field_get:storage_info_message.tag)
  return _internal_tag();
}
inline void storage_info_message::set_tag(const std::string& value) {
  _internal_set_tag(value);
  // @@protoc_insertion_point(field_set:storage_info_message.tag)
}
inline std::string* storage_info_message::mutable_tag() {
  // @@protoc_insertion_point(field_mutable:storage_info_message.tag)
  return _internal_mutable_tag();
}
inline const std::string& storage_info_message::_internal_tag() const {
  return tag_.GetNoArena();
}
inline void storage_info_message::_internal_set_tag(const std::string& value) {
  _has_bits_[0] |= 0x00000008u;
  tag_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
}
inline void storage_info_message::set_tag(std::string&& value) {
  _has_bits_[0] |= 0x00000008u;
  tag_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:storage_info_message.tag)
}
inline void storage_info_message::set_tag(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000008u;
  tag_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:storage_info_message.tag)
}
inline void storage_info_message::set_tag(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000008u;
  tag_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:storage_info_message.tag)
}
inline std::string* storage_info_message::_internal_mutable_tag() {
  _has_bits_[0] |= 0x00000008u;
  return tag_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* storage_info_message::release_tag() {
  // @@protoc_insertion_point(field_release:storage_info_message.tag)
  if (!_internal_has_tag()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000008u;
  return tag_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void storage_info_message::set_allocated_tag(std::string* tag) {
  if (tag != nullptr) {
    _has_bits_[0] |= 0x00000008u;
  } else {
    _has_bits_[0] &= ~0x00000008u;
  }
  tag_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), tag);
  // @@protoc_insertion_point(field_set_allocated:storage_info_message.tag)
}

// -------------------------------------------------------------------

// channel_key_message

// optional string tag = 1;
inline bool channel_key_message::_internal_has_tag() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool channel_key_message::has_tag() const {
  return _internal_has_tag();
}
inline void channel_key_message::clear_tag() {
  tag_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& channel_key_message::tag() const {
  // @@protoc_insertion_point(field_get:channel_key_message.tag)
  return _internal_tag();
}
inline void channel_key_message::set_tag(const std::string& value) {
  _internal_set_tag(value);
  // @@protoc_insertion_point(field_set:channel_key_message.tag)
}
inline std::string* channel_key_message::mutable_tag() {
  // @@protoc_insertion_point(field_mutable:channel_key_message.tag)
  return _internal_mutable_tag();
}
inline const std::string& channel_key_message::_internal_tag() const {
  return tag_.GetNoArena();
}
inline void channel_key_message::_internal_set_tag(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  tag_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
}
inline void channel_key_message::set_tag(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  tag_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:channel_key_message.tag)
}
inline void channel_key_message::set_tag(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  tag_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:channel_key_message.tag)
}
inline void channel_key_message::set_tag(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000001u;
  tag_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:channel_key_message.tag)
}
inline std::string* channel_key_message::_internal_mutable_tag() {
  _has_bits_[0] |= 0x00000001u;
  return tag_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* channel_key_message::release_tag() {
  // @@protoc_insertion_point(field_release:channel_key_message.tag)
  if (!_internal_has_tag()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return tag_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void channel_key_message::set_allocated_tag(std::string* tag) {
  if (tag != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  tag_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), tag);
  // @@protoc_insertion_point(field_set_allocated:channel_key_message.tag)
}

// optional .key_message auth_key = 2;
inline bool channel_key_message::_internal_has_auth_key() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || auth_key_ != nullptr);
  return value;
}
inline bool channel_key_message::has_auth_key() const {
  return _internal_has_auth_key();
}
inline void channel_key_message::clear_auth_key() {
  if (auth_key_ != nullptr) auth_key_->Clear();
  _has_bits_[0] &= ~0x00000002u;
}
inline const ::key_message& channel_key_message::_internal_auth_key() const {
  const ::key_message* p = auth_key_;
  return p != nullptr ? *p : *reinterpret_cast<const ::key_message*>(
      &::_key_message_default_instance_);
}
inline const ::key_message& channel_key_message::auth_key() const {
  // @@protoc_insertion_point(field_get:channel_key_message.auth_key)
  return _internal_auth_key();
}
inline ::key_message* channel_key_message::release_auth_key() {
  // @@protoc_insertion_point(field_release:channel_key_message.auth_key)
  _has_bits_[0] &= ~0x00000002u;
  ::key_message* temp = auth_key_;
  auth_key_ = nullptr;
  return temp;
}
inline ::key_message* channel_key_message::_internal_mutable_auth_key() {
  _has_bits_[0] |= 0x00000002u;
  if (auth_key_ == nullptr) {
    auto* p = CreateMaybeMessage<::key_message>(GetArenaNoVirtual());
    auth_key_ = p;
  }
  return auth_key_;
}
inline ::key_message* channel_key_message::mutable_auth_key() {
  // @@protoc_insertion_point(field_mutable:channel_key_message.auth_key)
  return _internal_mutable_auth_key();
}
inline void channel_key_message::set_allocated_auth_key(::key_message* auth_key) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete auth_key_;
  }
  if (auth_key) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      auth_key = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, auth_key, submessage_arena);
    }
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  auth_key_ = auth_key;
  // @@protoc_insertion_point(field_set_allocated:channel_key_message.auth_key)
}

// -------------------------------------------------------------------

// trusted_service_message

// optional string trusted_service_address = 1;
inline bool trusted_service_message::_internal_has_trusted_service_address() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool trusted_service_message::has_trusted_service_address() const {
  return _internal_has_trusted_service_address();
}
inline void trusted_service_message::clear_trusted_service_address() {
  trusted_service_address_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& trusted_service_message::trusted_service_address() const {
  // @@protoc_insertion_point(field_get:trusted_service_message.trusted_service_address)
  return _internal_trusted_service_address();
}
inline void trusted_service_message::set_trusted_service_address(const std::string& value) {
  _internal_set_trusted_service_address(value);
  // @@protoc_insertion_point(field_set:trusted_service_message.trusted_service_address)
}
inline std::string* trusted_service_message::mutable_trusted_service_address() {
  // @@protoc_insertion_point(field_mutable:trusted_service_message.trusted_service_address)
  return _internal_mutable_trusted_service_address();
}
inline const std::string& trusted_service_message::_internal_trusted_service_address() const {
  return trusted_service_address_.GetNoArena();
}
inline void trusted_service_message::_internal_set_trusted_service_address(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  trusted_service_address_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
}
inline void trusted_service_message::set_trusted_service_address(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  trusted_service_address_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:trusted_service_message.trusted_service_address)
}
inline void trusted_service_message::set_trusted_service_address(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  trusted_service_address_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:trusted_service_message.trusted_service_address)
}
inline void trusted_service_message::set_trusted_service_address(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000001u;
  trusted_service_address_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:trusted_service_message.trusted_service_address)
}
inline std::string* trusted_service_message::_internal_mutable_trusted_service_address() {
  _has_bits_[0] |= 0x00000001u;
  return trusted_service_address_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* trusted_service_message::release_trusted_service_address() {
  // @@protoc_insertion_point(field_release:trusted_service_message.trusted_service_address)
  if (!_internal_has_trusted_service_address()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return trusted_service_address_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void trusted_service_message::set_allocated_trusted_service_address(std::string* trusted_service_address) {
  if (trusted_service_address != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  trusted_service_address_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), trusted_service_address);
  // @@protoc_insertion_point(field_set_allocated:trusted_service_message.trusted_service_address)
}

// optional .key_message trusted_service_key = 2;
inline bool trusted_service_message::_internal_has_trusted_service_key() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || trusted_service_key_ != nullptr);
  return value;
}
inline bool trusted_service_message::has_trusted_service_key() const {
  return _internal_has_trusted_service_key();
}
inline void trusted_service_message::clear_trusted_service_key() {
  if (trusted_service_key_ != nullptr) trusted_service_key_->Clear();
  _has_bits_[0] &= ~0x00000004u;
}
inline const ::key_message& trusted_service_message::_internal_trusted_service_key() const {
  const ::key_message* p = trusted_service_key_;
  return p != nullptr ? *p : *reinterpret_cast<const ::key_message*>(
      &::_key_message_default_instance_);
}
inline const ::key_message& trusted_service_message::trusted_service_key() const {
  // @@protoc_insertion_point(field_get:trusted_service_message.trusted_service_key)
  return _internal_trusted_service_key();
}
inline ::key_message* trusted_service_message::release_trusted_service_key() {
  // @@protoc_insertion_point(field_release:trusted_service_message.trusted_service_key)
  _has_bits_[0] &= ~0x00000004u;
  ::key_message* temp = trusted_service_key_;
  trusted_service_key_ = nullptr;
  return temp;
}
inline ::key_message* trusted_service_message::_internal_mutable_trusted_service_key() {
  _has_bits_[0] |= 0x00000004u;
  if (trusted_service_key_ == nullptr) {
    auto* p = CreateMaybeMessage<::key_message>(GetArenaNoVirtual());
    trusted_service_key_ = p;
  }
  return trusted_service_key_;
}
inline ::key_message* trusted_service_message::mutable_trusted_service_key() {
  // @@protoc_insertion_point(field_mutable:trusted_service_message.trusted_service_key)
  return _internal_mutable_trusted_service_key();
}
inline void trusted_service_message::set_allocated_trusted_service_key(::key_message* trusted_service_key) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete trusted_service_key_;
  }
  if (trusted_service_key) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      trusted_service_key = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, trusted_service_key, submessage_arena);
    }
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  trusted_service_key_ = trusted_service_key;
  // @@protoc_insertion_point(field_set_allocated:trusted_service_message.trusted_service_key)
}

// optional string tag = 3;
inline bool trusted_service_message::_internal_has_tag() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool trusted_service_message::has_tag() const {
  return _internal_has_tag();
}
inline void trusted_service_message::clear_tag() {
  tag_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& trusted_service_message::tag() const {
  // @@protoc_insertion_point(field_get:trusted_service_message.tag)
  return _internal_tag();
}
inline void trusted_service_message::set_tag(const std::string& value) {
  _internal_set_tag(value);
  // @@protoc_insertion_point(field_set:trusted_service_message.tag)
}
inline std::string* trusted_service_message::mutable_tag() {
  // @@protoc_insertion_point(field_mutable:trusted_service_message.tag)
  return _internal_mutable_tag();
}
inline const std::string& trusted_service_message::_internal_tag() const {
  return tag_.GetNoArena();
}
inline void trusted_service_message::_internal_set_tag(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  tag_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
}
inline void trusted_service_message::set_tag(std::string&& value) {
  _has_bits_[0] |= 0x00000002u;
  tag_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:trusted_service_message.tag)
}
inline void trusted_service_message::set_tag(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000002u;
  tag_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:trusted_service_message.tag)
}
inline void trusted_service_message::set_tag(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000002u;
  tag_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:trusted_service_message.tag)
}
inline std::string* trusted_service_message::_internal_mutable_tag() {
  _has_bits_[0] |= 0x00000002u;
  return tag_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* trusted_service_message::release_tag() {
  // @@protoc_insertion_point(field_release:trusted_service_message.tag)
  if (!_internal_has_tag()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  return tag_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void trusted_service_message::set_allocated_tag(std::string* tag) {
  if (tag != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  tag_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), tag);
  // @@protoc_insertion_point(field_set_allocated:trusted_service_message.tag)
}

// -------------------------------------------------------------------

// tagged_claim

// optional string tag = 1;
inline bool tagged_claim::_internal_has_tag() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool tagged_claim::has_tag() const {
  return _internal_has_tag();
}
inline void tagged_claim::clear_tag() {
  tag_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& tagged_claim::tag() const {
  // @@protoc_insertion_point(field_get:tagged_claim.tag)
  return _internal_tag();
}
inline void tagged_claim::set_tag(const std::string& value) {
  _internal_set_tag(value);
  // @@protoc_insertion_point(field_set:tagged_claim.tag)
}
inline std::string* tagged_claim::mutable_tag() {
  // @@protoc_insertion_point(field_mutable:tagged_claim.tag)
  return _internal_mutable_tag();
}
inline const std::string& tagged_claim::_internal_tag() const {
  return tag_.GetNoArena();
}
inline void tagged_claim::_internal_set_tag(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  tag_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
}
inline void tagged_claim::set_tag(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  tag_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:tagged_claim.tag)
}
inline void tagged_claim::set_tag(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  tag_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:tagged_claim.tag)
}
inline void tagged_claim::set_tag(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000001u;
  tag_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:tagged_claim.tag)
}
inline std::string* tagged_claim::_internal_mutable_tag() {
  _has_bits_[0] |= 0x00000001u;
  return tag_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* tagged_claim::release_tag() {
  // @@protoc_insertion_point(field_release:tagged_claim.tag)
  if (!_internal_has_tag()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return tag_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void tagged_claim::set_allocated_tag(std::string* tag) {
  if (tag != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  tag_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), tag);
  // @@protoc_insertion_point(field_set_allocated:tagged_claim.tag)
}

// optional .claim_message claim = 2;
inline bool tagged_claim::_internal_has_claim() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || claim_ != nullptr);
  return value;
}
inline bool tagged_claim::has_claim() const {
  return _internal_has_claim();
}
inline void tagged_claim::clear_claim() {
  if (claim_ != nullptr) claim_->Clear();
  _has_bits_[0] &= ~0x00000002u;
}
inline const ::claim_message& tagged_claim::_internal_claim() const {
  const ::claim_message* p = claim_;
  return p != nullptr ? *p : *reinterpret_cast<const ::claim_message*>(
      &::_claim_message_default_instance_);
}
inline const ::claim_message& tagged_claim::claim() const {
  // @@protoc_insertion_point(field_get:tagged_claim.claim)
  return _internal_claim();
}
inline ::claim_message* tagged_claim::release_claim() {
  // @@protoc_insertion_point(field_release:tagged_claim.claim)
  _has_bits_[0] &= ~0x00000002u;
  ::claim_message* temp = claim_;
  claim_ = nullptr;
  return temp;
}
inline ::claim_message* tagged_claim::_internal_mutable_claim() {
  _has_bits_[0] |= 0x00000002u;
  if (claim_ == nullptr) {
    auto* p = CreateMaybeMessage<::claim_message>(GetArenaNoVirtual());
    claim_ = p;
  }
  return claim_;
}
inline ::claim_message* tagged_claim::mutable_claim() {
  // @@protoc_insertion_point(field_mutable:tagged_claim.claim)
  return _internal_mutable_claim();
}
inline void tagged_claim::set_allocated_claim(::claim_message* claim) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete claim_;
  }
  if (claim) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      claim = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, claim, submessage_arena);
    }
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  claim_ = claim;
  // @@protoc_insertion_point(field_set_allocated:tagged_claim.claim)
}

// -------------------------------------------------------------------

// tagged_claims_sequence

// repeated .tagged_claim claims = 1;
inline int tagged_claims_sequence::_internal_claims_size() const {
  return claims_.size();
}
inline int tagged_claims_sequence::claims_size() const {
  return _internal_claims_size();
}
inline void tagged_claims_sequence::clear_claims() {
  claims_.Clear();
}
inline ::tagged_claim* tagged_claims_sequence::mutable_claims(int index) {
  // @@protoc_insertion_point(field_mutable:tagged_claims_sequence.claims)
  return claims_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::tagged_claim >*
tagged_claims_sequence::mutable_claims() {
  // @@protoc_insertion_point(field_mutable_list:tagged_claims_sequence.claims)
  return &claims_;
}
inline const ::tagged_claim& tagged_claims_sequence::_internal_claims(int index) const {
  return claims_.Get(index);
}
inline const ::tagged_claim& tagged_claims_sequence::claims(int index) const {
  // @@protoc_insertion_point(field_get:tagged_claims_sequence.claims)
  return _internal_claims(index);
}
inline ::tagged_claim* tagged_claims_sequence::_internal_add_claims() {
  return claims_.Add();
}
inline ::tagged_claim* tagged_claims_sequence::add_claims() {
  // @@protoc_insertion_point(field_add:tagged_claims_sequence.claims)
  return _internal_add_claims();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::tagged_claim >&
tagged_claims_sequence::claims() const {
  // @@protoc_insertion_point(field_list:tagged_claims_sequence.claims)
  return claims_;
}

// -------------------------------------------------------------------

// policy_store_message

// optional .key_message policy_key = 1;
inline bool policy_store_message::_internal_has_policy_key() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || policy_key_ != nullptr);
  return value;
}
inline bool policy_store_message::has_policy_key() const {
  return _internal_has_policy_key();
}
inline void policy_store_message::clear_policy_key() {
  if (policy_key_ != nullptr) policy_key_->Clear();
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::key_message& policy_store_message::_internal_policy_key() const {
  const ::key_message* p = policy_key_;
  return p != nullptr ? *p : *reinterpret_cast<const ::key_message*>(
      &::_key_message_default_instance_);
}
inline const ::key_message& policy_store_message::policy_key() const {
  // @@protoc_insertion_point(field_get:policy_store_message.policy_key)
  return _internal_policy_key();
}
inline ::key_message* policy_store_message::release_policy_key() {
  // @@protoc_insertion_point(field_release:policy_store_message.policy_key)
  _has_bits_[0] &= ~0x00000001u;
  ::key_message* temp = policy_key_;
  policy_key_ = nullptr;
  return temp;
}
inline ::key_message* policy_store_message::_internal_mutable_policy_key() {
  _has_bits_[0] |= 0x00000001u;
  if (policy_key_ == nullptr) {
    auto* p = CreateMaybeMessage<::key_message>(GetArenaNoVirtual());
    policy_key_ = p;
  }
  return policy_key_;
}
inline ::key_message* policy_store_message::mutable_policy_key() {
  // @@protoc_insertion_point(field_mutable:policy_store_message.policy_key)
  return _internal_mutable_policy_key();
}
inline void policy_store_message::set_allocated_policy_key(::key_message* policy_key) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete policy_key_;
  }
  if (policy_key) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      policy_key = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, policy_key, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  policy_key_ = policy_key;
  // @@protoc_insertion_point(field_set_allocated:policy_store_message.policy_key)
}

// repeated .trusted_service_message trusted_services = 2;
inline int policy_store_message::_internal_trusted_services_size() const {
  return trusted_services_.size();
}
inline int policy_store_message::trusted_services_size() const {
  return _internal_trusted_services_size();
}
inline void policy_store_message::clear_trusted_services() {
  trusted_services_.Clear();
}
inline ::trusted_service_message* policy_store_message::mutable_trusted_services(int index) {
  // @@protoc_insertion_point(field_mutable:policy_store_message.trusted_services)
  return trusted_services_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::trusted_service_message >*
policy_store_message::mutable_trusted_services() {
  // @@protoc_insertion_point(field_mutable_list:policy_store_message.trusted_services)
  return &trusted_services_;
}
inline const ::trusted_service_message& policy_store_message::_internal_trusted_services(int index) const {
  return trusted_services_.Get(index);
}
inline const ::trusted_service_message& policy_store_message::trusted_services(int index) const {
  // @@protoc_insertion_point(field_get:policy_store_message.trusted_services)
  return _internal_trusted_services(index);
}
inline ::trusted_service_message* policy_store_message::_internal_add_trusted_services() {
  return trusted_services_.Add();
}
inline ::trusted_service_message* policy_store_message::add_trusted_services() {
  // @@protoc_insertion_point(field_add:policy_store_message.trusted_services)
  return _internal_add_trusted_services();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::trusted_service_message >&
policy_store_message::trusted_services() const {
  // @@protoc_insertion_point(field_list:policy_store_message.trusted_services)
  return trusted_services_;
}

// repeated .channel_key_message channel_authentication_keys = 3;
inline int policy_store_message::_internal_channel_authentication_keys_size() const {
  return channel_authentication_keys_.size();
}
inline int policy_store_message::channel_authentication_keys_size() const {
  return _internal_channel_authentication_keys_size();
}
inline void policy_store_message::clear_channel_authentication_keys() {
  channel_authentication_keys_.Clear();
}
inline ::channel_key_message* policy_store_message::mutable_channel_authentication_keys(int index) {
  // @@protoc_insertion_point(field_mutable:policy_store_message.channel_authentication_keys)
  return channel_authentication_keys_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::channel_key_message >*
policy_store_message::mutable_channel_authentication_keys() {
  // @@protoc_insertion_point(field_mutable_list:policy_store_message.channel_authentication_keys)
  return &channel_authentication_keys_;
}
inline const ::channel_key_message& policy_store_message::_internal_channel_authentication_keys(int index) const {
  return channel_authentication_keys_.Get(index);
}
inline const ::channel_key_message& policy_store_message::channel_authentication_keys(int index) const {
  // @@protoc_insertion_point(field_get:policy_store_message.channel_authentication_keys)
  return _internal_channel_authentication_keys(index);
}
inline ::channel_key_message* policy_store_message::_internal_add_channel_authentication_keys() {
  return channel_authentication_keys_.Add();
}
inline ::channel_key_message* policy_store_message::add_channel_authentication_keys() {
  // @@protoc_insertion_point(field_add:policy_store_message.channel_authentication_keys)
  return _internal_add_channel_authentication_keys();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::channel_key_message >&
policy_store_message::channel_authentication_keys() const {
  // @@protoc_insertion_point(field_list:policy_store_message.channel_authentication_keys)
  return channel_authentication_keys_;
}

// repeated .tagged_claim claims = 4;
inline int policy_store_message::_internal_claims_size() const {
  return claims_.size();
}
inline int policy_store_message::claims_size() const {
  return _internal_claims_size();
}
inline void policy_store_message::clear_claims() {
  claims_.Clear();
}
inline ::tagged_claim* policy_store_message::mutable_claims(int index) {
  // @@protoc_insertion_point(field_mutable:policy_store_message.claims)
  return claims_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::tagged_claim >*
policy_store_message::mutable_claims() {
  // @@protoc_insertion_point(field_mutable_list:policy_store_message.claims)
  return &claims_;
}
inline const ::tagged_claim& policy_store_message::_internal_claims(int index) const {
  return claims_.Get(index);
}
inline const ::tagged_claim& policy_store_message::claims(int index) const {
  // @@protoc_insertion_point(field_get:policy_store_message.claims)
  return _internal_claims(index);
}
inline ::tagged_claim* policy_store_message::_internal_add_claims() {
  return claims_.Add();
}
inline ::tagged_claim* policy_store_message::add_claims() {
  // @@protoc_insertion_point(field_add:policy_store_message.claims)
  return _internal_add_claims();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::tagged_claim >&
policy_store_message::claims() const {
  // @@protoc_insertion_point(field_list:policy_store_message.claims)
  return claims_;
}

// repeated .storage_info_message storage_info = 5;
inline int policy_store_message::_internal_storage_info_size() const {
  return storage_info_.size();
}
inline int policy_store_message::storage_info_size() const {
  return _internal_storage_info_size();
}
inline void policy_store_message::clear_storage_info() {
  storage_info_.Clear();
}
inline ::storage_info_message* policy_store_message::mutable_storage_info(int index) {
  // @@protoc_insertion_point(field_mutable:policy_store_message.storage_info)
  return storage_info_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::storage_info_message >*
policy_store_message::mutable_storage_info() {
  // @@protoc_insertion_point(field_mutable_list:policy_store_message.storage_info)
  return &storage_info_;
}
inline const ::storage_info_message& policy_store_message::_internal_storage_info(int index) const {
  return storage_info_.Get(index);
}
inline const ::storage_info_message& policy_store_message::storage_info(int index) const {
  // @@protoc_insertion_point(field_get:policy_store_message.storage_info)
  return _internal_storage_info(index);
}
inline ::storage_info_message* policy_store_message::_internal_add_storage_info() {
  return storage_info_.Add();
}
inline ::storage_info_message* policy_store_message::add_storage_info() {
  // @@protoc_insertion_point(field_add:policy_store_message.storage_info)
  return _internal_add_storage_info();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::storage_info_message >&
policy_store_message::storage_info() const {
  // @@protoc_insertion_point(field_list:policy_store_message.storage_info)
  return storage_info_;
}

// repeated .tagged_signed_claim signed_claims = 6;
inline int policy_store_message::_internal_signed_claims_size() const {
  return signed_claims_.size();
}
inline int policy_store_message::signed_claims_size() const {
  return _internal_signed_claims_size();
}
inline void policy_store_message::clear_signed_claims() {
  signed_claims_.Clear();
}
inline ::tagged_signed_claim* policy_store_message::mutable_signed_claims(int index) {
  // @@protoc_insertion_point(field_mutable:policy_store_message.signed_claims)
  return signed_claims_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::tagged_signed_claim >*
policy_store_message::mutable_signed_claims() {
  // @@protoc_insertion_point(field_mutable_list:policy_store_message.signed_claims)
  return &signed_claims_;
}
inline const ::tagged_signed_claim& policy_store_message::_internal_signed_claims(int index) const {
  return signed_claims_.Get(index);
}
inline const ::tagged_signed_claim& policy_store_message::signed_claims(int index) const {
  // @@protoc_insertion_point(field_get:policy_store_message.signed_claims)
  return _internal_signed_claims(index);
}
inline ::tagged_signed_claim* policy_store_message::_internal_add_signed_claims() {
  return signed_claims_.Add();
}
inline ::tagged_signed_claim* policy_store_message::add_signed_claims() {
  // @@protoc_insertion_point(field_add:policy_store_message.signed_claims)
  return _internal_add_signed_claims();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::tagged_signed_claim >&
policy_store_message::signed_claims() const {
  // @@protoc_insertion_point(field_list:policy_store_message.signed_claims)
  return signed_claims_;
}

// repeated .tagged_blob_message blobs = 7;
inline int policy_store_message::_internal_blobs_size() const {
  return blobs_.size();
}
inline int policy_store_message::blobs_size() const {
  return _internal_blobs_size();
}
inline void policy_store_message::clear_blobs() {
  blobs_.Clear();
}
inline ::tagged_blob_message* policy_store_message::mutable_blobs(int index) {
  // @@protoc_insertion_point(field_mutable:policy_store_message.blobs)
  return blobs_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::tagged_blob_message >*
policy_store_message::mutable_blobs() {
  // @@protoc_insertion_point(field_mutable_list:policy_store_message.blobs)
  return &blobs_;
}
inline const ::tagged_blob_message& policy_store_message::_internal_blobs(int index) const {
  return blobs_.Get(index);
}
inline const ::tagged_blob_message& policy_store_message::blobs(int index) const {
  // @@protoc_insertion_point(field_get:policy_store_message.blobs)
  return _internal_blobs(index);
}
inline ::tagged_blob_message* policy_store_message::_internal_add_blobs() {
  return blobs_.Add();
}
inline ::tagged_blob_message* policy_store_message::add_blobs() {
  // @@protoc_insertion_point(field_add:policy_store_message.blobs)
  return _internal_add_blobs();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::tagged_blob_message >&
policy_store_message::blobs() const {
  // @@protoc_insertion_point(field_list:policy_store_message.blobs)
  return blobs_;
}

// -------------------------------------------------------------------

// claims_sequence

// repeated .claim_message claims = 1;
inline int claims_sequence::_internal_claims_size() const {
  return claims_.size();
}
inline int claims_sequence::claims_size() const {
  return _internal_claims_size();
}
inline void claims_sequence::clear_claims() {
  claims_.Clear();
}
inline ::claim_message* claims_sequence::mutable_claims(int index) {
  // @@protoc_insertion_point(field_mutable:claims_sequence.claims)
  return claims_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::claim_message >*
claims_sequence::mutable_claims() {
  // @@protoc_insertion_point(field_mutable_list:claims_sequence.claims)
  return &claims_;
}
inline const ::claim_message& claims_sequence::_internal_claims(int index) const {
  return claims_.Get(index);
}
inline const ::claim_message& claims_sequence::claims(int index) const {
  // @@protoc_insertion_point(field_get:claims_sequence.claims)
  return _internal_claims(index);
}
inline ::claim_message* claims_sequence::_internal_add_claims() {
  return claims_.Add();
}
inline ::claim_message* claims_sequence::add_claims() {
  // @@protoc_insertion_point(field_add:claims_sequence.claims)
  return _internal_add_claims();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::claim_message >&
claims_sequence::claims() const {
  // @@protoc_insertion_point(field_list:claims_sequence.claims)
  return claims_;
}

// -------------------------------------------------------------------

// signed_claim_sequence

// repeated .signed_claim_message claims = 1;
inline int signed_claim_sequence::_internal_claims_size() const {
  return claims_.size();
}
inline int signed_claim_sequence::claims_size() const {
  return _internal_claims_size();
}
inline void signed_claim_sequence::clear_claims() {
  claims_.Clear();
}
inline ::signed_claim_message* signed_claim_sequence::mutable_claims(int index) {
  // @@protoc_insertion_point(field_mutable:signed_claim_sequence.claims)
  return claims_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::signed_claim_message >*
signed_claim_sequence::mutable_claims() {
  // @@protoc_insertion_point(field_mutable_list:signed_claim_sequence.claims)
  return &claims_;
}
inline const ::signed_claim_message& signed_claim_sequence::_internal_claims(int index) const {
  return claims_.Get(index);
}
inline const ::signed_claim_message& signed_claim_sequence::claims(int index) const {
  // @@protoc_insertion_point(field_get:signed_claim_sequence.claims)
  return _internal_claims(index);
}
inline ::signed_claim_message* signed_claim_sequence::_internal_add_claims() {
  return claims_.Add();
}
inline ::signed_claim_message* signed_claim_sequence::add_claims() {
  // @@protoc_insertion_point(field_add:signed_claim_sequence.claims)
  return _internal_add_claims();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::signed_claim_message >&
signed_claim_sequence::claims() const {
  // @@protoc_insertion_point(field_list:signed_claim_sequence.claims)
  return claims_;
}

// -------------------------------------------------------------------

// tagged_signed_claim

// optional string tag = 1;
inline bool tagged_signed_claim::_internal_has_tag() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool tagged_signed_claim::has_tag() const {
  return _internal_has_tag();
}
inline void tagged_signed_claim::clear_tag() {
  tag_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& tagged_signed_claim::tag() const {
  // @@protoc_insertion_point(field_get:tagged_signed_claim.tag)
  return _internal_tag();
}
inline void tagged_signed_claim::set_tag(const std::string& value) {
  _internal_set_tag(value);
  // @@protoc_insertion_point(field_set:tagged_signed_claim.tag)
}
inline std::string* tagged_signed_claim::mutable_tag() {
  // @@protoc_insertion_point(field_mutable:tagged_signed_claim.tag)
  return _internal_mutable_tag();
}
inline const std::string& tagged_signed_claim::_internal_tag() const {
  return tag_.GetNoArena();
}
inline void tagged_signed_claim::_internal_set_tag(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  tag_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
}
inline void tagged_signed_claim::set_tag(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  tag_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:tagged_signed_claim.tag)
}
inline void tagged_signed_claim::set_tag(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  tag_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:tagged_signed_claim.tag)
}
inline void tagged_signed_claim::set_tag(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000001u;
  tag_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:tagged_signed_claim.tag)
}
inline std::string* tagged_signed_claim::_internal_mutable_tag() {
  _has_bits_[0] |= 0x00000001u;
  return tag_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* tagged_signed_claim::release_tag() {
  // @@protoc_insertion_point(field_release:tagged_signed_claim.tag)
  if (!_internal_has_tag()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return tag_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void tagged_signed_claim::set_allocated_tag(std::string* tag) {
  if (tag != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  tag_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), tag);
  // @@protoc_insertion_point(field_set_allocated:tagged_signed_claim.tag)
}

// optional .signed_claim_message sc = 2;
inline bool tagged_signed_claim::_internal_has_sc() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || sc_ != nullptr);
  return value;
}
inline bool tagged_signed_claim::has_sc() const {
  return _internal_has_sc();
}
inline void tagged_signed_claim::clear_sc() {
  if (sc_ != nullptr) sc_->Clear();
  _has_bits_[0] &= ~0x00000002u;
}
inline const ::signed_claim_message& tagged_signed_claim::_internal_sc() const {
  const ::signed_claim_message* p = sc_;
  return p != nullptr ? *p : *reinterpret_cast<const ::signed_claim_message*>(
      &::_signed_claim_message_default_instance_);
}
inline const ::signed_claim_message& tagged_signed_claim::sc() const {
  // @@protoc_insertion_point(field_get:tagged_signed_claim.sc)
  return _internal_sc();
}
inline ::signed_claim_message* tagged_signed_claim::release_sc() {
  // @@protoc_insertion_point(field_release:tagged_signed_claim.sc)
  _has_bits_[0] &= ~0x00000002u;
  ::signed_claim_message* temp = sc_;
  sc_ = nullptr;
  return temp;
}
inline ::signed_claim_message* tagged_signed_claim::_internal_mutable_sc() {
  _has_bits_[0] |= 0x00000002u;
  if (sc_ == nullptr) {
    auto* p = CreateMaybeMessage<::signed_claim_message>(GetArenaNoVirtual());
    sc_ = p;
  }
  return sc_;
}
inline ::signed_claim_message* tagged_signed_claim::mutable_sc() {
  // @@protoc_insertion_point(field_mutable:tagged_signed_claim.sc)
  return _internal_mutable_sc();
}
inline void tagged_signed_claim::set_allocated_sc(::signed_claim_message* sc) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete sc_;
  }
  if (sc) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      sc = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, sc, submessage_arena);
    }
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  sc_ = sc;
  // @@protoc_insertion_point(field_set_allocated:tagged_signed_claim.sc)
}

// -------------------------------------------------------------------

// buffer_sequence

// repeated bytes block = 1;
inline int buffer_sequence::_internal_block_size() const {
  return block_.size();
}
inline int buffer_sequence::block_size() const {
  return _internal_block_size();
}
inline void buffer_sequence::clear_block() {
  block_.Clear();
}
inline std::string* buffer_sequence::add_block() {
  // @@protoc_insertion_point(field_add_mutable:buffer_sequence.block)
  return _internal_add_block();
}
inline const std::string& buffer_sequence::_internal_block(int index) const {
  return block_.Get(index);
}
inline const std::string& buffer_sequence::block(int index) const {
  // @@protoc_insertion_point(field_get:buffer_sequence.block)
  return _internal_block(index);
}
inline std::string* buffer_sequence::mutable_block(int index) {
  // @@protoc_insertion_point(field_mutable:buffer_sequence.block)
  return block_.Mutable(index);
}
inline void buffer_sequence::set_block(int index, const std::string& value) {
  // @@protoc_insertion_point(field_set:buffer_sequence.block)
  block_.Mutable(index)->assign(value);
}
inline void buffer_sequence::set_block(int index, std::string&& value) {
  // @@protoc_insertion_point(field_set:buffer_sequence.block)
  block_.Mutable(index)->assign(std::move(value));
}
inline void buffer_sequence::set_block(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  block_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:buffer_sequence.block)
}
inline void buffer_sequence::set_block(int index, const void* value, size_t size) {
  block_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:buffer_sequence.block)
}
inline std::string* buffer_sequence::_internal_add_block() {
  return block_.Add();
}
inline void buffer_sequence::add_block(const std::string& value) {
  block_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:buffer_sequence.block)
}
inline void buffer_sequence::add_block(std::string&& value) {
  block_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:buffer_sequence.block)
}
inline void buffer_sequence::add_block(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  block_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:buffer_sequence.block)
}
inline void buffer_sequence::add_block(const void* value, size_t size) {
  block_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:buffer_sequence.block)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
buffer_sequence::block() const {
  // @@protoc_insertion_point(field_list:buffer_sequence.block)
  return block_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
buffer_sequence::mutable_block() {
  // @@protoc_insertion_point(field_mutable_list:buffer_sequence.block)
  return &block_;
}

// -------------------------------------------------------------------

// run_request

// optional string location = 1;
inline bool run_request::_internal_has_location() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool run_request::has_location() const {
  return _internal_has_location();
}
inline void run_request::clear_location() {
  location_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& run_request::location() const {
  // @@protoc_insertion_point(field_get:run_request.location)
  return _internal_location();
}
inline void run_request::set_location(const std::string& value) {
  _internal_set_location(value);
  // @@protoc_insertion_point(field_set:run_request.location)
}
inline std::string* run_request::mutable_location() {
  // @@protoc_insertion_point(field_mutable:run_request.location)
  return _internal_mutable_location();
}
inline const std::string& run_request::_internal_location() const {
  return location_.GetNoArena();
}
inline void run_request::_internal_set_location(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  location_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
}
inline void run_request::set_location(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  location_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:run_request.location)
}
inline void run_request::set_location(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  location_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:run_request.location)
}
inline void run_request::set_location(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000001u;
  location_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:run_request.location)
}
inline std::string* run_request::_internal_mutable_location() {
  _has_bits_[0] |= 0x00000001u;
  return location_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* run_request::release_location() {
  // @@protoc_insertion_point(field_release:run_request.location)
  if (!_internal_has_location()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return location_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void run_request::set_allocated_location(std::string* location) {
  if (location != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  location_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), location);
  // @@protoc_insertion_point(field_set_allocated:run_request.location)
}

// optional bytes cert = 2;
inline bool run_request::_internal_has_cert() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool run_request::has_cert() const {
  return _internal_has_cert();
}
inline void run_request::clear_cert() {
  cert_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& run_request::cert() const {
  // @@protoc_insertion_point(field_get:run_request.cert)
  return _internal_cert();
}
inline void run_request::set_cert(const std::string& value) {
  _internal_set_cert(value);
  // @@protoc_insertion_point(field_set:run_request.cert)
}
inline std::string* run_request::mutable_cert() {
  // @@protoc_insertion_point(field_mutable:run_request.cert)
  return _internal_mutable_cert();
}
inline const std::string& run_request::_internal_cert() const {
  return cert_.GetNoArena();
}
inline void run_request::_internal_set_cert(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  cert_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
}
inline void run_request::set_cert(std::string&& value) {
  _has_bits_[0] |= 0x00000002u;
  cert_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:run_request.cert)
}
inline void run_request::set_cert(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000002u;
  cert_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:run_request.cert)
}
inline void run_request::set_cert(const void* value, size_t size) {
  _has_bits_[0] |= 0x00000002u;
  cert_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:run_request.cert)
}
inline std::string* run_request::_internal_mutable_cert() {
  _has_bits_[0] |= 0x00000002u;
  return cert_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* run_request::release_cert() {
  // @@protoc_insertion_point(field_release:run_request.cert)
  if (!_internal_has_cert()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  return cert_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void run_request::set_allocated_cert(std::string* cert) {
  if (cert != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  cert_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), cert);
  // @@protoc_insertion_point(field_set_allocated:run_request.cert)
}

// repeated string args = 3;
inline int run_request::_internal_args_size() const {
  return args_.size();
}
inline int run_request::args_size() const {
  return _internal_args_size();
}
inline void run_request::clear_args() {
  args_.Clear();
}
inline std::string* run_request::add_args() {
  // @@protoc_insertion_point(field_add_mutable:run_request.args)
  return _internal_add_args();
}
inline const std::string& run_request::_internal_args(int index) const {
  return args_.Get(index);
}
inline const std::string& run_request::args(int index) const {
  // @@protoc_insertion_point(field_get:run_request.args)
  return _internal_args(index);
}
inline std::string* run_request::mutable_args(int index) {
  // @@protoc_insertion_point(field_mutable:run_request.args)
  return args_.Mutable(index);
}
inline void run_request::set_args(int index, const std::string& value) {
  // @@protoc_insertion_point(field_set:run_request.args)
  args_.Mutable(index)->assign(value);
}
inline void run_request::set_args(int index, std::string&& value) {
  // @@protoc_insertion_point(field_set:run_request.args)
  args_.Mutable(index)->assign(std::move(value));
}
inline void run_request::set_args(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  args_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:run_request.args)
}
inline void run_request::set_args(int index, const char* value, size_t size) {
  args_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:run_request.args)
}
inline std::string* run_request::_internal_add_args() {
  return args_.Add();
}
inline void run_request::add_args(const std::string& value) {
  args_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:run_request.args)
}
inline void run_request::add_args(std::string&& value) {
  args_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:run_request.args)
}
inline void run_request::add_args(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  args_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:run_request.args)
}
inline void run_request::add_args(const char* value, size_t size) {
  args_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:run_request.args)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
run_request::args() const {
  // @@protoc_insertion_point(field_list:run_request.args)
  return args_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
run_request::mutable_args() {
  // @@protoc_insertion_point(field_mutable_list:run_request.args)
  return &args_;
}

// -------------------------------------------------------------------

// run_response

// optional string status = 1;
inline bool run_response::_internal_has_status() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool run_response::has_status() const {
  return _internal_has_status();
}
inline void run_response::clear_status() {
  status_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& run_response::status() const {
  // @@protoc_insertion_point(field_get:run_response.status)
  return _internal_status();
}
inline void run_response::set_status(const std::string& value) {
  _internal_set_status(value);
  // @@protoc_insertion_point(field_set:run_response.status)
}
inline std::string* run_response::mutable_status() {
  // @@protoc_insertion_point(field_mutable:run_response.status)
  return _internal_mutable_status();
}
inline const std::string& run_response::_internal_status() const {
  return status_.GetNoArena();
}
inline void run_response::_internal_set_status(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  status_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
}
inline void run_response::set_status(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  status_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:run_response.status)
}
inline void run_response::set_status(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  status_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:run_response.status)
}
inline void run_response::set_status(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000001u;
  status_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:run_response.status)
}
inline std::string* run_response::_internal_mutable_status() {
  _has_bits_[0] |= 0x00000001u;
  return status_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* run_response::release_status() {
  // @@protoc_insertion_point(field_release:run_response.status)
  if (!_internal_has_status()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return status_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void run_response::set_allocated_status(std::string* status) {
  if (status != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  status_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), status);
  // @@protoc_insertion_point(field_set_allocated:run_response.status)
}

// -------------------------------------------------------------------

// app_request

// optional string function = 1;
inline bool app_request::_internal_has_function() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool app_request::has_function() const {
  return _internal_has_function();
}
inline void app_request::clear_function() {
  function_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& app_request::function() const {
  // @@protoc_insertion_point(field_get:app_request.function)
  return _internal_function();
}
inline void app_request::set_function(const std::string& value) {
  _internal_set_function(value);
  // @@protoc_insertion_point(field_set:app_request.function)
}
inline std::string* app_request::mutable_function() {
  // @@protoc_insertion_point(field_mutable:app_request.function)
  return _internal_mutable_function();
}
inline const std::string& app_request::_internal_function() const {
  return function_.GetNoArena();
}
inline void app_request::_internal_set_function(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  function_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
}
inline void app_request::set_function(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  function_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:app_request.function)
}
inline void app_request::set_function(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  function_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:app_request.function)
}
inline void app_request::set_function(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000001u;
  function_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:app_request.function)
}
inline std::string* app_request::_internal_mutable_function() {
  _has_bits_[0] |= 0x00000001u;
  return function_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* app_request::release_function() {
  // @@protoc_insertion_point(field_release:app_request.function)
  if (!_internal_has_function()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return function_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void app_request::set_allocated_function(std::string* function) {
  if (function != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  function_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), function);
  // @@protoc_insertion_point(field_set_allocated:app_request.function)
}

// repeated bytes args = 2;
inline int app_request::_internal_args_size() const {
  return args_.size();
}
inline int app_request::args_size() const {
  return _internal_args_size();
}
inline void app_request::clear_args() {
  args_.Clear();
}
inline std::string* app_request::add_args() {
  // @@protoc_insertion_point(field_add_mutable:app_request.args)
  return _internal_add_args();
}
inline const std::string& app_request::_internal_args(int index) const {
  return args_.Get(index);
}
inline const std::string& app_request::args(int index) const {
  // @@protoc_insertion_point(field_get:app_request.args)
  return _internal_args(index);
}
inline std::string* app_request::mutable_args(int index) {
  // @@protoc_insertion_point(field_mutable:app_request.args)
  return args_.Mutable(index);
}
inline void app_request::set_args(int index, const std::string& value) {
  // @@protoc_insertion_point(field_set:app_request.args)
  args_.Mutable(index)->assign(value);
}
inline void app_request::set_args(int index, std::string&& value) {
  // @@protoc_insertion_point(field_set:app_request.args)
  args_.Mutable(index)->assign(std::move(value));
}
inline void app_request::set_args(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  args_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:app_request.args)
}
inline void app_request::set_args(int index, const void* value, size_t size) {
  args_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:app_request.args)
}
inline std::string* app_request::_internal_add_args() {
  return args_.Add();
}
inline void app_request::add_args(const std::string& value) {
  args_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:app_request.args)
}
inline void app_request::add_args(std::string&& value) {
  args_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:app_request.args)
}
inline void app_request::add_args(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  args_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:app_request.args)
}
inline void app_request::add_args(const void* value, size_t size) {
  args_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:app_request.args)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
app_request::args() const {
  // @@protoc_insertion_point(field_list:app_request.args)
  return args_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
app_request::mutable_args() {
  // @@protoc_insertion_point(field_mutable_list:app_request.args)
  return &args_;
}

// -------------------------------------------------------------------

// app_response

// optional string function = 1;
inline bool app_response::_internal_has_function() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool app_response::has_function() const {
  return _internal_has_function();
}
inline void app_response::clear_function() {
  function_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& app_response::function() const {
  // @@protoc_insertion_point(field_get:app_response.function)
  return _internal_function();
}
inline void app_response::set_function(const std::string& value) {
  _internal_set_function(value);
  // @@protoc_insertion_point(field_set:app_response.function)
}
inline std::string* app_response::mutable_function() {
  // @@protoc_insertion_point(field_mutable:app_response.function)
  return _internal_mutable_function();
}
inline const std::string& app_response::_internal_function() const {
  return function_.GetNoArena();
}
inline void app_response::_internal_set_function(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  function_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
}
inline void app_response::set_function(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  function_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:app_response.function)
}
inline void app_response::set_function(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  function_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:app_response.function)
}
inline void app_response::set_function(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000001u;
  function_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:app_response.function)
}
inline std::string* app_response::_internal_mutable_function() {
  _has_bits_[0] |= 0x00000001u;
  return function_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* app_response::release_function() {
  // @@protoc_insertion_point(field_release:app_response.function)
  if (!_internal_has_function()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return function_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void app_response::set_allocated_function(std::string* function) {
  if (function != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  function_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), function);
  // @@protoc_insertion_point(field_set_allocated:app_response.function)
}

// optional string status = 2;
inline bool app_response::_internal_has_status() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool app_response::has_status() const {
  return _internal_has_status();
}
inline void app_response::clear_status() {
  status_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& app_response::status() const {
  // @@protoc_insertion_point(field_get:app_response.status)
  return _internal_status();
}
inline void app_response::set_status(const std::string& value) {
  _internal_set_status(value);
  // @@protoc_insertion_point(field_set:app_response.status)
}
inline std::string* app_response::mutable_status() {
  // @@protoc_insertion_point(field_mutable:app_response.status)
  return _internal_mutable_status();
}
inline const std::string& app_response::_internal_status() const {
  return status_.GetNoArena();
}
inline void app_response::_internal_set_status(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  status_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
}
inline void app_response::set_status(std::string&& value) {
  _has_bits_[0] |= 0x00000002u;
  status_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:app_response.status)
}
inline void app_response::set_status(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000002u;
  status_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:app_response.status)
}
inline void app_response::set_status(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000002u;
  status_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:app_response.status)
}
inline std::string* app_response::_internal_mutable_status() {
  _has_bits_[0] |= 0x00000002u;
  return status_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* app_response::release_status() {
  // @@protoc_insertion_point(field_release:app_response.status)
  if (!_internal_has_status()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  return status_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void app_response::set_allocated_status(std::string* status) {
  if (status != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  status_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), status);
  // @@protoc_insertion_point(field_set_allocated:app_response.status)
}

// repeated bytes args = 3;
inline int app_response::_internal_args_size() const {
  return args_.size();
}
inline int app_response::args_size() const {
  return _internal_args_size();
}
inline void app_response::clear_args() {
  args_.Clear();
}
inline std::string* app_response::add_args() {
  // @@protoc_insertion_point(field_add_mutable:app_response.args)
  return _internal_add_args();
}
inline const std::string& app_response::_internal_args(int index) const {
  return args_.Get(index);
}
inline const std::string& app_response::args(int index) const {
  // @@protoc_insertion_point(field_get:app_response.args)
  return _internal_args(index);
}
inline std::string* app_response::mutable_args(int index) {
  // @@protoc_insertion_point(field_mutable:app_response.args)
  return args_.Mutable(index);
}
inline void app_response::set_args(int index, const std::string& value) {
  // @@protoc_insertion_point(field_set:app_response.args)
  args_.Mutable(index)->assign(value);
}
inline void app_response::set_args(int index, std::string&& value) {
  // @@protoc_insertion_point(field_set:app_response.args)
  args_.Mutable(index)->assign(std::move(value));
}
inline void app_response::set_args(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  args_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:app_response.args)
}
inline void app_response::set_args(int index, const void* value, size_t size) {
  args_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:app_response.args)
}
inline std::string* app_response::_internal_add_args() {
  return args_.Add();
}
inline void app_response::add_args(const std::string& value) {
  args_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:app_response.args)
}
inline void app_response::add_args(std::string&& value) {
  args_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:app_response.args)
}
inline void app_response::add_args(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  args_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:app_response.args)
}
inline void app_response::add_args(const void* value, size_t size) {
  args_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:app_response.args)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
app_response::args() const {
  // @@protoc_insertion_point(field_list:app_response.args)
  return args_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
app_response::mutable_args() {
  // @@protoc_insertion_point(field_mutable_list:app_response.args)
  return &args_;
}

// -------------------------------------------------------------------

// tagged_blob_message

// optional string tag = 1;
inline bool tagged_blob_message::_internal_has_tag() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool tagged_blob_message::has_tag() const {
  return _internal_has_tag();
}
inline void tagged_blob_message::clear_tag() {
  tag_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& tagged_blob_message::tag() const {
  // @@protoc_insertion_point(field_get:tagged_blob_message.tag)
  return _internal_tag();
}
inline void tagged_blob_message::set_tag(const std::string& value) {
  _internal_set_tag(value);
  // @@protoc_insertion_point(field_set:tagged_blob_message.tag)
}
inline std::string* tagged_blob_message::mutable_tag() {
  // @@protoc_insertion_point(field_mutable:tagged_blob_message.tag)
  return _internal_mutable_tag();
}
inline const std::string& tagged_blob_message::_internal_tag() const {
  return tag_.GetNoArena();
}
inline void tagged_blob_message::_internal_set_tag(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  tag_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
}
inline void tagged_blob_message::set_tag(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  tag_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:tagged_blob_message.tag)
}
inline void tagged_blob_message::set_tag(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  tag_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:tagged_blob_message.tag)
}
inline void tagged_blob_message::set_tag(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000001u;
  tag_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:tagged_blob_message.tag)
}
inline std::string* tagged_blob_message::_internal_mutable_tag() {
  _has_bits_[0] |= 0x00000001u;
  return tag_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* tagged_blob_message::release_tag() {
  // @@protoc_insertion_point(field_release:tagged_blob_message.tag)
  if (!_internal_has_tag()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return tag_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void tagged_blob_message::set_allocated_tag(std::string* tag) {
  if (tag != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  tag_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), tag);
  // @@protoc_insertion_point(field_set_allocated:tagged_blob_message.tag)
}

// optional bytes b = 2;
inline bool tagged_blob_message::_internal_has_b() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool tagged_blob_message::has_b() const {
  return _internal_has_b();
}
inline void tagged_blob_message::clear_b() {
  b_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& tagged_blob_message::b() const {
  // @@protoc_insertion_point(field_get:tagged_blob_message.b)
  return _internal_b();
}
inline void tagged_blob_message::set_b(const std::string& value) {
  _internal_set_b(value);
  // @@protoc_insertion_point(field_set:tagged_blob_message.b)
}
inline std::string* tagged_blob_message::mutable_b() {
  // @@protoc_insertion_point(field_mutable:tagged_blob_message.b)
  return _internal_mutable_b();
}
inline const std::string& tagged_blob_message::_internal_b() const {
  return b_.GetNoArena();
}
inline void tagged_blob_message::_internal_set_b(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  b_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
}
inline void tagged_blob_message::set_b(std::string&& value) {
  _has_bits_[0] |= 0x00000002u;
  b_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:tagged_blob_message.b)
}
inline void tagged_blob_message::set_b(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000002u;
  b_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:tagged_blob_message.b)
}
inline void tagged_blob_message::set_b(const void* value, size_t size) {
  _has_bits_[0] |= 0x00000002u;
  b_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:tagged_blob_message.b)
}
inline std::string* tagged_blob_message::_internal_mutable_b() {
  _has_bits_[0] |= 0x00000002u;
  return b_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* tagged_blob_message::release_b() {
  // @@protoc_insertion_point(field_release:tagged_blob_message.b)
  if (!_internal_has_b()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  return b_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void tagged_blob_message::set_allocated_b(std::string* b) {
  if (b != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  b_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), b);
  // @@protoc_insertion_point(field_set_allocated:tagged_blob_message.b)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)


// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_certifier_2eproto
